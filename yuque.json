[
  {
    "id": 2131338,
    "slug": "ge8c8t",
    "title": "关于nginx",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"LVWhw\"></a>\n# What\nNginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。\n\n![](https://cdn.nlark.com/yuque/0/2019/jpeg/92887/1563278513924-0ae579e4-e8a4-4bff-be76-d58bb7778cba.jpeg#align=left&display=inline&height=506&originHeight=506&originWidth=688&size=0&status=done&width=688)\n\n<a name=\"rrTrs\"></a>\n## 反向代理\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/92887/1563278539375-dfe54c83-19fb-4c78-8aa9-56e6086f4a8d.png#align=left&display=inline&height=401&name=image.png&originHeight=501&originWidth=441&size=147840&status=done&width=352.8)<br />当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。\n\n服务器根据客户端的请求，从其关联的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在\n\n<a name=\"ryksr\"></a>\n## 正向代理\n![](https://cdn.nlark.com/yuque/0/2019/jpeg/92887/1563278625606-3f0b6177-812c-4608-93c7-9f213a7ab3c8.jpeg#align=left&display=inline&height=269&originHeight=269&originWidth=349&size=0&status=done&width=349)<br />由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，正向代理“代理”的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。\n\n<a name=\"CpWyV\"></a>\n# 工作方式\nMaster-Worker模式<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/92887/1563278687914-b9c2c1b0-1df3-43a9-83cf-d8a867773389.jpeg#align=left&display=inline&height=446&originHeight=446&originWidth=599&size=0&status=done&width=599)<br />启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。\n\n<a name=\"Rzcsb\"></a>\n# 安装\n这个参考的是中文官网，但注意的是，官网上依赖的包不是最新的，可能会找不到相应的资源，自己注意替换为最新的<br />[http://www.nginx.cn/install](http://www.nginx.cn/install)\n\n<a name=\"psm0s\"></a>\n# 配置\n我按照默认来，配置是在nginx.conf文件中\n\n1. 修改user 参数，nginx默认启动的是nobody用户，需要修改为指定用户，不然会导致读取目录权限出错的问题；\n1. server -- location 中修改root 指定到你需要指定的内容目录\n1. 实际工作中，会根据host来管理conf，会把所有的conf放在vhost目录中，方便管理，只需要在nginx.conf加载vhost目录即可，如下：\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/92887/1563279097613-62a39124-98fa-4413-930d-0db477fa0ea6.png#align=left&display=inline&height=34&name=image.png&originHeight=43&originWidth=222&size=3636&status=done&width=177.6)\n\n<a name=\"7J8hk\"></a>\n# 命令\n\n```php\n{nginx_home}/nginx                      # 启动nginx\n{nginx_home}/nginx -s reload            # 重新载入配置文件\n{nginx_home}/nginx -s reopen            # 重启 Nginx\n{nginx_home}/nginx -s stop              # 停止 Nginx\n```\n\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"LVWhw\">What</h1><p><span style=\"color: #1A1A1A;\">Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</span></p><p><span style=\"color: #1A1A1A;\"><br /></span><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/92887/1563278513924-0ae579e4-e8a4-4bff-be76-d58bb7778cba.jpeg#align=left&amp;display=inline&amp;height=506&amp;originHeight=506&amp;originWidth=688&amp;size=0&amp;status=done&amp;width=688\" style=\"max-width: 600px; width: 688px;\" /></p><p><span style=\"color: #1A1A1A;\"><br /></span></p><h2 id=\"rrTrs\">反向代理</h2><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1563278539375-dfe54c83-19fb-4c78-8aa9-56e6086f4a8d.png#align=left&amp;display=inline&amp;height=401&amp;name=image.png&amp;originHeight=501&amp;originWidth=441&amp;size=147840&amp;status=done&amp;width=352.8\" style=\"max-width: 600px; width: 352.8px;\" /></p><p><span style=\"color: #1A1A1A;\">当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。</span></p><p><span style=\"color: #1A1A1A;\"><br /></span></p><p>服务器根据客户端的请求，从其关联的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在</p><p><br /></p><h2 id=\"ryksr\">正向代理</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/92887/1563278625606-3f0b6177-812c-4608-93c7-9f213a7ab3c8.jpeg#align=left&amp;display=inline&amp;height=269&amp;originHeight=269&amp;originWidth=349&amp;size=0&amp;status=done&amp;width=349\" style=\"max-width: 600px; width: 349px;\" /></p><p><span style=\"color: #1A1A1A;\">由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，正向代理“代理”的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</span></p><p><br /></p><h1 id=\"CpWyV\">工作方式</h1><p>Master-Worker模式</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/92887/1563278687914-b9c2c1b0-1df3-43a9-83cf-d8a867773389.jpeg#align=left&amp;display=inline&amp;height=446&amp;originHeight=446&amp;originWidth=599&amp;size=0&amp;status=done&amp;width=599\" style=\"max-width: 600px; width: 599px;\" /></p><p><span style=\"color: #1A1A1A;\">启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</span></p><p><span style=\"color: #1A1A1A;\"><br /></span></p><p><br /></p><h1 id=\"Rzcsb\">安装</h1><p>这个参考的是中文官网，但注意的是，官网上依赖的包不是最新的，可能会找不到相应的资源，自己注意替换为最新的</p><p><a href=\"http://www.nginx.cn/install\" target=\"_blank\">http://www.nginx.cn/install</a></p><p><br /></p><h1 id=\"psm0s\">配置</h1><p>我按照默认来，配置是在nginx.conf文件中</p><ol start=\"1\"><li>修改user 参数，nginx默认启动的是nobody用户，需要修改为指定用户，不然会导致读取目录权限出错的问题；</li><li>server -- location 中修改root 指定到你需要指定的内容目录</li><li>实际工作中，会根据host来管理conf，会把所有的conf放在vhost目录中，方便管理，只需要在nginx.conf加载vhost目录即可，如下：</li></ol><p style=\"padding-left: 2em;\"><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1563279097613-62a39124-98fa-4413-930d-0db477fa0ea6.png#align=left&amp;display=inline&amp;height=34&amp;name=image.png&amp;originHeight=43&amp;originWidth=222&amp;size=3636&amp;status=done&amp;width=177.6\" style=\"max-width: 600px; width: 177.6px;\" /></p><p><br /></p><h1 id=\"7J8hk\">命令</h1><p><br /></p><pre data-lang=\"php\"><code>{nginx_home}/nginx                      # 启动nginx\n{nginx_home}/nginx -s reload            # 重新载入配置文件\n{nginx_home}/nginx -s reopen            # 重启 Nginx\n{nginx_home}/nginx -s stop              # 停止 Nginx</code></pre><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"LVWhw\">What</h1><p><span style=\"color: #1A1A1A;\">Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</span></p><p><span style=\"color: #1A1A1A;\"><br /></span><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F92887%2F1563278513924-0ae579e4-e8a4-4bff-be76-d58bb7778cba.jpeg%22%2C%22originWidth%22%3A688%2C%22originHeight%22%3A506%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A688%2C%22height%22%3A506%7D\"></card></p><p><span style=\"color: #1A1A1A;\"><br /></span></p><h2 id=\"rrTrs\">反向代理</h2><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1563278539375-dfe54c83-19fb-4c78-8aa9-56e6086f4a8d.png%22%2C%22originWidth%22%3A441%2C%22originHeight%22%3A501%2C%22name%22%3A%22image.png%22%2C%22size%22%3A147840%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A352.8%2C%22height%22%3A401%7D\"></card></p><p><span style=\"color: #1A1A1A;\">当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。</span></p><p><span style=\"color: #1A1A1A;\"><br /></span></p><p>服务器根据客户端的请求，从其关联的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在</p><p><br /></p><h2 id=\"ryksr\">正向代理</h2><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F92887%2F1563278625606-3f0b6177-812c-4608-93c7-9f213a7ab3c8.jpeg%22%2C%22originWidth%22%3A349%2C%22originHeight%22%3A269%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A349%2C%22height%22%3A269%7D\"></card></p><p><span style=\"color: #1A1A1A;\">由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，正向代理“代理”的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</span></p><p><br /></p><h1 id=\"CpWyV\">工作方式</h1><p>Master-Worker模式</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F92887%2F1563278687914-b9c2c1b0-1df3-43a9-83cf-d8a867773389.jpeg%22%2C%22originWidth%22%3A599%2C%22originHeight%22%3A446%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A599%2C%22height%22%3A446%7D\"></card></p><p><span style=\"color: #1A1A1A;\">启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</span></p><p><span style=\"color: #1A1A1A;\"><br /></span></p><p><br /></p><h1 id=\"Rzcsb\">安装</h1><p>这个参考的是中文官网，但注意的是，官网上依赖的包不是最新的，可能会找不到相应的资源，自己注意替换为最新的</p><p><a href=\"http://www.nginx.cn/install\" target=\"_blank\">http://www.nginx.cn/install</a></p><p><br /></p><h1 id=\"psm0s\">配置</h1><p>我按照默认来，配置是在nginx.conf文件中</p><ol start=\"1\"><li>修改user 参数，nginx默认启动的是nobody用户，需要修改为指定用户，不然会导致读取目录权限出错的问题；</li><li>server -- location 中修改root 指定到你需要指定的内容目录</li><li>实际工作中，会根据host来管理conf，会把所有的conf放在vhost目录中，方便管理，只需要在nginx.conf加载vhost目录即可，如下：</li></ol><p style=\"padding-left: 2em;\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1563279097613-62a39124-98fa-4413-930d-0db477fa0ea6.png%22%2C%22originWidth%22%3A222%2C%22originHeight%22%3A43%2C%22name%22%3A%22image.png%22%2C%22size%22%3A3636%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A177.6%2C%22height%22%3A34%7D\"></card></p><p><br /></p><h1 id=\"7J8hk\">命令</h1><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22php%22%2C%22code%22%3A%22%7Bnginx_home%7D%2Fnginx%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E5%90%AF%E5%8A%A8nginx%5Cn%7Bnginx_home%7D%2Fnginx%20-s%20reload%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E9%87%8D%E6%96%B0%E8%BD%BD%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%5Cn%7Bnginx_home%7D%2Fnginx%20-s%20reopen%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E9%87%8D%E5%90%AF%20Nginx%5Cn%7Bnginx_home%7D%2Fnginx%20-s%20stop%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E5%81%9C%E6%AD%A2%20Nginx%22%2C%22id%22%3A%22raxFY%22%7D\"></card><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-07-17T02:27:36.000Z",
    "deleted_at": null,
    "created_at": "2019-07-16T11:57:13.000Z",
    "updated_at": "2019-07-17T02:27:36.000Z",
    "published_at": "2019-07-16T12:16:18.000Z",
    "first_published_at": "2019-07-16T12:16:18.000Z",
    "word_count": 560,
    "cover": null,
    "description": "WhatNginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。反向代理当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。服...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 2074934,
    "slug": "zcpa4u",
    "title": "django migrate报错",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"iyBJN\"></a>\n# 背景\n学习django过程中，执行python manage.py migrate报错，提示如下：\n\n```python\ndjango.db.utils.ProgrammingError: (1064, \"You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '(6) NOT\n NULL)' at line 1\")\n```\n\n<a name=\"5fVdB\"></a>\n# 过程\n直接google，说是因为django2.1+版本需要mysql版本要5.6+，因此先判断下自己的版本<br />Django      2.2.3<br />mysql 5.5.4\n\ndjango版本直接pip list查看，因为是pip安装；<br />mysql的版本的话，直接输入select version();\n\n那么确定是版本问到导致的，解决方法，也提供了，如下：\n\n```python\n# 在项目的settings.py最上面添加如下代码\nfrom django.db.backends.mysql.base import DatabaseWrapper\nDatabaseWrapper.data_types['DateTimeField'] = 'datetime' # fix for MySQL 5.5\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/92887/1562663317661-fbf601fb-7bd9-4243-b077-dc37f6c32444.png#align=left&display=inline&height=386&name=image.png&originHeight=482&originWidth=1520&size=101977&status=done&width=1216)\n",
    "body_draft": "",
    "body_html": "<h1 id=\"iyBJN\">背景</h1><p>学习django过程中，执行python manage.py migrate报错，提示如下：</p><p><br /></p><pre data-lang=\"python\"><code>django.db.utils.ProgrammingError: (1064, &quot;You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '(6) NOT\n NULL)' at line 1&quot;)</code></pre><p><br /></p><h1 id=\"5fVdB\">过程</h1><p>直接google，说是因为django2.1+版本需要mysql版本要5.6+，因此先判断下自己的版本</p><p>Django      2.2.3</p><p>mysql 5.5.4</p><p><br /></p><p>django版本直接pip list查看，因为是pip安装；</p><p>mysql的版本的话，直接输入select version();</p><p><br /></p><p>那么确定是版本问到导致的，解决方法，也提供了，如下：</p><p><br /></p><pre data-lang=\"python\"><code># 在项目的settings.py最上面添加如下代码\nfrom django.db.backends.mysql.base import DatabaseWrapper\nDatabaseWrapper.data_types['DateTimeField'] = 'datetime' # fix for MySQL 5.5</code></pre><p><br /></p><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1562663317661-fbf601fb-7bd9-4243-b077-dc37f6c32444.png#align=left&amp;display=inline&amp;height=386&amp;name=image.png&amp;originHeight=482&amp;originWidth=1520&amp;size=101977&amp;status=done&amp;width=1216\" style=\"max-width: 600px; width: 1216px;\" /></p>",
    "body_lake": "<!doctype lake><h1 id=\"iyBJN\">背景</h1><p>学习django过程中，执行python manage.py migrate报错，提示如下：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22django.db.utils.ProgrammingError%3A%20(1064%2C%20%5C%22You%20have%20an%20error%20in%20your%20SQL%20syntax%3B%20check%20the%20manual%20that%20corresponds%20to%20your%20MySQL%20server%20version%20for%20the%20right%20syntax%20to%20use%20near%20'(6)%20NOT%5Cn%20NULL)'%20at%20line%201%5C%22)%22%2C%22id%22%3A%22PuMdA%22%7D\"></card><p><br /></p><h1 id=\"5fVdB\">过程</h1><p>直接google，说是因为django2.1+版本需要mysql版本要5.6+，因此先判断下自己的版本</p><p>Django      2.2.3</p><p>mysql 5.5.4</p><p><br /></p><p>django版本直接pip list查看，因为是pip安装；</p><p>mysql的版本的话，直接输入select version();</p><p><br /></p><p>那么确定是版本问到导致的，解决方法，也提供了，如下：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22%23%20%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9A%84settings.py%E6%9C%80%E4%B8%8A%E9%9D%A2%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%5Cnfrom%20django.db.backends.mysql.base%20import%20DatabaseWrapper%5CnDatabaseWrapper.data_types%5B'DateTimeField'%5D%20%3D%20'datetime'%20%23%20fix%20for%20MySQL%205.5%22%2C%22id%22%3A%22XpteE%22%7D\"></card><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1562663317661-fbf601fb-7bd9-4243-b077-dc37f6c32444.png%22%2C%22originWidth%22%3A1520%2C%22originHeight%22%3A482%2C%22name%22%3A%22image.png%22%2C%22size%22%3A101977%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1216%2C%22height%22%3A386%7D\"></card><cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-07-09T09:08:44.000Z",
    "deleted_at": null,
    "created_at": "2019-07-09T09:02:27.000Z",
    "updated_at": "2019-07-09T09:08:45.000Z",
    "published_at": "2019-07-09T09:08:44.000Z",
    "first_published_at": "2019-07-09T09:08:44.000Z",
    "word_count": 181,
    "cover": null,
    "description": "背景学习django过程中，执行python manage.py migrate报错，提示如下：django.db.utils.ProgrammingError: (1064, &quot;You have an error in your SQL syntax; check the manu...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 2063127,
    "slug": "ucd7bk",
    "title": "source命令",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"wNOpI\"></a>\n# 背景\nsource命令，之前一直用来加载环境变量的，source一下然后执行某个sh，使其环境变量生效，但对细节没有追究；<br />今天在看公司一个sh脚本的时候发现有个sh只有source命令，按照之前的理解source命令并没有执行的过程呀，难道一个source也可以执行命令吗？\n\n<a name=\"jiAqZ\"></a>\n# 过程\n百度/google了一下，发现标题多为source和sh/. 执行的区别，那么就先确定了source也有执行命令的效果，且他还有一定的区别\n\nsource命令：<br />source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。<br />功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句<br />source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。<br />用法：<br />source filename 或 . filename<br />source命令(从 C Shell 而来)是bash shell的内置命令;点命令(.)，就是个点符号(从Bourne Shell而来)是source的另一名称。\n\nsource filename 与 sh filename 及./filename执行脚本的区别在那里呢？<br />1.当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有\".\"是用来表示当前目录的。<br />2.sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。<br />3.source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，**没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面**。\n\n<a name=\"dvB21\"></a>\n# 实例\n举例说明：\n\n1. 新建一个test.sh脚本，内容为:A=1\n1. 然后使其可执行chmod +x test.sh\n1. 运行sh test.sh后，echo $A，显示为空，因为A=1并未传回给当前shell\n1. 运行./test.sh后，也是一样的效果\n1. 运行source test.sh 或者 . test.sh，然后echo $A，则会显示1，说明A=1的变量在当前shell中\n\n<a name=\"yN3u3\"></a>\n# 后记\n翻阅文档后，恍然大悟，保留到当前shell中确实可以生效；\n\n<a name=\"m39uh\"></a>\n# 资料\n[http://www.51testing.com/html/38/225738-206878.html](http://www.51testing.com/html/38/225738-206878.html)\n",
    "body_draft": "",
    "body_html": "<h1 id=\"wNOpI\">背景</h1><p>source命令，之前一直用来加载环境变量的，source一下然后执行某个sh，使其环境变量生效，但对细节没有追究；</p><p>今天在看公司一个sh脚本的时候发现有个sh只有source命令，按照之前的理解source命令并没有执行的过程呀，难道一个source也可以执行命令吗？</p><p><br /></p><h1 id=\"jiAqZ\">过程</h1><p>百度/google了一下，发现标题多为source和sh/. 执行的区别，那么就先确定了source也有执行命令的效果，且他还有一定的区别</p><p><br /></p><p>source命令：</p><p>source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。</p><p>功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句</p><p>source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。</p><p>用法：</p><p>source filename 或 . filename</p><p>source命令(从 C Shell 而来)是bash shell的内置命令;点命令(.)，就是个点符号(从Bourne Shell而来)是source的另一名称。</p><p><br /></p><p>source filename 与 sh filename 及./filename执行脚本的区别在那里呢？</p><p>1.当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有&quot;.&quot;是用来表示当前目录的。</p><p>2.sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。</p><p>3.source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，<strong>没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面</strong>。</p><p><br /></p><h1 id=\"dvB21\">实例</h1><p>举例说明：</p><ol start=\"1\"><li>新建一个test.sh脚本，内容为:A=1</li><li>然后使其可执行chmod +x test.sh</li><li>运行sh test.sh后，echo $A，显示为空，因为A=1并未传回给当前shell</li><li>运行./test.sh后，也是一样的效果</li><li>运行source test.sh 或者 . test.sh，然后echo $A，则会显示1，说明A=1的变量在当前shell中</li></ol><p><br /></p><h1 id=\"yN3u3\">后记</h1><p>翻阅文档后，恍然大悟，保留到当前shell中确实可以生效；</p><p><br /></p><h1 id=\"m39uh\">资料</h1><p><a href=\"http://www.51testing.com/html/38/225738-206878.html\" target=\"_blank\">http://www.51testing.com/html/38/225738-206878.html</a></p>",
    "body_lake": "<!doctype lake><h1 id=\"wNOpI\">背景</h1><p>source命令，之前一直用来加载环境变量的，source一下然后执行某个sh，使其环境变量生效，但对细节没有追究；</p><p>今天在看公司一个sh脚本的时候发现有个sh只有source命令，按照之前的理解source命令并没有执行的过程呀，难道一个source也可以执行命令吗？</p><p><br /></p><h1 id=\"jiAqZ\">过程</h1><p>百度/google了一下，发现标题多为source和sh/. 执行的区别，那么就先确定了source也有执行命令的效果，且他还有一定的区别</p><p><br /></p><p>source命令：</p><p>source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。</p><p>功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句</p><p>source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。</p><p>用法：</p><p>source filename 或 . filename</p><p>source命令(从 C Shell 而来)是bash shell的内置命令;点命令(.)，就是个点符号(从Bourne Shell而来)是source的另一名称。</p><p><br /></p><p>source filename 与 sh filename 及./filename执行脚本的区别在那里呢？</p><p>1.当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有&quot;.&quot;是用来表示当前目录的。</p><p>2.sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。</p><p>3.source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，<strong>没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面</strong>。</p><p><br /></p><h1 id=\"dvB21\">实例</h1><p>举例说明：</p><ol start=\"1\"><li>新建一个test.sh脚本，内容为:A=1</li><li>然后使其可执行chmod +x test.sh</li><li>运行sh test.sh后，echo $A，显示为空，因为A=1并未传回给当前shell</li><li>运行./test.sh后，也是一样的效果</li><li>运行source test.sh 或者 . test.sh，然后echo $A，则会显示1，说明A=1的变量在当前shell中</li></ol><p><br /></p><h1 id=\"yN3u3\">后记</h1><p>翻阅文档后，恍然大悟，保留到当前shell中确实可以生效；</p><p><br /></p><h1 id=\"m39uh\">资料</h1><p><a href=\"http://www.51testing.com/html/38/225738-206878.html\" target=\"_blank\">http://www.51testing.com/html/38/225738-206878.html</a></p>",
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-07-08T07:11:07.000Z",
    "deleted_at": null,
    "created_at": "2019-07-08T06:46:14.000Z",
    "updated_at": "2019-07-08T07:11:07.000Z",
    "published_at": "2019-07-08T06:54:03.000Z",
    "first_published_at": "2019-07-08T06:54:03.000Z",
    "word_count": 609,
    "cover": null,
    "description": "背景source命令，之前一直用来加载环境变量的，source一下然后执行某个sh，使其环境变量生效，但对细节没有追究；今天在看公司一个sh脚本的时候发现有个sh只有source命令，按照之前的理解source命令并没有执行的过程呀，难道一个source也可以执行命令吗？过程百度/google...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1942155,
    "slug": "gvmetc",
    "title": "redis 多实例",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8maLG\"></a>\n# 背景\n业务侧需要起一个新的redis实例来存储，避免干扰到现有的实例数据，现在有的redis实例是6379端口，还有一个6380端这个是redis从库的\n\n<a name=\"6LbwC\"></a>\n# 操作\n\n1. 查看redis的help文档，你会发现如下：\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/92887/1560952631181-c3ebe187-166e-487a-9e7d-190ecc1acac7.png#align=left&display=inline&height=341&name=image.png&originHeight=341&originWidth=879&size=40442&status=done&width=879)<br />\n\n2. 我们可以启动指定conf文件的形式，接下来我们查看下现有的6379.conf（一般的目录为/etc/redis/）\n\n我们需要修改的地方：\n\n```\nport 6379\ndaemonize no\npidfile /var/run/redis_6379.pid\nlogfile /data/redis/log/redis.log\ndbfilename dump.rdb\ndir /data/redis/data\n```\n根据字段名很好的理解，其中要注意的就是daemonize 这里需要把no修改为yes，意思是以守护进程启动，就是可以后台运行；其他可以直接替换6379位6380即可（假设新的实例端口为6380）<br />\n\n3. 启动实例，redis-server /etc/redis/redis_6380.conf就可以了\n3. 验证，ps -ef | grep redis\n\n<a name=\"BFZYv\"></a>\n# 疑问\n其中有个slaveof的参数。如上图的操作 ./redis-server --port 7777 --slaveof 127.0.0.1 8888 ，本地起了一个7777端口的实例，这个实例的是本地8888端口实例的从库，如果8888端口实例有更新，7777端口的实例也会同步更新\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8maLG\">背景</h1><p>业务侧需要起一个新的redis实例来存储，避免干扰到现有的实例数据，现在有的redis实例是6379端口，还有一个6380端这个是redis从库的</p><p><br /></p><h1 id=\"6LbwC\">操作</h1><ol start=\"1\"><li>查看redis的help文档，你会发现如下：</li></ol><p style=\"text-indent: 2em;\"><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1560952631181-c3ebe187-166e-487a-9e7d-190ecc1acac7.png#align=left&amp;display=inline&amp;height=341&amp;name=image.png&amp;originHeight=341&amp;originWidth=879&amp;size=40442&amp;status=done&amp;width=879\" style=\"max-width: 600px; width: 879px;\" /></p><p style=\"text-indent: 2em;\"><br /></p><ol start=\"2\"><li>我们可以启动指定conf文件的形式，接下来我们查看下现有的6379.conf（一般的目录为/etc/redis/）</li></ol><p style=\"padding-left: 2em;\">我们需要修改的地方：</p><p><br /></p><pre><code>port 6379\ndaemonize no\npidfile /var/run/redis_6379.pid\nlogfile /data/redis/log/redis.log\ndbfilename dump.rdb\ndir /data/redis/data</code></pre><p style=\"text-indent: 2em;\">根据字段名很好的理解，其中要注意的就是daemonize 这里需要把no修改为yes，意思是以守护进程启动，就是可以后台运行；其他可以直接替换6379位6380即可（假设新的实例端口为6380）</p><p style=\"text-indent: 2em;\"><br /></p><ol start=\"3\"><li>启动实例，redis-server /etc/redis/redis_6380.conf就可以了</li><li>验证，ps -ef | grep redis</li></ol><p><br /></p><h1 id=\"BFZYv\">疑问</h1><p>其中有个slaveof的参数。如上图的操作 ./redis-server --port 7777 --slaveof 127.0.0.1 8888 ，本地起了一个7777端口的实例，这个实例的是本地8888端口实例的从库，如果8888端口实例有更新，7777端口的实例也会同步更新</p>",
    "body_lake": "<!doctype lake><h1 id=\"8maLG\">背景</h1><p>业务侧需要起一个新的redis实例来存储，避免干扰到现有的实例数据，现在有的redis实例是6379端口，还有一个6380端这个是redis从库的</p><p><br /></p><h1 id=\"6LbwC\">操作</h1><ol start=\"1\"><li>查看redis的help文档，你会发现如下：</li></ol><p style=\"text-indent: 2em;\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1560952631181-c3ebe187-166e-487a-9e7d-190ecc1acac7.png%22%2C%22originWidth%22%3A879%2C%22originHeight%22%3A341%2C%22name%22%3A%22image.png%22%2C%22size%22%3A40442%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A879%2C%22height%22%3A341%7D\"></card></p><p style=\"text-indent: 2em;\"><br /></p><ol start=\"2\"><li>我们可以启动指定conf文件的形式，接下来我们查看下现有的6379.conf（一般的目录为/etc/redis/）</li></ol><p style=\"padding-left: 2em;\">我们需要修改的地方：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22port%206379%5Cndaemonize%20no%5Cnpidfile%20%2Fvar%2Frun%2Fredis_6379.pid%5Cnlogfile%20%2Fdata%2Fredis%2Flog%2Fredis.log%5Cndbfilename%20dump.rdb%5Cndir%20%2Fdata%2Fredis%2Fdata%22%2C%22id%22%3A%22OIhLX%22%7D\"></card><p style=\"text-indent: 2em;\">根据字段名很好的理解，其中要注意的就是daemonize 这里需要把no修改为yes，意思是以守护进程启动，就是可以后台运行；其他可以直接替换6379位6380即可（假设新的实例端口为6380）</p><p style=\"text-indent: 2em;\"><br /></p><ol start=\"3\"><li>启动实例，redis-server /etc/redis/redis_6380.conf就可以了</li><li>验证，ps -ef | grep redis</li></ol><p><br /></p><h1 id=\"BFZYv\">疑问</h1><p>其中有个slaveof的参数。如上图的操作 ./redis-server --port 7777 --slaveof 127.0.0.1 8888 ，本地起了一个7777端口的实例，这个实例的是本地8888端口实例的从库，如果8888端口实例有更新，7777端口的实例也会同步更新</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-06-19T14:05:24.000Z",
    "deleted_at": null,
    "created_at": "2019-06-19T13:53:24.000Z",
    "updated_at": "2019-06-19T14:05:25.000Z",
    "published_at": "2019-06-19T14:05:24.000Z",
    "first_published_at": "2019-06-19T14:05:24.000Z",
    "word_count": 303,
    "cover": null,
    "description": "背景业务侧需要起一个新的redis实例来存储，避免干扰到现有的实例数据，现在有的redis实例是6379端口，还有一个6380端这个是redis从库的操作查看redis的help文档，你会发现如下：我们可以启动指定conf文件的形式，接下来我们查看下现有的6379.conf（一般的目录为/et...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1786659,
    "slug": "xzotq6",
    "title": "阿里创新自动化测试工具平台--Doom",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "摘要： 阿里内部诞生一了个依赖真实流量用于自动回归的自动化测试平台，通过创新的自动mock机制不仅支持读接口的回归验证，同时支持了写接口验证，在内部产生了极大价值，有价值的东西就应该分享，目前该工具已经作为云服务对外开放。\n\n<a name=\"WeSlp\"></a>\n# 背景\n信息系统上线后通常会需要迭代升级甚至重构，如何保证被修改后系统原有业务的正确性非常重要。不复杂的业务系统通过一些常规的自动化测试工具加上人工测试可以解决，但对于业务十分复杂的系统，回归测试将变成一项浩大的工程。 <br />一个实际的例子：阿里巴巴作为一家以电商为核心的集团公司，交易系统和稳定性的重要性不言而喻。整个交易系统在多年的发展过程中，经历了很多业务的上下线，维护的人员也换了一波又一波，几乎没有人能梳理清楚其中的业务和代码。当它不得不面临一次全面升级的时候，其回归测试的困难度难以想象。因为常规的自动化测试工具需要准备测试数据、编写脚本，因此覆盖率不高，因此无法满足需求重构后的回归验证要求。 <br />doom平台的出现解决了这一难题，它通过复制线上真实流量去做自动化回归，通过它发现了很多重构带来的bug，同时加快交易重构项目的上线进程。同时通过录制流量作为用例来实现日常自动化回归取代传统编写脚本的自动化回归大大提升了回归效率和覆盖率。 <br />因为其解决方案的通用性，我们把这它拿出来给大家分享，同时也开放了云服务希望能支持到有需要的用户。\n<a name=\"nuQLc\"></a>\n# \n<a name=\"POFRD\"></a>\n# 平台介绍\n什么是doom平台<br />doom自动回归平台是一个将一部分线上真实流量复制并用于自动回归测试的平台。 通过创新的自动mock机制不仅支持读接口的回归验证，同时支持了写接口（例如用户下单接口、付款接口）的验证。它最底层借助了java的instrument实现aop因此，目前仅支持java应用的接入使用。其原理图如下：<br />![](https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224233-83ad8882-1647-4a1e-822c-1e93d8693100.png#align=left&display=inline&height=142&originHeight=142&originWidth=800&size=0&status=done&width=800)<br />它与tcpcopy或者diffy的区别：tcpcopy、diffy是在应用外的网络层实现流量录制和回放的，它们只能实现一些只读页面的验证。doom是在应用内部通过aop切面编程方式实现的流量录制和回放功能，因此可以做到应用内部接口级别的回归验证，当然也支持服务级别或者http级别的回归验证。通过独创的中间件级mock以及内部自定义的mock，可实现写流量的回归验证以及跨环境的回归验证（线上引流到测试环境）。\n\n<a name=\"gc675\"></a>\n# 应用场景\n系统重构时，复制真实线上环境流量到被测试环境进行回归，相当于在不影响业务的情况下提前上线检测系统潜在的问题。<br />可以将录制的流量作为用例管理起来进行日常自动化归回。<br />![](https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224876-7334753c-8056-4649-b1fc-1d5bc0bde81b.png#align=left&display=inline&height=424&originHeight=424&originWidth=800&size=0&status=done&width=800)\n<a name=\"IAwbQ\"></a>\n# 优势\n低成本：无需编写测试用例，通过流量录制形成丰富的测试用例。<br />高覆盖：一方面线上大量真实流量确保覆盖率，另一方面支持中间过程的验证，例如发送消息的内容、中间计算过程等等的全对象的对比验证，传统手工编写验证点很难实现。<br />支持写流量验证：（注：写流量是指可能导致有数据变更的流量）不用担心写流量回放污染应用数据，支持线上引流到测试环境以及写流量的自动化mock。<br />低应用侵入：通过隔离容器技术、字节码级别的AOP技术、中间件级MOCK避免接入类冲突以及降低接入成本。\n\n<a name=\"gyu1Z\"></a>\n# 如何使用\ndoom平台在阿里巴巴内部，特别是一些核心系统得到广泛使用，因此我们决定把这个产品开放出来，以云服务的形式免费提供给大家使用。doom支持 云效 上的应用直接申请使用，也支持任意能访问公网的应用直接申请使用。 <br />平台文档：[接入使用指南](https://help.aliyun.com/document_detail/62849.html?spm=5176.100239.blogcont278811.11.GSi6fa) <br />平台链接：[doom平台](https://account.aliyun.com/login/login.htm?oauth_callback=http://rdc-login.aliyun.com/aliyun?from=http%253A%252F%252Fdoom.rdc.aliyun.com%253A80&ctx=%252Fcommon%252Fapp_manage.htm%253Fspm%253D5176.100239.blogcont278811.12.Ljy152&ignore=true)\n\n<a name=\"OfDxD\"></a>\n# 原理\n如何实现回归验证？<br />对于web应用来说，请求最终都通过发起http请求方式来完成。我们假定生产环境应用会正常的响应用户的请求，通过aop的方式将请求入参及返回结果以及执行过程中的一些快照数据例如访问数据库的入参和返回结果、访问远程服务器的入参及结果保存下来。然后将快照数据发送给测试机器（代码发生变化的机器）完成一次回放过程。通将落库数据、调用后台请求的数据以及返回结果和线上真实请求发生时的数据进行全量对比，发现其中的差异，从而识别被测试系统的问题。针对后台应用来说也是如此，只是后台应用一般都是通过rpc请求实现，这时只要记录rpc入参、rpc返回值以及中间快照数据用于回放即可。<br />![](https://cdn.nlark.com/yuque/0/2019/png/92887/1559010225203-ea3b9232-82ce-4d5c-9d3c-5ddd2d14e2a6.png#align=left&display=inline&height=308&originHeight=308&originWidth=800&size=0&status=done&width=800)\n\n<a name=\"hDbvG\"></a>\n# 如何保证数据库不被污染？\nmock是单元测试常用手段，用来解决接口未完成或者调不通的情况。将这个特性进行延展，在线上执行真实请求时就把写数据库的请求以及对外服务的访问保存下来，在回放时当执行数据库或者调用后台的服务进行mock，这样回放时不会真正的访问数据库，也不会真正的发起对后台服务的调用，因此会影响业务数据，甚至可以在线下环境进行回放，因为mock数据来源于真实请求，也省去了造数据的麻烦。<br />![](https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224622-38d83dac-eb8e-491c-98c5-1339d50044ec.png#align=left&display=inline&height=798&originHeight=798&originWidth=800&size=0&status=done&width=800)<br />如何实现对外系统请求的mock？<br />应用会通过各种各样的中间件对外发起rpc请求，可以通过平台配置的中间件隔离来设置，平台客户端会对这些中间件进行aop处理实现自动的mock，不需要人工去配置具体的rpc接口。如果不支持的中间件请联系我们，我们会对其做适配开发。<br />如何解决回放时程序执行流程可能和线上真实流程不一致？<br />在生产环境程序执行时的一些内存数据状态和回放时测试服务器的内存数据状态往往会出现不一致，这些不一致会导致程序的执行流程不一样。例如本机缓存、内存开关、session查询等等。那么要如何解决呢？平台提供了自定义mock机制，将这些会导致不一致的代码片段进行mock。例如将缓存的get方法进行mock，那么如果线上读缓存时有数据，那么回放时直接可以用这些缓存数据进行mock即可，确保了回放的流程和线上真实执行时一致。<br />如何解决对比时的噪音？<br />回放时和录制时必然存在一些差异，例如服务器ip、时间、以及一些随机数等等。通过两种方式去解决：<br />排除法：平台支持指定字段排除对比，将不需要的字段排除即可。<br />指定对比法：将关心的业务数据进对比。\n\n<a name=\"NFFev\"></a>\n# 系统架构\n部署图<br />![](https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224607-3f6d0654-1c2f-4cf2-8c65-b464fab8555f.png#align=left&display=inline&height=543&originHeight=543&originWidth=800&size=0&status=done&width=800)<br />如图上所示，云服务提供配置管理功能，而在用户机房可以通过扩展实现自定义数据存储或者直接使用阿里云oss存储产品来实现用例或者流量的存储。配置之所以集中管理是为了方便平台升级，而支持数据自定义存储则提供给了用户更多的存储选择。 <br />图中A企业完全使用平台功能，如果平台功能不满足需求也可以像图中企业B一样，基于平台提供的录制、回放等等能力去实现自己的稳定性/回归测试平台。\n\n<a name=\"oCnrd\"></a>\n# 客户端服务端架构\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224713-cc238bbf-de39-478b-ae03-eab8d75d7f2b.png#align=left&display=inline&height=327&originHeight=327&originWidth=800&size=0&status=done&width=800)<br />上图为客户端服务端的架构图。客户端为接入应用嵌入的一个功能模块，可以负责流量录制、流量回放、中间件mock、中间件隔离、流量对比分析等等功能。服务端提供客户端相关的配置信息，例如要录制哪些流量，录制比例是多少、哪些ip服务器需要被录制等等。客户端的一些状态信息也会发送给服务端方便展示管理。另外只有当发生对比异常时，服务端才会发送异常数据给服务端用于查看分析。 <br />要实现不同企业的不同中间件mock，客户端需要扩展不同的中间件mock插件来实现。各个插件通过中间件插件管理器去管理，平台支持一些常用的中间件也支持扩展。除了mock外还需要提供了一个中间件隔离机制，例如通过在中间件最底层做一些隔离，避免在mock失败的情况下不会访问到数据库，保证回放时业务数据的安全性，当然如果是在非生产环境进行回放测试也可以避免这个风险。\n\n<a name=\"fG6Ww\"></a>\n# 平台开放\n录制数据存储到哪里？ <br />平台默认将录制数据保存到oss，也支持用户通过扩展实现使用自己的数据存储服务。<br />能基于doom平台实现自己的用例管理执行平台吗？<br />doom平台开放了流量的录制、回放以及对比的api，有需求的用户可以基于这些能力快速搭建一套属于自己自动化回归测试平台。\n",
    "body_draft": "",
    "body_html": "<p>摘要： 阿里内部诞生一了个依赖真实流量用于自动回归的自动化测试平台，通过创新的自动mock机制不仅支持读接口的回归验证，同时支持了写接口验证，在内部产生了极大价值，有价值的东西就应该分享，目前该工具已经作为云服务对外开放。</p><p><br /></p><h1 id=\"WeSlp\">背景</h1><p>信息系统上线后通常会需要迭代升级甚至重构，如何保证被修改后系统原有业务的正确性非常重要。不复杂的业务系统通过一些常规的自动化测试工具加上人工测试可以解决，但对于业务十分复杂的系统，回归测试将变成一项浩大的工程。 </p><p>一个实际的例子：阿里巴巴作为一家以电商为核心的集团公司，交易系统和稳定性的重要性不言而喻。整个交易系统在多年的发展过程中，经历了很多业务的上下线，维护的人员也换了一波又一波，几乎没有人能梳理清楚其中的业务和代码。当它不得不面临一次全面升级的时候，其回归测试的困难度难以想象。因为常规的自动化测试工具需要准备测试数据、编写脚本，因此覆盖率不高，因此无法满足需求重构后的回归验证要求。 </p><p>doom平台的出现解决了这一难题，它通过复制线上真实流量去做自动化回归，通过它发现了很多重构带来的bug，同时加快交易重构项目的上线进程。同时通过录制流量作为用例来实现日常自动化回归取代传统编写脚本的自动化回归大大提升了回归效率和覆盖率。 </p><p>因为其解决方案的通用性，我们把这它拿出来给大家分享，同时也开放了云服务希望能支持到有需要的用户。</p><h1 id=\"nuQLc\"><br /></h1><h1 id=\"POFRD\">平台介绍</h1><p>什么是doom平台</p><p>doom自动回归平台是一个将一部分线上真实流量复制并用于自动回归测试的平台。 通过创新的自动mock机制不仅支持读接口的回归验证，同时支持了写接口（例如用户下单接口、付款接口）的验证。它最底层借助了java的instrument实现aop因此，目前仅支持java应用的接入使用。其原理图如下：</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224233-83ad8882-1647-4a1e-822c-1e93d8693100.png#align=left&amp;display=inline&amp;height=142&amp;originHeight=142&amp;originWidth=800&amp;size=0&amp;status=done&amp;width=800\" style=\"max-width: 600px; width: 800px;\" /></p><p>它与tcpcopy或者diffy的区别：tcpcopy、diffy是在应用外的网络层实现流量录制和回放的，它们只能实现一些只读页面的验证。doom是在应用内部通过aop切面编程方式实现的流量录制和回放功能，因此可以做到应用内部接口级别的回归验证，当然也支持服务级别或者http级别的回归验证。通过独创的中间件级mock以及内部自定义的mock，可实现写流量的回归验证以及跨环境的回归验证（线上引流到测试环境）。</p><p><br /></p><h1 id=\"gc675\">应用场景</h1><p>系统重构时，复制真实线上环境流量到被测试环境进行回归，相当于在不影响业务的情况下提前上线检测系统潜在的问题。</p><p>可以将录制的流量作为用例管理起来进行日常自动化归回。</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224876-7334753c-8056-4649-b1fc-1d5bc0bde81b.png#align=left&amp;display=inline&amp;height=424&amp;originHeight=424&amp;originWidth=800&amp;size=0&amp;status=done&amp;width=800\" style=\"max-width: 600px; width: 800px;\" /></p><h1 id=\"IAwbQ\">优势</h1><p>低成本：无需编写测试用例，通过流量录制形成丰富的测试用例。</p><p>高覆盖：一方面线上大量真实流量确保覆盖率，另一方面支持中间过程的验证，例如发送消息的内容、中间计算过程等等的全对象的对比验证，传统手工编写验证点很难实现。</p><p>支持写流量验证：（注：写流量是指可能导致有数据变更的流量）不用担心写流量回放污染应用数据，支持线上引流到测试环境以及写流量的自动化mock。</p><p>低应用侵入：通过隔离容器技术、字节码级别的AOP技术、中间件级MOCK避免接入类冲突以及降低接入成本。</p><p><br /></p><h1 id=\"gyu1Z\">如何使用</h1><p>doom平台在阿里巴巴内部，特别是一些核心系统得到广泛使用，因此我们决定把这个产品开放出来，以云服务的形式免费提供给大家使用。doom支持 云效 上的应用直接申请使用，也支持任意能访问公网的应用直接申请使用。 </p><p>平台文档：<a href=\"https://help.aliyun.com/document_detail/62849.html?spm=5176.100239.blogcont278811.11.GSi6fa\" target=\"_blank\">接入使用指南</a> </p><p>平台链接：<a href=\"https://account.aliyun.com/login/login.htm?oauth_callback=http://rdc-login.aliyun.com/aliyun?from=http%253A%252F%252Fdoom.rdc.aliyun.com%253A80&amp;ctx=%252Fcommon%252Fapp_manage.htm%253Fspm%253D5176.100239.blogcont278811.12.Ljy152&amp;ignore=true\" target=\"_blank\">doom平台</a></p><p><br /></p><h1 id=\"OfDxD\">原理</h1><p>如何实现回归验证？</p><p>对于web应用来说，请求最终都通过发起http请求方式来完成。我们假定生产环境应用会正常的响应用户的请求，通过aop的方式将请求入参及返回结果以及执行过程中的一些快照数据例如访问数据库的入参和返回结果、访问远程服务器的入参及结果保存下来。然后将快照数据发送给测试机器（代码发生变化的机器）完成一次回放过程。通将落库数据、调用后台请求的数据以及返回结果和线上真实请求发生时的数据进行全量对比，发现其中的差异，从而识别被测试系统的问题。针对后台应用来说也是如此，只是后台应用一般都是通过rpc请求实现，这时只要记录rpc入参、rpc返回值以及中间快照数据用于回放即可。</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1559010225203-ea3b9232-82ce-4d5c-9d3c-5ddd2d14e2a6.png#align=left&amp;display=inline&amp;height=308&amp;originHeight=308&amp;originWidth=800&amp;size=0&amp;status=done&amp;width=800\" style=\"max-width: 600px; width: 800px;\" /></p><p><br /></p><h1 id=\"hDbvG\">如何保证数据库不被污染？</h1><p>mock是单元测试常用手段，用来解决接口未完成或者调不通的情况。将这个特性进行延展，在线上执行真实请求时就把写数据库的请求以及对外服务的访问保存下来，在回放时当执行数据库或者调用后台的服务进行mock，这样回放时不会真正的访问数据库，也不会真正的发起对后台服务的调用，因此会影响业务数据，甚至可以在线下环境进行回放，因为mock数据来源于真实请求，也省去了造数据的麻烦。</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224622-38d83dac-eb8e-491c-98c5-1339d50044ec.png#align=left&amp;display=inline&amp;height=798&amp;originHeight=798&amp;originWidth=800&amp;size=0&amp;status=done&amp;width=800\" style=\"max-width: 600px; width: 800px;\" /></p><p>如何实现对外系统请求的mock？</p><p>应用会通过各种各样的中间件对外发起rpc请求，可以通过平台配置的中间件隔离来设置，平台客户端会对这些中间件进行aop处理实现自动的mock，不需要人工去配置具体的rpc接口。如果不支持的中间件请联系我们，我们会对其做适配开发。</p><p>如何解决回放时程序执行流程可能和线上真实流程不一致？</p><p>在生产环境程序执行时的一些内存数据状态和回放时测试服务器的内存数据状态往往会出现不一致，这些不一致会导致程序的执行流程不一样。例如本机缓存、内存开关、session查询等等。那么要如何解决呢？平台提供了自定义mock机制，将这些会导致不一致的代码片段进行mock。例如将缓存的get方法进行mock，那么如果线上读缓存时有数据，那么回放时直接可以用这些缓存数据进行mock即可，确保了回放的流程和线上真实执行时一致。</p><p>如何解决对比时的噪音？</p><p>回放时和录制时必然存在一些差异，例如服务器ip、时间、以及一些随机数等等。通过两种方式去解决：</p><p>排除法：平台支持指定字段排除对比，将不需要的字段排除即可。</p><p>指定对比法：将关心的业务数据进对比。</p><p><br /></p><h1 id=\"NFFev\">系统架构</h1><p>部署图</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224607-3f6d0654-1c2f-4cf2-8c65-b464fab8555f.png#align=left&amp;display=inline&amp;height=543&amp;originHeight=543&amp;originWidth=800&amp;size=0&amp;status=done&amp;width=800\" style=\"max-width: 600px; width: 800px;\" /></p><p>如图上所示，云服务提供配置管理功能，而在用户机房可以通过扩展实现自定义数据存储或者直接使用阿里云oss存储产品来实现用例或者流量的存储。配置之所以集中管理是为了方便平台升级，而支持数据自定义存储则提供给了用户更多的存储选择。 </p><p>图中A企业完全使用平台功能，如果平台功能不满足需求也可以像图中企业B一样，基于平台提供的录制、回放等等能力去实现自己的稳定性/回归测试平台。</p><p><br /></p><h1 id=\"oCnrd\">客户端服务端架构</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1559010224713-cc238bbf-de39-478b-ae03-eab8d75d7f2b.png#align=left&amp;display=inline&amp;height=327&amp;originHeight=327&amp;originWidth=800&amp;size=0&amp;status=done&amp;width=800\" style=\"max-width: 600px; width: 800px;\" /></p><p>上图为客户端服务端的架构图。客户端为接入应用嵌入的一个功能模块，可以负责流量录制、流量回放、中间件mock、中间件隔离、流量对比分析等等功能。服务端提供客户端相关的配置信息，例如要录制哪些流量，录制比例是多少、哪些ip服务器需要被录制等等。客户端的一些状态信息也会发送给服务端方便展示管理。另外只有当发生对比异常时，服务端才会发送异常数据给服务端用于查看分析。 </p><p>要实现不同企业的不同中间件mock，客户端需要扩展不同的中间件mock插件来实现。各个插件通过中间件插件管理器去管理，平台支持一些常用的中间件也支持扩展。除了mock外还需要提供了一个中间件隔离机制，例如通过在中间件最底层做一些隔离，避免在mock失败的情况下不会访问到数据库，保证回放时业务数据的安全性，当然如果是在非生产环境进行回放测试也可以避免这个风险。</p><p><br /></p><h1 id=\"fG6Ww\">平台开放</h1><p>录制数据存储到哪里？ </p><p>平台默认将录制数据保存到oss，也支持用户通过扩展实现使用自己的数据存储服务。</p><p>能基于doom平台实现自己的用例管理执行平台吗？</p><p>doom平台开放了流量的录制、回放以及对比的api，有需求的用户可以基于这些能力快速搭建一套属于自己自动化回归测试平台。</p>",
    "body_lake": "<!doctype lake><p>摘要： 阿里内部诞生一了个依赖真实流量用于自动回归的自动化测试平台，通过创新的自动mock机制不仅支持读接口的回归验证，同时支持了写接口验证，在内部产生<cursor />了极大价值，有价值的东西就应该分享，目前该工具已经作为云服务对外开放。</p><p><br /></p><h1 id=\"WeSlp\">背景</h1><p>信息系统上线后通常会需要迭代升级甚至重构，如何保证被修改后系统原有业务的正确性非常重要。不复杂的业务系统通过一些常规的自动化测试工具加上人工测试可以解决，但对于业务十分复杂的系统，回归测试将变成一项浩大的工程。 </p><p>一个实际的例子：阿里巴巴作为一家以电商为核心的集团公司，交易系统和稳定性的重要性不言而喻。整个交易系统在多年的发展过程中，经历了很多业务的上下线，维护的人员也换了一波又一波，几乎没有人能梳理清楚其中的业务和代码。当它不得不面临一次全面升级的时候，其回归测试的困难度难以想象。因为常规的自动化测试工具需要准备测试数据、编写脚本，因此覆盖率不高，因此无法满足需求重构后的回归验证要求。 </p><p>doom平台的出现解决了这一难题，它通过复制线上真实流量去做自动化回归，通过它发现了很多重构带来的bug，同时加快交易重构项目的上线进程。同时通过录制流量作为用例来实现日常自动化回归取代传统编写脚本的自动化回归大大提升了回归效率和覆盖率。 </p><p>因为其解决方案的通用性，我们把这它拿出来给大家分享，同时也开放了云服务希望能支持到有需要的用户。</p><h1 id=\"nuQLc\"><br /></h1><h1 id=\"POFRD\">平台介绍</h1><p>什么是doom平台</p><p>doom自动回归平台是一个将一部分线上真实流量复制并用于自动回归测试的平台。 通过创新的自动mock机制不仅支持读接口的回归验证，同时支持了写接口（例如用户下单接口、付款接口）的验证。它最底层借助了java的instrument实现aop因此，目前仅支持java应用的接入使用。其原理图如下：</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1559010224233-83ad8882-1647-4a1e-822c-1e93d8693100.png%22%2C%22originWidth%22%3A800%2C%22originHeight%22%3A142%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A800%2C%22height%22%3A142%7D\"></card></p><p>它与tcpcopy或者diffy的区别：tcpcopy、diffy是在应用外的网络层实现流量录制和回放的，它们只能实现一些只读页面的验证。doom是在应用内部通过aop切面编程方式实现的流量录制和回放功能，因此可以做到应用内部接口级别的回归验证，当然也支持服务级别或者http级别的回归验证。通过独创的中间件级mock以及内部自定义的mock，可实现写流量的回归验证以及跨环境的回归验证（线上引流到测试环境）。</p><p><br /></p><h1 id=\"gc675\">应用场景</h1><p>系统重构时，复制真实线上环境流量到被测试环境进行回归，相当于在不影响业务的情况下提前上线检测系统潜在的问题。</p><p>可以将录制的流量作为用例管理起来进行日常自动化归回。</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1559010224876-7334753c-8056-4649-b1fc-1d5bc0bde81b.png%22%2C%22originWidth%22%3A800%2C%22originHeight%22%3A424%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A800%2C%22height%22%3A424%7D\"></card></p><h1 id=\"IAwbQ\">优势</h1><p>低成本：无需编写测试用例，通过流量录制形成丰富的测试用例。</p><p>高覆盖：一方面线上大量真实流量确保覆盖率，另一方面支持中间过程的验证，例如发送消息的内容、中间计算过程等等的全对象的对比验证，传统手工编写验证点很难实现。</p><p>支持写流量验证：（注：写流量是指可能导致有数据变更的流量）不用担心写流量回放污染应用数据，支持线上引流到测试环境以及写流量的自动化mock。</p><p>低应用侵入：通过隔离容器技术、字节码级别的AOP技术、中间件级MOCK避免接入类冲突以及降低接入成本。</p><p><br /></p><h1 id=\"gyu1Z\">如何使用</h1><p>doom平台在阿里巴巴内部，特别是一些核心系统得到广泛使用，因此我们决定把这个产品开放出来，以云服务的形式免费提供给大家使用。doom支持 云效 上的应用直接申请使用，也支持任意能访问公网的应用直接申请使用。 </p><p>平台文档：<a href=\"https://help.aliyun.com/document_detail/62849.html?spm=5176.100239.blogcont278811.11.GSi6fa\" target=\"_blank\">接入使用指南</a> </p><p>平台链接：<a href=\"https://account.aliyun.com/login/login.htm?oauth_callback=http://rdc-login.aliyun.com/aliyun?from=http%253A%252F%252Fdoom.rdc.aliyun.com%253A80&amp;ctx=%252Fcommon%252Fapp_manage.htm%253Fspm%253D5176.100239.blogcont278811.12.Ljy152&amp;ignore=true\" target=\"_blank\">doom平台</a></p><p><br /></p><h1 id=\"OfDxD\">原理</h1><p>如何实现回归验证？</p><p>对于web应用来说，请求最终都通过发起http请求方式来完成。我们假定生产环境应用会正常的响应用户的请求，通过aop的方式将请求入参及返回结果以及执行过程中的一些快照数据例如访问数据库的入参和返回结果、访问远程服务器的入参及结果保存下来。然后将快照数据发送给测试机器（代码发生变化的机器）完成一次回放过程。通将落库数据、调用后台请求的数据以及返回结果和线上真实请求发生时的数据进行全量对比，发现其中的差异，从而识别被测试系统的问题。针对后台应用来说也是如此，只是后台应用一般都是通过rpc请求实现，这时只要记录rpc入参、rpc返回值以及中间快照数据用于回放即可。</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1559010225203-ea3b9232-82ce-4d5c-9d3c-5ddd2d14e2a6.png%22%2C%22originWidth%22%3A800%2C%22originHeight%22%3A308%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A800%2C%22height%22%3A308%7D\"></card></p><p><br /></p><h1 id=\"hDbvG\">如何保证数据库不被污染？</h1><p>mock是单元测试常用手段，用来解决接口未完成或者调不通的情况。将这个特性进行延展，在线上执行真实请求时就把写数据库的请求以及对外服务的访问保存下来，在回放时当执行数据库或者调用后台的服务进行mock，这样回放时不会真正的访问数据库，也不会真正的发起对后台服务的调用，因此会影响业务数据，甚至可以在线下环境进行回放，因为mock数据来源于真实请求，也省去了造数据的麻烦。</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1559010224622-38d83dac-eb8e-491c-98c5-1339d50044ec.png%22%2C%22originWidth%22%3A800%2C%22originHeight%22%3A798%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A800%2C%22height%22%3A798%7D\"></card></p><p>如何实现对外系统请求的mock？</p><p>应用会通过各种各样的中间件对外发起rpc请求，可以通过平台配置的中间件隔离来设置，平台客户端会对这些中间件进行aop处理实现自动的mock，不需要人工去配置具体的rpc接口。如果不支持的中间件请联系我们，我们会对其做适配开发。</p><p>如何解决回放时程序执行流程可能和线上真实流程不一致？</p><p>在生产环境程序执行时的一些内存数据状态和回放时测试服务器的内存数据状态往往会出现不一致，这些不一致会导致程序的执行流程不一样。例如本机缓存、内存开关、session查询等等。那么要如何解决呢？平台提供了自定义mock机制，将这些会导致不一致的代码片段进行mock。例如将缓存的get方法进行mock，那么如果线上读缓存时有数据，那么回放时直接可以用这些缓存数据进行mock即可，确保了回放的流程和线上真实执行时一致。</p><p>如何解决对比时的噪音？</p><p>回放时和录制时必然存在一些差异，例如服务器ip、时间、以及一些随机数等等。通过两种方式去解决：</p><p>排除法：平台支持指定字段排除对比，将不需要的字段排除即可。</p><p>指定对比法：将关心的业务数据进对比。</p><p><br /></p><h1 id=\"NFFev\">系统架构</h1><p>部署图</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1559010224607-3f6d0654-1c2f-4cf2-8c65-b464fab8555f.png%22%2C%22originWidth%22%3A800%2C%22originHeight%22%3A543%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A800%2C%22height%22%3A543%7D\"></card></p><p>如图上所示，云服务提供配置管理功能，而在用户机房可以通过扩展实现自定义数据存储或者直接使用阿里云oss存储产品来实现用例或者流量的存储。配置之所以集中管理是为了方便平台升级，而支持数据自定义存储则提供给了用户更多的存储选择。 </p><p>图中A企业完全使用平台功能，如果平台功能不满足需求也可以像图中企业B一样，基于平台提供的录制、回放等等能力去实现自己的稳定性/回归测试平台。</p><p><br /></p><h1 id=\"oCnrd\">客户端服务端架构</h1><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1559010224713-cc238bbf-de39-478b-ae03-eab8d75d7f2b.png%22%2C%22originWidth%22%3A800%2C%22originHeight%22%3A327%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A800%2C%22height%22%3A327%7D\"></card></p><p>上图为客户端服务端的架构图。客户端为接入应用嵌入的一个功能模块，可以负责流量录制、流量回放、中间件mock、中间件隔离、流量对比分析等等功能。服务端提供客户端相关的配置信息，例如要录制哪些流量，录制比例是多少、哪些ip服务器需要被录制等等。客户端的一些状态信息也会发送给服务端方便展示管理。另外只有当发生对比异常时，服务端才会发送异常数据给服务端用于查看分析。 </p><p>要实现不同企业的不同中间件mock，客户端需要扩展不同的中间件mock插件来实现。各个插件通过中间件插件管理器去管理，平台支持一些常用的中间件也支持扩展。除了mock外还需要提供了一个中间件隔离机制，例如通过在中间件最底层做一些隔离，避免在mock失败的情况下不会访问到数据库，保证回放时业务数据的安全性，当然如果是在非生产环境进行回放测试也可以避免这个风险。</p><p><br /></p><h1 id=\"fG6Ww\">平台开放</h1><p>录制数据存储到哪里？ </p><p>平台默认将录制数据保存到oss，也支持用户通过扩展实现使用自己的数据存储服务。</p><p>能基于doom平台实现自己的用例管理执行平台吗？</p><p>doom平台开放了流量的录制、回放以及对比的api，有需求的用户可以基于这些能力快速搭建一套属于自己自动化回归测试平台。</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-05-28T02:26:00.000Z",
    "deleted_at": null,
    "created_at": "2019-05-28T02:23:18.000Z",
    "updated_at": "2019-05-28T02:26:00.000Z",
    "published_at": "2019-05-28T02:26:00.000Z",
    "first_published_at": "2019-05-28T02:24:16.000Z",
    "word_count": 2678,
    "cover": null,
    "description": "摘要： 阿里内部诞生一了个依赖真实流量用于自动回归的自动化测试平台，通过创新的自动mock机制不仅支持读接口的回归验证，同时支持了写接口验证，在内部产生了极大价值，有价值的东西就应该分享，目前该工具已经作为云服务对外开放。背景信息系统上线后通常会需要迭代升级甚至重构，如何保证被修改后系统原有业...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1670110,
    "slug": "kmyw3z",
    "title": "glide install 问题",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-17T12:09:01.746Z",
      "updated_at": "2019-07-17T12:09:01.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"m3IOj\"></a>\n# 背景 \ngo项目，使用glide install命令去下载安装依赖，依赖中有个github.com/hashicorp/consul\n\n<a name=\"dw95Z\"></a>\n# 问题描述\n一直无法下载安装依赖成功，报错如下：\n\n```\n[ERROR] Export failed for github.com/hashicorp/consul: Unable to export source: exit status 128\n[ERROR] Unable to export dependencies to vendor directory: Unable to export source: exit status 128\n```\n\n<a name=\"T1bDZ\"></a>\n# 解决思路\n> 先日了狗表达心情！\n\n一顿google，发现提供的思路都差不多为：\n\n```\nglide cc\n\nrm -rf vendor\n```\n尝试了无数次后都是失败了<br />在google的过程中，有的人建议贴出debug日志，无奈最后就自己加上了debug：glide --debug install，得到了如下日志\n\n<a name=\"BvYcu\"></a>\n# 具体日志\n\n```\n[ERROR] Export failed for github.com/hashicorp/consul: Unable to export source: exit status 128\n\n[DEBUG] Output was: error: unable to create file C:\\\\\\Users\\\\\\M\\\\\\AppData\\\\\\Local\\\\\\Temp\\\\\\glide-vendor249536483\\\\\\vendor\\\\\\github.com\\\\\\hashicorp\\\\\\consul\\\\\\vendor/github.com/hashicorp/go-discover/provider/azure/vendor/github.com/Azure/azure-sdk-for-go/services/network/mgmt/2015-06-15/network/expressroutecircuitauthorizations.go: Filename too long[DEBUG]\n\nUnlocking https-github.com-hashicorp-consul\n\n[ERROR] Unable to export dependencies to vendor directory: Unable to export source: exit status 128\n\n[DEBUG] Output was: error: unable to create file C:\\\\\\Users\\\\\\M\\\\\\AppData\\\\\\Local\\\\\\Temp\\\\\\glide-vendor249536483\\\\\\vendor\\\\\\github.com\\\\\\hashicorp\\\\\\consul\\\\\\vendor/github.com/hashicorp/go-discover/provider/azure/vendor/github.com/Azure/azure-sdk-for-go/services/network/mgmt/2015-06-15/network/expressroutecircuitauthorizations.go: Filename too long\n```\n日了狗，看描述大概明白了，glide在执行新建文件的时候发现文件名过长了！！！\n\n<a name=\"KN3wD\"></a>\n# 解决办法\n那么问题就演变成了glide error filename too long的问题了<br />具体方法：\n\n```\nEnable long paths on Windows (requires Windows 10 Anniversary Update or newer): https://superuser.com/a/1119980/97078\n\nConfigure git to use long paths: git config --global core.longpaths true (globally) or git config core.longpaths true (per project)\n```\n我执行了第二步就解决了问题，那么大概就是glide 会去使用git去拉取代码和创建文件了的 \n\n<a name=\"8KWU0\"></a>\n# 小结\n还是问题的官方日志靠谱，遇到问题先获取更多的日志吧\n",
    "body_draft": "",
    "body_html": "<h1 id=\"m3IOj\">背景 </h1><p>go项目，使用glide install命令去下载安装依赖，依赖中有个github.com/hashicorp/consul</p><p><br /></p><h1 id=\"dw95Z\">问题描述</h1><p>一直无法下载安装依赖成功，报错如下：</p><p><br /></p><pre><code>[ERROR] Export failed for github.com/hashicorp/consul: Unable to export source: exit status 128\n[ERROR] Unable to export dependencies to vendor directory: Unable to export source: exit status 128</code></pre><p><br /></p><h1 id=\"T1bDZ\">解决思路</h1><blockquote><p>先日了狗表达心情！</p></blockquote><p>一顿google，发现提供的思路都差不多为：</p><p><br /></p><pre><code>glide cc\n\nrm -rf vendor</code></pre><p>尝试了无数次后都是失败了</p><p>在google的过程中，有的人建议贴出debug日志，无奈最后就自己加上了debug：glide --debug install，得到了如下日志</p><p><br /></p><h1 id=\"BvYcu\">具体日志</h1><p><br /></p><pre><code>[ERROR] Export failed for github.com/hashicorp/consul: Unable to export source: exit status 128\n\n[DEBUG] Output was: error: unable to create file C:\\\\\\Users\\\\\\M\\\\\\AppData\\\\\\Local\\\\\\Temp\\\\\\glide-vendor249536483\\\\\\vendor\\\\\\github.com\\\\\\hashicorp\\\\\\consul\\\\\\vendor/github.com/hashicorp/go-discover/provider/azure/vendor/github.com/Azure/azure-sdk-for-go/services/network/mgmt/2015-06-15/network/expressroutecircuitauthorizations.go: Filename too long[DEBUG]\n\nUnlocking https-github.com-hashicorp-consul\n\n[ERROR] Unable to export dependencies to vendor directory: Unable to export source: exit status 128\n\n[DEBUG] Output was: error: unable to create file C:\\\\\\Users\\\\\\M\\\\\\AppData\\\\\\Local\\\\\\Temp\\\\\\glide-vendor249536483\\\\\\vendor\\\\\\github.com\\\\\\hashicorp\\\\\\consul\\\\\\vendor/github.com/hashicorp/go-discover/provider/azure/vendor/github.com/Azure/azure-sdk-for-go/services/network/mgmt/2015-06-15/network/expressroutecircuitauthorizations.go: Filename too long</code></pre><p>日了狗，看描述大概明白了，glide在执行新建文件的时候发现文件名过长了！！！</p><p><br /></p><h1 id=\"KN3wD\">解决办法</h1><p>那么问题就演变成了glide error filename too long的问题了</p><p>具体方法：</p><p><br /></p><pre><code>Enable long paths on Windows (requires Windows 10 Anniversary Update or newer): https://superuser.com/a/1119980/97078\n\nConfigure git to use long paths: git config --global core.longpaths true (globally) or git config core.longpaths true (per project)</code></pre><p>我执行了第二步就解决了问题，那么大概就是glide 会去使用git去拉取代码和创建文件了的 </p><p><br /></p><h1 id=\"8KWU0\">小结</h1><p>还是问题的官方日志靠谱，遇到问题先获取更多的日志吧</p>",
    "body_lake": "<!doctype lake><h1 id=\"m3IOj\">背景 </h1><p>go项目，使用glide install命令去下载安装依赖，依赖中有个github.com/hashicorp/consul</p><p><br /></p><h1 id=\"dw95Z\">问题描述</h1><p>一直无法下载安装依赖成功，报错如下：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%5BERROR%5D%20Export%20failed%20for%20github.com%2Fhashicorp%2Fconsul%3A%20Unable%20to%20export%20source%3A%20exit%20status%20128%5Cn%5BERROR%5D%20Unable%20to%20export%20dependencies%20to%20vendor%20directory%3A%20Unable%20to%20export%20source%3A%20exit%20status%20128%22%2C%22id%22%3A%22oQZMK%22%7D\"></card><p><br /></p><h1 id=\"T1bDZ\">解决思路</h1><blockquote><p>先日了狗表达心情！</p></blockquote><p>一顿google，发现提供的思路都差不多为：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22glide%20cc%5Cn%5Cnrm%20-rf%20vendor%22%2C%22id%22%3A%22eiCwM%22%7D\"></card><p>尝试了无数次后都是失败了</p><p>在google的过程中，有的人建议贴出debug日志，无奈最后就自己加上了debug：glide --debug install，得到了如下日志<cursor /></p><p><br /></p><h1 id=\"BvYcu\">具体日志</h1><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%5BERROR%5D%20Export%20failed%20for%20github.com%2Fhashicorp%2Fconsul%3A%20Unable%20to%20export%20source%3A%20exit%20status%20128%5Cn%5Cn%5BDEBUG%5D%20Output%20was%3A%20error%3A%20unable%20to%20create%20file%20C%3A%5C%5C%5C%5C%5C%5CUsers%5C%5C%5C%5C%5C%5CM%5C%5C%5C%5C%5C%5CAppData%5C%5C%5C%5C%5C%5CLocal%5C%5C%5C%5C%5C%5CTemp%5C%5C%5C%5C%5C%5Cglide-vendor249536483%5C%5C%5C%5C%5C%5Cvendor%5C%5C%5C%5C%5C%5Cgithub.com%5C%5C%5C%5C%5C%5Chashicorp%5C%5C%5C%5C%5C%5Cconsul%5C%5C%5C%5C%5C%5Cvendor%2Fgithub.com%2Fhashicorp%2Fgo-discover%2Fprovider%2Fazure%2Fvendor%2Fgithub.com%2FAzure%2Fazure-sdk-for-go%2Fservices%2Fnetwork%2Fmgmt%2F2015-06-15%2Fnetwork%2Fexpressroutecircuitauthorizations.go%3A%20Filename%20too%20long%5BDEBUG%5D%5Cn%5CnUnlocking%20https-github.com-hashicorp-consul%5Cn%5Cn%5BERROR%5D%20Unable%20to%20export%20dependencies%20to%20vendor%20directory%3A%20Unable%20to%20export%20source%3A%20exit%20status%20128%5Cn%5Cn%5BDEBUG%5D%20Output%20was%3A%20error%3A%20unable%20to%20create%20file%20C%3A%5C%5C%5C%5C%5C%5CUsers%5C%5C%5C%5C%5C%5CM%5C%5C%5C%5C%5C%5CAppData%5C%5C%5C%5C%5C%5CLocal%5C%5C%5C%5C%5C%5CTemp%5C%5C%5C%5C%5C%5Cglide-vendor249536483%5C%5C%5C%5C%5C%5Cvendor%5C%5C%5C%5C%5C%5Cgithub.com%5C%5C%5C%5C%5C%5Chashicorp%5C%5C%5C%5C%5C%5Cconsul%5C%5C%5C%5C%5C%5Cvendor%2Fgithub.com%2Fhashicorp%2Fgo-discover%2Fprovider%2Fazure%2Fvendor%2Fgithub.com%2FAzure%2Fazure-sdk-for-go%2Fservices%2Fnetwork%2Fmgmt%2F2015-06-15%2Fnetwork%2Fexpressroutecircuitauthorizations.go%3A%20Filename%20too%20long%22%2C%22id%22%3A%22FFBya%22%7D\"></card><p>日了狗，看描述大概明白了，glide在执行新建文件的时候发现文件名过长了！！！</p><p><br /></p><h1 id=\"KN3wD\">解决办法</h1><p>那么问题就演变成了glide error filename too long的问题了</p><p>具体方法：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22Enable%20long%20paths%20on%20Windows%20(requires%20Windows%2010%20Anniversary%20Update%20or%20newer)%3A%20https%3A%2F%2Fsuperuser.com%2Fa%2F1119980%2F97078%5Cn%5CnConfigure%20git%20to%20use%20long%20paths%3A%20git%20config%20--global%20core.longpaths%20true%20(globally)%20or%20git%20config%20core.longpaths%20true%20(per%20project)%22%2C%22id%22%3A%22uBxWa%22%7D\"></card><p>我执行了第二步就解决了问题，那么大概就是glide 会去使用git去拉取代码和创建文件了的 </p><p><br /></p><h1 id=\"8KWU0\">小结</h1><p>还是问题的官方日志靠谱，遇到问题先获取更多的日志吧</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-05-10T12:12:11.000Z",
    "deleted_at": null,
    "created_at": "2019-05-10T11:47:15.000Z",
    "updated_at": "2019-07-17T12:09:01.000Z",
    "published_at": "2019-07-17T12:09:01.000Z",
    "first_published_at": "2019-05-10T12:09:04.000Z",
    "word_count": 455,
    "cover": null,
    "description": "背景 go项目，使用glide install命令去下载安装依赖，依赖中有个github.com/hashicorp/consul问题描述一直无法下载安装依赖成功，报错如下：[ERROR] Export failed for github.com/hashicorp/consul: Unabl...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1592007,
    "slug": "bpi1ec",
    "title": "ERR_BLOCKED_BY_CLIENT错误",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-17T12:10:03.944Z",
      "updated_at": "2019-07-17T12:10:03.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"Ejzna\"></a>\n# 背景\n今天在测试需求的发现一个js报错，研发小哥说自己的电脑没有出现这个问题<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/92887/1556178719782-ecc78aa2-56c3-4942-a235-e1231b58d4db.png#align=left&display=inline&height=207&name=image.png&originHeight=398&originWidth=1437&size=45810&status=done&width=746)\n\n<a name=\"wPlPq\"></a>\n# 排查过程\n\n1. 研发自己电脑重现，重现失败，那边正常\n1. 确认是我这里的js加载失败，先确认代码是否更新，代码为最新代码；\n1. 查看具体错误，提示ERR_BLOCKED_BY_CLIENT，研发也表示没见过，那就直接百度了\n1. 发现了原来是adblock的原因，我chrome是有装这个插件的，如果暂停adblock，js加载成功\n\n<a name=\"S9HuP\"></a>\n# 后文\n本来是想找下adblock默认的过滤规则，但是没有找到，但这个js文件中带有adsource的字样，推测大概是被误伤了的\n\n<a name=\"e3nSJ\"></a>\n# 参考\n[https://www.jianshu.com/p/c3cd3f820e5b](https://www.jianshu.com/p/c3cd3f820e5b)\n",
    "body_draft": "",
    "body_html": "<h1 id=\"Ejzna\">背景</h1><p>今天在测试需求的发现一个js报错，研发小哥说自己的电脑没有出现这个问题</p><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1556178719782-ecc78aa2-56c3-4942-a235-e1231b58d4db.png#align=left&amp;display=inline&amp;height=207&amp;name=image.png&amp;originHeight=398&amp;originWidth=1437&amp;size=45810&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><h1 id=\"wPlPq\">排查过程</h1><ol start=\"1\"><li>研发自己电脑重现，重现失败，那边正常</li><li>确认是我这里的js加载失败，先确认代码是否更新，代码为最新代码；</li><li>查看具体错误，提示ERR_BLOCKED_BY_CLIENT，研发也表示没见过，那就直接百度了</li><li>发现了原来是adblock的原因，我chrome是有装这个插件的，如果暂停adblock，js加载成功</li></ol><p><br /></p><h1 id=\"S9HuP\">后文</h1><p>本来是想找下adblock默认的过滤规则，但是没有找到，但这个js文件中带有adsource的字样，推测大概是被误伤了的</p><p><br /></p><h1 id=\"e3nSJ\">参考</h1><p><a href=\"https://www.jianshu.com/p/c3cd3f820e5b\" target=\"_blank\">https://www.jianshu.com/p/c3cd3f820e5b</a></p>",
    "body_lake": "<!doctype lake><h1 id=\"Ejzna\">背景</h1><p>今天在测试需求的发现一个js报错，研发小哥说自己的电脑没有出现这个问题</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1556178719782-ecc78aa2-56c3-4942-a235-e1231b58d4db.png%22%2C%22originWidth%22%3A1437%2C%22originHeight%22%3A398%2C%22name%22%3A%22image.png%22%2C%22size%22%3A45810%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A207%7D\"></card></p><p><br /></p><h1 id=\"wPlPq\">排查过程</h1><ol start=\"1\"><li>研发自己电脑重现，重现失败，那边正常</li><li>确认是我这里的js加载失败，先确认代码是否更新，代码为最新代码；</li><li>查看具体错误，提示ERR_BLOCKED_BY_CLIENT，研发也表示没见过，那就直接百度了</li><li>发现了原来是adblock的原因，我chrome是有装这个插件的，如果暂停adblock，js加载成功</li></ol><p><br /></p><h1 id=\"S9HuP\">后文</h1><p>本来是想找下adblock默认的过滤规则，但是没有找到，但这个js文件中带有adsource的字样，推测大概是被误伤了的</p><p><br /></p><h1 id=\"e3nSJ\">参考</h1><p><a href=\"https://www.jianshu.com/p/c3cd3f820e5b\" target=\"_blank\">https://www.jianshu.com/p/c3cd3f820e5b</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-25T07:55:28.000Z",
    "deleted_at": null,
    "created_at": "2019-04-25T07:50:24.000Z",
    "updated_at": "2019-07-17T12:10:04.000Z",
    "published_at": "2019-07-17T12:10:03.000Z",
    "first_published_at": "2019-04-25T07:55:28.000Z",
    "word_count": 193,
    "cover": null,
    "description": "背景今天在测试需求的发现一个js报错，研发小哥说自己的电脑没有出现这个问题排查过程研发自己电脑重现，重现失败，那边正常确认是我这里的js加载失败，先确认代码是否更新，代码为最新代码；查看具体错误，提示ERR_BLOCKED_BY_CLIENT，研发也表示没见过，那就直接百度了发现了原来是adb...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1587155,
    "slug": "ku1870",
    "title": "CGI FastCGI PHP-FPM",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"CGI\"></a>\n# CGI\n> Common Gateway Interface, CGI 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持CGI,可用任何语言编写CGI\n\n**历史在前进，静态资源 变成 动态资源的历史进程；**<br />如访问jpg这种静态资源，web server在相应的目录找到了文件返回，<br />当web server收到/index.php这个请求后，会启动对应的CGI程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。\n\n缺点：<br />每次请求过来都会启动cgi程序，然后处理，然后退出，性能不好\n\n<a name=\"FastCGI\"></a>\n# FastCGI\n> FastCGI全称 快速通用网关接口（FastCommonGatewayInterface）。\n> FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。\n> FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。\n\n**一种技术的诞生，往往是解决一些问题。**<br />**\n<a name=\"PHP-FPM\"></a>\n# PHP-FPM\n> PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)是一个PHPFastCGI管理器，对于PHP 5.3.3之前的php来说，是一个补丁包[ ]() ，旨在将FastCGI进程管理整合进PHP包中。如果你使用的是PHP5.3.3之前的PHP的话，就必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。\n\n大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度php-cgi进程的程序<br />php-fpm实现了fastcgi这个协议\n\n\n<a name=\"35808e79\"></a>\n# 参考资料\n[https://blog.csdn.net/u010785091/article/details/78705690](https://blog.csdn.net/u010785091/article/details/78705690)<br />[https://blog.csdn.net/App_IOS/article/details/80640987](https://blog.csdn.net/App_IOS/article/details/80640987)<br />[https://segmentfault.com/a/1190000007322358?utm_source=tag-newest](https://segmentfault.com/a/1190000007322358?utm_source=tag-newest)\n",
    "body_draft": "",
    "body_html": "<h1 id=\"CGI\">CGI</h1><blockquote><p>Common Gateway Interface, <span style=\"color: #333333;\">CGI 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持CGI,可用任何语言编写CGI</span></p></blockquote><p><strong>历史在前进，静态资源 变成 动态资源的历史进程；</strong></p><p>如访问jpg这种静态资源，web server在相应的目录找到了文件返回，</p><p>当web server收到/index.php这个请求后，会启动对应的CGI程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。</p><p><br /></p><p>缺点：</p><p>每次请求过来都会启动cgi程序，然后处理，然后退出，性能不好</p><p><br /></p><h1 id=\"FastCGI\">FastCGI</h1><blockquote><p>FastCGI全称 快速通用网关接口（FastCommonGatewayInterface）。</p><p>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</p><p>FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。</p></blockquote><p><strong>一种技术的诞生，往往是解决一些问题。</strong></p><p><strong><br /></strong></p><h1 id=\"PHP-FPM\">PHP-FPM</h1><blockquote><p><span style=\"color: #333333;\">PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)是一个</span>PHPFastCGI<span style=\"color: #333333;\">管理器，对于PHP 5.3.3之前的php来说，是一个补丁包</span><sup> [1]</sup><a name=\"ref_[1]_4168033\" target=\"_blank\"> </a><span style=\"color: #333333;\"> ，旨在将FastCGI进程管理整合进PHP包中。如果你使用的是PHP5.3.3之前的PHP的话，就必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。</span></p></blockquote><p>大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度php-cgi进程的程序</p><p><span class=\"lake-fontsize-11\" style=\"color: #4F4F4F;\">php-fpm实现了fastcgi这个协议</span></p><p><br /></p><p><br /></p><h1 id=\"35808e79\">参考资料</h1><p><a href=\"https://blog.csdn.net/u010785091/article/details/78705690\" target=\"_blank\">https://blog.csdn.net/u010785091/article/details/78705690</a></p><p><a href=\"https://blog.csdn.net/App_IOS/article/details/80640987\" target=\"_blank\">https://blog.csdn.net/App_IOS/article/details/80640987</a></p><p><a href=\"https://segmentfault.com/a/1190000007322358?utm_source=tag-newest\" target=\"_blank\">https://segmentfault.com/a/1190000007322358?utm_source=tag-newest</a></p>",
    "body_lake": "<!doctype lake><h1 id=\"CGI\">CGI</h1><blockquote><p>Common Gateway Interface, <span style=\"color: #333333;\">CGI 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持CGI,可用任何语言编写CGI</span></p></blockquote><p><strong>历史在前进，静态资源 变成 动态资源的历史进程；</strong></p><p>如访问jpg这种静态资源，web server在相应的目录找到了文件返回，</p><p>当web server收到/index.php这个请求后，会启动对应的CGI程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。</p><p><br /></p><p>缺点：</p><p>每次请求过来都会启动cgi程序，然后处理，然后退出，性能不好</p><p><br /></p><h1 id=\"FastCGI\">FastCGI</h1><blockquote><p>FastCGI全称 快速通用网关接口（FastCommonGatewayInterface）。</p><p>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</p><p>FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。</p></blockquote><p><strong>一种技术的诞生，往往是解决一些问题。</strong></p><p><strong><br /></strong></p><h1 id=\"PHP-FPM\">PHP-FPM</h1><blockquote><p><span style=\"color: #333333;\">PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)是一个</span>PHPFastCGI<span style=\"color: #333333;\">管理器，对于PHP 5.3.3之前的php来说，是一个补丁包</span><sup> [1]</sup><a name=\"ref_[1]_4168033\" target=\"_blank\"> </a><span style=\"color: #333333;\"> ，旨在将FastCGI进程管理整合进PHP包中。如果你使用的是PHP5.3.3之前的PHP的话，就必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。</span></p></blockquote><p>大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度php-cgi进程的程序</p><p><span class=\"lake-fontsize-11\" style=\"color: #4F4F4F;\">php-fpm实现了fastcgi这个协议</span></p><p><br /></p><p><br /></p><h1 id=\"35808e79\">参考资料</h1><p><a href=\"https://blog.csdn.net/u010785091/article/details/78705690\" target=\"_blank\">https://blog.csdn.net/u010785091/article/details/78705690</a></p><p><a href=\"https://blog.csdn.net/App_IOS/article/details/80640987\" target=\"_blank\">https://blog.csdn.net/App_IOS/article/details/80640987</a></p><p><a href=\"https://segmentfault.com/a/1190000007322358?utm_source=tag-newest\" target=\"_blank\">https://segmentfault.com/a/1190000007322358?utm_source=tag-newest</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-24T09:13:06.000Z",
    "deleted_at": null,
    "created_at": "2019-04-24T08:56:49.000Z",
    "updated_at": "2019-04-24T09:13:06.000Z",
    "published_at": "2019-04-24T09:13:06.000Z",
    "first_published_at": "2019-04-24T09:13:06.000Z",
    "word_count": 674,
    "cover": null,
    "description": "CGICommon Gateway Interface, CGI 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553205,
    "slug": "efa3zc",
    "title": "自媒体平台简结",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"df368884\"></a>\n# 前言\n网络上跑的有三种流：\n\n- 人流\n- 信息流\n- 资金流\n\n人流 （通讯/社交）-- 腾讯<br />信息流 -- 百度<br />资金流 -- 阿里\n\n<a name=\"What\"></a>\n# [](https://www.yuque.com/qianwang/notes/gpesx4/edit#w0wwrn)What\n信息流，广义来讲就是内容，狭义来讲内容以瀑布流的形式展示<br />现在大多数app都以信息流的方式展示内容，如新闻类的头条\n\n\n<a name=\"593c78c7\"></a>\n# [](https://www.yuque.com/qianwang/notes/gpesx4/edit#7ioeri)自媒体平台\n围绕着内容，又称B端内容创作平台\n\nB端用户产生内容，C端用户消费内容\n\n- 生成内容<br />\n  - 内容数量<br />\n  - 内容质量<br />\n- 消费内容<br />\n  - 数据展示<br />\n  - 商业化<br />\n\n人的管理\n\n- 积极性<br />\n  - 权益体系<br />\n  - 创作指导<br />\n  - 激励体系<br />\n- 拉新/留存<br />\n  - 新人任务<br />\n- 使用体感<br />\n  - 编辑器<br />\n\n用户角度\n\n- 钱<br />\n- 荣誉<br />\n\n\n<a name=\"6e818306\"></a>\n# [](https://www.yuque.com/qianwang/notes/gpesx4/edit#l4tuxv)信息流\n自媒体<br />机构号<br />爬虫\n\n原始内容 -- 审核 -- 可推荐内容 -- 筛选/推荐 -- 下发 -- 展示 -- 消费 -- 回流 --画像沉淀\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"df368884\">前言</h1><p>网络上跑的有三种流：</p><ul><li>人流</li><li>信息流</li><li>资金流</li></ul><p><br /></p><p>人流 （通讯/社交）-- 腾讯</p><p>信息流 -- 百度</p><p>资金流 -- 阿里</p><p><br /></p><h1 id=\"What\"><a href=\"https://www.yuque.com/qianwang/notes/gpesx4/edit#w0wwrn\" target=\"_blank\"></a>What</h1><p>信息流，广义来讲就是内容，狭义来讲内容以瀑布流的形式展示</p><p>现在大多数app都以信息流的方式展示内容，如新闻类的头条</p><p><br /></p><p><br /></p><h1 id=\"593c78c7\"><a href=\"https://www.yuque.com/qianwang/notes/gpesx4/edit#7ioeri\" target=\"_blank\"></a>自媒体平台</h1><p>围绕着内容，又称B端内容创作平台</p><p><br /></p><p>B端用户产生内容，C端用户消费内容</p><ul><li>生成内容<br /></li></ul><ul data-lake-indent=\"1\"><li>内容数量<br /></li><li>内容质量<br /></li></ul><ul><li>消费内容<br /></li></ul><ul data-lake-indent=\"1\"><li>数据展示<br /></li><li>商业化<br /></li></ul><p><br /></p><p>人的管理</p><ul><li>积极性<br /></li></ul><ul data-lake-indent=\"1\"><li>权益体系<br /></li><li>创作指导<br /></li><li>激励体系<br /></li></ul><ul><li>拉新/留存<br /></li></ul><ul data-lake-indent=\"1\"><li>新人任务<br /></li></ul><ul><li>使用体感<br /></li></ul><ul data-lake-indent=\"1\"><li>编辑器<br /></li></ul><p><br /></p><p>用户角度</p><ul><li>钱<br /></li><li>荣誉<br /></li></ul><p><br /></p><p><br /></p><h1 id=\"6e818306\"><a href=\"https://www.yuque.com/qianwang/notes/gpesx4/edit#l4tuxv\" target=\"_blank\"></a>信息流</h1><p>自媒体</p><p>机构号</p><p>爬虫</p><p><br /></p><p>原始内容 -- 审核 -- 可推荐内容 -- 筛选/推荐 -- 下发 -- 展示 -- 消费 -- 回流 --画像沉淀</p><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"df368884\">前言</h1><p>网络上跑的有三种流：</p><ul><li>人流</li><li>信息流</li><li>资金流</li></ul><p><br /></p><p>人流 （通讯/社交）-- 腾讯</p><p>信息流 -- 百度</p><p>资金流 -- 阿里</p><p><br /></p><h1 id=\"What\"><a href=\"https://www.yuque.com/qianwang/notes/gpesx4/edit#w0wwrn\" target=\"_blank\"></a>What</h1><p>信息流，广义来讲就是内容，狭义来讲内容以瀑布流的形式展示</p><p>现在大多数app都以信息流的方式展示内容，如新闻类的头条</p><p><br /></p><p><br /></p><h1 id=\"593c78c7\"><a href=\"https://www.yuque.com/qianwang/notes/gpesx4/edit#7ioeri\" target=\"_blank\"></a>自媒体平台</h1><p>围绕着内容，又称B端内容创作平台</p><p><br /></p><p>B端用户产生内容，C端用户消费内容</p><ul><li>生成内容<br /></li></ul><ul data-lake-indent=\"1\"><li>内容数量<br /></li><li>内容质量<br /></li></ul><ul><li>消费内容<br /></li></ul><ul data-lake-indent=\"1\"><li>数据展示<br /></li><li>商业化<br /></li></ul><p><br /></p><p>人的管理</p><ul><li>积极性<br /></li></ul><ul data-lake-indent=\"1\"><li>权益体系<br /></li><li>创作指导<br /></li><li>激励体系<br /></li></ul><ul><li>拉新/留存<br /></li></ul><ul data-lake-indent=\"1\"><li>新人任务<br /></li></ul><ul><li>使用体感<br /></li></ul><ul data-lake-indent=\"1\"><li>编辑器<br /></li></ul><p><br /></p><p>用户角度</p><ul><li>钱<br /></li><li>荣誉<br /></li></ul><p><br /></p><p><br /></p><h1 id=\"6e818306\"><a href=\"https://www.yuque.com/qianwang/notes/gpesx4/edit#l4tuxv\" target=\"_blank\"></a>信息流</h1><p>自媒体</p><p>机构号</p><p>爬虫</p><p><br /></p><p>原始内容 -- 审核 -- 可推荐内容 -- 筛选/推荐 -- 下发 -- 展示 -- 消费 -- 回流 --画像沉淀</p><p><br /><cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T12:23:35.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T12:23:15.000Z",
    "updated_at": "2019-06-06T13:15:29.000Z",
    "published_at": "2019-04-17T12:23:35.000Z",
    "first_published_at": "2019-04-17T12:23:35.000Z",
    "word_count": 227,
    "cover": null,
    "description": "前言网络上跑的有三种流：人流信息流资金流人流 （通讯/社交）-- 腾讯信息流 -- 百度资金流 -- 阿里What信息流，广义来讲就是内容，狭义来讲内容以瀑布流的形式展示现在大多数app都以信息流的方式展示内容，如新闻类的头条自媒体平台围绕着内容，又称B端内容创作平台B端用户产生内容，C端用户...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553183,
    "slug": "5b816630-590a-4633-a595-a7cd2e6fc7ac",
    "title": "jenkins 从git拉取代码",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "步骤\n==\n\njenkins已集成git插件（如无，请自行下载）\n\n1\\. 去到源码管理栏，选中Git：\n------------------\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503497725-35e4cd01-7345-47d7-94f9-4f024b9f643b.png)\n\n **使用http协议去获取代码**\n------------------\n\n Repository URL填写http的git地址，此时未选择相应的Credentials，会有图中红色提示\n\n****![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503497864-25f199fd-1f13-4dff-be08-ffcb24c37195.png)****\n-----------------------------------------------------------------------------------------------------\n\n HTTP协议的话，需要输入账号密码来验证，点击Add，输入的账号密码并保存，记得kind选择“Username with password”\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503497955-784cd04f-f920-4cfc-9451-482079c51fe4.png)\n\n选后Credentials选中刚刚新增的账号密码，红色提示消失；\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503498031-b866372e-6240-402e-886c-bc44a141bd9c.png)\n\n使用ssh协议去获取代码\n------------\n\n Repository URL填写ssh的git地址，此时未选择相应的Credentials，会有图中红色提示\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503498140-7a1dcb11-8bf7-4820-a35e-7b67788a38ae.png)\n\n点击Add，需要添加ssh的credentials，这里需要上传的是**私钥（不是公钥！！）**\n\n私钥文件存放在~/.ssh/id\\_rsa 文件中，  \n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503498248-ece2661d-a68b-48c6-bdaa-c3f69b3b1493.png)  \n可参考[http://blog.csdn.net/gw569453350game/article/details/51911179](http://blog.csdn.net/gw569453350game/article/details/51911179)\n\n2\\. 查看是否成功获取git代码\n-----------------\n\n首先可以查看jenkins的控制台输出日志，是否报错\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503498339-c45ddedb-bc07-416c-8835-bf13d40a4dce.png)\n\n或者直接去到jenkins的工作目录\n\n/var/lib/jenkins/workspace/\n\n查看代码是否clone下来\n\n  \n  \n\n**疑问点（公钥和私钥的理解）**\n\n为什么linux上直接可以git clone成功，而用jenkins去执行不成功呢，然后jenkins为什么不用公钥而要密钥呢\n\n个人理解：ssh生成的公钥和私钥是一对的，我们在linux上通过ssh协议获取git代码，也是先在linux生成公钥+私钥，然后把公钥上传到git服务端，然后获取代码的流程是：\n\na. linux把公钥上传到git服务器；\n\nb. git服务器使用公钥加密信息（这里指代码），把信息传回给linux；\n\nc. linux拿到信息后，通过本地的私钥解密信息，得到代码；\n\n**而公钥私钥存放在～/.ssh下，每个用户都不一样**\n\n而jenkins的执行是用jenkins用户去执行的，当git服务把信息给到jenkins的时候，jenkins在他的～/.ssh下没有对应的私钥，因此需要将私钥告诉jenkins，这就是jenkins为什么需要添加私钥；\n",
    "body_draft": "",
    "body_html": "<a name=\"步骤\"></a><h1 id=\"52b36576\">步骤</h1><p><br /></p><p>jenkins已集成git插件（如无，请自行下载）</p><p><br /></p><a name=\"1.-去到源码管理栏，选中Git：\"></a><h2 id=\"05df5881\">1. 去到源码管理栏，选中Git：</h2><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503497725-35e4cd01-7345-47d7-94f9-4f024b9f643b.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><a name=\"-strong-使用http协议去获取代码--strong-\"></a><h2 id=\"405aa26f\"><strong>使用http协议去获取代码</strong></h2><p><br /></p><p>Repository URL填写http的git地址，此时未选择相应的Credentials，会有图中红色提示</p><p><br /></p><a name=\"-strong---strong--card-type=-inline--name=-image--value=-data-%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503497864-25f199fd-1f13-4dff-be08-ffcb24c37195.png%22%2C%22alt%22%3A%22%22%7D----card--strong---strong-\"></a><h2 id=\"6f0dcd01\"><strong></strong><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503497864-25f199fd-1f13-4dff-be08-ffcb24c37195.png#alt=\" style=\"max-width: 600px;\" /><strong></strong></h2><p><br /></p><p>HTTP协议的话，需要输入账号密码来验证，点击Add，输入的账号密码并保存，记得kind选择“Username with password”</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503497955-784cd04f-f920-4cfc-9451-482079c51fe4.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>选后Credentials选中刚刚新增的账号密码，红色提示消失；</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503498031-b866372e-6240-402e-886c-bc44a141bd9c.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><a name=\"使用ssh协议去获取代码\"></a><h2 id=\"9de0f68c\">使用ssh协议去获取代码</h2><p><br /></p><p>Repository URL填写ssh的git地址，此时未选择相应的Credentials，会有图中红色提示</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503498140-7a1dcb11-8bf7-4820-a35e-7b67788a38ae.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>点击Add，需要添加ssh的credentials，这里需要上传的是<strong>私钥（不是公钥！！）</strong></p><p><br /></p><p>私钥文件存放在~/.ssh/id_rsa 文件中，<br />\n<img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503498248-ece2661d-a68b-48c6-bdaa-c3f69b3b1493.png#alt=\" style=\"max-width: 600px;\" /><br />\n可参考<a href=\"http://blog.csdn.net/gw569453350game/article/details/51911179\" target=\"_blank\">http://blog.csdn.net/gw569453350game/article/details/51911179</a></p><p><br /></p><a name=\"2.-查看是否成功获取git代码\"></a><h2 id=\"d45fd778\">2. 查看是否成功获取git代码</h2><p><br /></p><p>首先可以查看jenkins的控制台输出日志，是否报错</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503498339-c45ddedb-bc07-416c-8835-bf13d40a4dce.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>或者直接去到jenkins的工作目录</p><p><br /></p><p>/var/lib/jenkins/workspace/</p><p><br /></p><p>查看代码是否clone下来</p><p><br /></p><p><strong>疑问点（公钥和私钥的理解）</strong></p><p><br /></p><p>为什么linux上直接可以git clone成功，而用jenkins去执行不成功呢，然后jenkins为什么不用公钥而要密钥呢</p><p><br /></p><p>个人理解：ssh生成的公钥和私钥是一对的，我们在linux上通过ssh协议获取git代码，也是先在linux生成公钥+私钥，然后把公钥上传到git服务端，然后获取代码的流程是：</p><p><br /></p><p>a. linux把公钥上传到git服务器；</p><p><br /></p><p>b. git服务器使用公钥加密信息（这里指代码），把信息传回给linux；</p><p><br /></p><p>c. linux拿到信息后，通过本地的私钥解密信息，得到代码；</p><p><br /></p><p><strong>而公钥私钥存放在～/.ssh下，每个用户都不一样</strong></p><p><br /></p><p>而jenkins的执行是用jenkins用户去执行的，当git服务把信息给到jenkins的时候，jenkins在他的～/.ssh下没有对应的私钥，因此需要将私钥告诉jenkins，这就是jenkins为什么需要添加私钥；</p>",
    "body_lake": "<!doctype lake><a name=\"步骤\"></a><h1 id=\"52b36576\">步骤</h1><p><br /></p><p>jenkins已集成git插件（如无，请自行下载）</p><p><br /></p><a name=\"1.-去到源码管理栏，选中Git：\"></a><h2 id=\"05df5881\">1. 去到源码管理栏，选中Git：</h2><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503497725-35e4cd01-7345-47d7-94f9-4f024b9f643b.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><a name=\"-strong-使用http协议去获取代码--strong-\"></a><h2 id=\"405aa26f\"><strong>使用http协议去获取代码</strong></h2><p><br /></p><p>Repository URL填写http的git地址，此时未选择相应的Credentials，会有图中红色提示</p><p><br /></p><a name=\"-strong---strong--card-type=-inline--name=-image--value=-data-%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503497864-25f199fd-1f13-4dff-be08-ffcb24c37195.png%22%2C%22alt%22%3A%22%22%7D----card--strong---strong-\"></a><h2 id=\"6f0dcd01\"><strong></strong><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503497864-25f199fd-1f13-4dff-be08-ffcb24c37195.png%22%2C%22alt%22%3A%22%22%7D\"></card><strong></strong></h2><p><br /></p><p>HTTP协议的话，需要输入账号密码来验证，点击Add，输入的账号密码并保存，记得kind选择“Username with password”</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503497955-784cd04f-f920-4cfc-9451-482079c51fe4.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>选后Credentials选中刚刚新增的账号密码，红色提示消失；</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503498031-b866372e-6240-402e-886c-bc44a141bd9c.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><a name=\"使用ssh协议去获取代码\"></a><h2 id=\"9de0f68c\">使用ssh协议去获取代码</h2><p><br /></p><p>Repository URL填写ssh的git地址，此时未选择相应的Credentials，会有图中红色提示</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503498140-7a1dcb11-8bf7-4820-a35e-7b67788a38ae.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>点击Add，需要添加ssh的credentials，这里需要上传的是<strong>私钥（不是公钥！！）</strong></p><p><br /></p><p>私钥文件存放在~/.ssh/id_rsa 文件中，<br />\n<card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503498248-ece2661d-a68b-48c6-bdaa-c3f69b3b1493.png%22%2C%22alt%22%3A%22%22%7D\"></card><br />\n可参考<a href=\"http://blog.csdn.net/gw569453350game/article/details/51911179\" target=\"_blank\">http://blog.csdn.net/gw569453350game/article/details/51911179</a></p><p><br /></p><a name=\"2.-查看是否成功获取git代码\"></a><h2 id=\"d45fd778\">2. 查看是否成功获取git代码</h2><p><br /></p><p>首先可以查看jenkins的控制台输出日志，是否报错</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503498339-c45ddedb-bc07-416c-8835-bf13d40a4dce.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>或者直接去到jenkins的工作目录</p><p><br /></p><p>/var/lib/jenkins/workspace/</p><p><br /></p><p>查看代码是否clone下来</p><p><br /></p><p><strong>疑问点（公钥和私钥的理解）</strong></p><p><br /></p><p>为什么linux上直接可以git clone成功，而用jenkins去执行不成功呢，然后jenkins为什么不用公钥而要密钥呢</p><p><br /></p><p>个人理解：ssh生成的公钥和私钥是一对的，我们在linux上通过ssh协议获取git代码，也是先在linux生成公钥+私钥，然后把公钥上传到git服务端，然后获取代码的流程是：</p><p><br /></p><p>a. linux把公钥上传到git服务器；</p><p><br /></p><p>b. git服务器使用公钥加密信息（这里指代码），把信息传回给linux；</p><p><br /></p><p>c. linux拿到信息后，通过本地的私钥解密信息，得到代码；</p><p><br /></p><p><strong>而公钥私钥存放在～/.ssh下，每个用户都不一样</strong></p><p><br /></p><p>而jenkins的执行是用jenkins用户去执行的，当git服务把信息给到jenkins的时候，jenkins在他的～/.ssh下没有对应的私钥，因此需要将私钥告诉jenkins，这就是jenkins为什么需要添加私钥；</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T12:18:27.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T12:18:27.000Z",
    "updated_at": "2019-04-17T12:18:28.000Z",
    "published_at": "2019-04-17T12:18:27.000Z",
    "first_published_at": null,
    "word_count": 517,
    "cover": null,
    "description": "步骤 jenkins已集成git插件（如无，请自行下载）  1. 去到源码管理栏，选中Git：   使用http协议去获取代码 Repository URL填写http的git地址，此时未选择相应的Credentials，会有图中红色提示   HTTP协议的话，需要输入账号密码来验证，点击Ad...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553173,
    "slug": "faf56d3b-d999-44d6-9516-68459f5602f6",
    "title": "通过jenkins API去build一个job",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "背景\n==\n\n查看jenkins的api\n\n直接访问 JENKINS\\_URL/job/JOB\\_NAME/api/ 就可以查看jenkins的api\n\nbuild一个job的话，是POST请求 JENKINS\\_URL/job/JOB\\_NAME/build\n\n会提示：\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370152-a9bbac06-249c-447e-8358-22a6e5c69881.png)\n\n这是jenkins的安全策略导致的，需要传递一个crumb\n\n 解决方法\n=====\n\n有两个方案，\n\n第一种方案：\n\n1\\. 先去掉jenkins的安全策略设置，如图，去掉勾选\n\n在jenkins全局安全设置中 取消勾选 “防止跨站点请求伪造（Prevent Cross Site Request Forgery exploits）”\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370237-1a3f3726-1e14-449c-ad5a-1de721ffc796.png)\n\n2\\. 允许anonymous 访问，如下图，勾选上\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370333-0fbe242c-7a64-4cb1-aaab-3b0a3ba78dd4.png)\n\n3\\. 设置token，token是针对指定job的，所以去到job中去设置\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370436-444176c0-8296-499c-9577-ba8b1edefa74.png)\n\n那么就可以通过POST请求访问 JENKINS\\_URL/job/test1/build?token=TOKEN\\_NAME 触发这个job了\n\n第二种方案： **安全这块不用去掉防止跨站点请求伪造，通过传递crumb来实现；但允许anonymous 访问还是要设置的**\n\n POST请求的时候带上这个Jenkins-Crumb（推荐这种方法）\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370533-0efa7f64-0e3a-44ce-8da0-3a98aab780d4.png)\n\n 访问 JENKINS\\_URL/crumbIssuer/api/json 就可以获取到你的crumb，当然不同的客户端去访问得到的不一样\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370627-13df13be-0d81-4d0e-b24d-66febecd7661.png)\n\n备注\n==\n\n将文中的JENKINS\\_URL替换成你自己的jenkins地址，\n\nJOB\\_NAME替换成job的名字；\n\nTOKEN\\_NAME 替换成你自己写的token值，如我上面的jwentest1\n",
    "body_draft": "",
    "body_html": "<a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>查看jenkins的api</p><p><br /></p><p>直接访问 JENKINS_URL/job/JOB_NAME/api/ 就可以查看jenkins的api</p><p><br /></p><p>build一个job的话，是POST请求 JENKINS_URL/job/JOB_NAME/build</p><p><br /></p><p>会提示：</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370152-a9bbac06-249c-447e-8358-22a6e5c69881.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>这是jenkins的安全策略导致的，需要传递一个crumb</p><p><br /></p><a name=\"解决方法\"></a><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p>有两个方案，</p><p><br /></p><p>第一种方案：</p><p><br /></p><p>1. 先去掉jenkins的安全策略设置，如图，去掉勾选</p><p><br /></p><p>在jenkins全局安全设置中 取消勾选 “防止跨站点请求伪造（Prevent Cross Site Request Forgery exploits）”</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370237-1a3f3726-1e14-449c-ad5a-1de721ffc796.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>2. 允许anonymous 访问，如下图，勾选上</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370333-0fbe242c-7a64-4cb1-aaab-3b0a3ba78dd4.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>3. 设置token，token是针对指定job的，所以去到job中去设置</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370436-444176c0-8296-499c-9577-ba8b1edefa74.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>那么就可以通过POST请求访问 JENKINS_URL/job/test1/build?token=TOKEN_NAME 触发这个job了</p><p><br /></p><p>第二种方案： <strong>安全这块不用去掉防止跨站点请求伪造，通过传递crumb来实现；但允许anonymous 访问还是要设置的</strong></p><p><br /></p><p>POST请求的时候带上这个Jenkins-Crumb（推荐这种方法）</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370533-0efa7f64-0e3a-44ce-8da0-3a98aab780d4.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>访问 JENKINS_URL/crumbIssuer/api/json 就可以获取到你的crumb，当然不同的客户端去访问得到的不一样</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503370627-13df13be-0d81-4d0e-b24d-66febecd7661.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><a name=\"备注\"></a><h1 id=\"2432b575\">备注</h1><p><br /></p><p>将文中的JENKINS_URL替换成你自己的jenkins地址，</p><p><br /></p><p>JOB_NAME替换成job的名字；</p><p><br /></p><p>TOKEN_NAME 替换成你自己写的token值，如我上面的jwentest1</p>",
    "body_lake": "<!doctype lake><a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>查看jenkins的api</p><p><br /></p><p>直接访问 JENKINS_URL/job/JOB_NAME/api/ 就可以查看jenkins的api</p><p><br /></p><p>build一个job的话，是POST请求 JENKINS_URL/job/JOB_NAME/build</p><p><br /></p><p>会提示：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503370152-a9bbac06-249c-447e-8358-22a6e5c69881.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>这是jenkins的安全策略导致的，需要传递一个crumb</p><p><br /></p><a name=\"解决方法\"></a><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p>有两个方案，</p><p><br /></p><p>第一种方案：</p><p><br /></p><p>1. 先去掉jenkins的安全策略设置，如图，去掉勾选</p><p><br /></p><p>在jenkins全局安全设置中 取消勾选 “防止跨站点请求伪造（Prevent Cross Site Request Forgery exploits）”</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503370237-1a3f3726-1e14-449c-ad5a-1de721ffc796.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>2. 允许anonymous 访问，如下图，勾选上</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503370333-0fbe242c-7a64-4cb1-aaab-3b0a3ba78dd4.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>3. 设置token，token是针对指定job的，所以去到job中去设置</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503370436-444176c0-8296-499c-9577-ba8b1edefa74.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>那么就可以通过POST请求访问 JENKINS_URL/job/test1/build?token=TOKEN_NAME 触发这个job了</p><p><br /></p><p>第二种方案： <strong>安全这块不用去掉防止跨站点请求伪造，通过传递crumb来实现；但允许anonymous 访问还是要设置的</strong></p><p><br /></p><p>POST请求的时候带上这个Jenkins-Crumb（推荐这种方法）</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503370533-0efa7f64-0e3a-44ce-8da0-3a98aab780d4.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>访问 JENKINS_URL/crumbIssuer/api/json 就可以获取到你的crumb，当然不同的客户端去访问得到的不一样</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503370627-13df13be-0d81-4d0e-b24d-66febecd7661.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><a name=\"备注\"></a><h1 id=\"2432b575\">备注</h1><p><br /></p><p>将文中的JENKINS_URL替换成你自己的jenkins地址，</p><p><br /></p><p>JOB_NAME替换成job的名字；</p><p><br /></p><p>TOKEN_NAME 替换成你自己写的token值，如我上面的jwentest1</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T12:16:25.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T12:16:25.000Z",
    "updated_at": "2019-04-17T12:16:25.000Z",
    "published_at": "2019-04-17T12:16:25.000Z",
    "first_published_at": null,
    "word_count": 318,
    "cover": null,
    "description": "背景 查看jenkins的api 直接访问 JENKINS_URL/job/JOB_NAME/api/ 就可以查看jenkins的api build一个job的话，是POST请求 JENKINS_URL/job/JOB_NAME/build 会提示：  这是jenkins的安全策略导致的，需要...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553164,
    "slug": "4b43e20c-9594-424f-9c51-f745d0971120",
    "title": "通过代码去执行testNG用例",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8e1b944f\"></a>\n# 背景\n\n用testNG去编写的测试用例，通过@Test去执行用例，一般本地都是通过IDE去执行相应的方法，持续集成的话，都是通过maven来执行或指定testNG.xml执行，但是如果想通过接口/界面去执行测试用例呢？\n\n<a name=\"52b36576\"></a>\n# 步骤\n\ntestNG其实提供了两种通过代码执行的方法\n\n1. 通过class来执行，show the code：\n\n```java\nTestNG testNG = new TestNG();\ntestNG.setTestClasses(new Class[] {WebTestFactory.class});\ntestNG.run();\n```\n\n新建一个TestNG对象，setTestClass传递一个用例的class进去，然后执行用例run();\n\n2. 通过suite来执行，show the code：\n\n```java\nXmlSuite suite = new XmlSuite();\nsuite.setName(\"TmpSuite\");\nXmlTest test = new XmlTest(suite);\ntest.setName(\"TmpTest\");\nList<XmlClass> classes = new ArrayList<XmlClass>();\nclasses.add(new XmlClass(\"test.failures.Child\"));\ntest.setXmlClasses(classes) ;\n        \n\nList<XmlSuite> suites = new ArrayList<XmlSuite>();\nsuites.add(suite);\nTestNG tng = new TestNG();\ntng.setXmlSuites(suites);\ntng.run();\n```\n\n<a name=\"2432b575\"></a>\n# 备注\n\n想直接调用指定的方法的话，需要自己折腾下，后续补上\n\n//TODO\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>用testNG去编写的测试用例，通过@Test去执行用例，一般本地都是通过IDE去执行相应的方法，持续集成的话，都是通过maven来执行或指定testNG.xml执行，但是如果想通过接口/界面去执行测试用例呢？</p><p><br /></p><h1 id=\"52b36576\">步骤</h1><p><br /></p><p>testNG其实提供了两种通过代码执行的方法</p><p><br /></p><p>1. 通过class来执行，show the code：</p><p><br /></p><pre data-lang=\"java\"><code>TestNG testNG = new TestNG();\ntestNG.setTestClasses(new Class[] {WebTestFactory.class});\ntestNG.run();</code></pre><p><br /></p><p>新建一个TestNG对象，setTestClass传递一个用例的class进去，然后执行用例run();</p><p><br /></p><p>2. 通过suite来执行，show the code：</p><p><br /></p><pre data-lang=\"java\"><code>XmlSuite suite = new XmlSuite();\nsuite.setName(&quot;TmpSuite&quot;);\nXmlTest test = new XmlTest(suite);\ntest.setName(&quot;TmpTest&quot;);\nList&lt;XmlClass&gt; classes = new ArrayList&lt;XmlClass&gt;();\nclasses.add(new XmlClass(&quot;test.failures.Child&quot;));\ntest.setXmlClasses(classes) ;\n        \n\nList&lt;XmlSuite&gt; suites = new ArrayList&lt;XmlSuite&gt;();\nsuites.add(suite);\nTestNG tng = new TestNG();\ntng.setXmlSuites(suites);\ntng.run();</code></pre><p><br /></p><h1 id=\"2432b575\">备注</h1><p><br /></p><p>想直接调用指定的方法的话，需要自己折腾下，后续补上</p><p><br /></p><p>//TODO</p>",
    "body_lake": "<!doctype lake><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>用testNG去编写的测试用例，通过@Test去执行用例，一般本地都是通过IDE去执行相应的方法，持续集成的话，都是通过maven来执行或指定testNG.xml执行，但是如果想通过接口/界面去执行测试用例呢？</p><p><br /></p><h1 id=\"52b36576\">步骤</h1><p><br /></p><p>testNG其实提供了两种通过代码执行的方法</p><p><br /></p><p>1. 通过class来执行，show the code：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22TestNG%20testNG%20%3D%20new%20TestNG()%3B%5CntestNG.setTestClasses(new%20Class%5B%5D%20%7BWebTestFactory.class%7D)%3B%5CntestNG.run()%3B%22%2C%22id%22%3A%22jmhDI%22%7D\"></card><p><br /></p><p>新建一个TestNG对象，setTestClass传递一个用例的class进去，然后执行用例run();</p><p><br /></p><p>2. 通过suite来执行，show the code：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22XmlSuite%20suite%20%3D%20new%20XmlSuite()%3B%5Cnsuite.setName(%5C%22TmpSuite%5C%22)%3B%5CnXmlTest%20test%20%3D%20new%20XmlTest(suite)%3B%5Cntest.setName(%5C%22TmpTest%5C%22)%3B%5CnList%3CXmlClass%3E%20classes%20%3D%20new%20ArrayList%3CXmlClass%3E()%3B%5Cnclasses.add(new%20XmlClass(%5C%22test.failures.Child%5C%22))%3B%5Cntest.setXmlClasses(classes)%20%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%5CnList%3CXmlSuite%3E%20suites%20%3D%20new%20ArrayList%3CXmlSuite%3E()%3B%5Cnsuites.add(suite)%3B%5CnTestNG%20tng%20%3D%20new%20TestNG()%3B%5Cntng.setXmlSuites(suites)%3B%5Cntng.run()%3B%22%2C%22id%22%3A%22xo6cz%22%7D\"></card><p><br /></p><h1 id=\"2432b575\">备注</h1><p><br /></p><p>想直接调用指定的方法的话，需要自己折腾下，后续补上</p><p><br /></p><p>//TODO<cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T12:15:48.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T12:14:38.000Z",
    "updated_at": "2019-04-17T12:15:48.000Z",
    "published_at": "2019-04-17T12:15:48.000Z",
    "first_published_at": null,
    "word_count": 248,
    "cover": null,
    "description": "背景用testNG去编写的测试用例，通过@Test去执行用例，一般本地都是通过IDE去执行相应的方法，持续集成的话，都是通过maven来执行或指定testNG.xml执行，但是如果想通过接口/界面去执行测试用例呢？步骤testNG其实提供了两种通过代码执行的方法1. 通过class来执行，sh...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553152,
    "slug": "2c6389c2-c134-4c30-876f-55e2bf010c48",
    "title": "使用testNGListenter来自定义日志",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8e1b944f\"></a>\n# 背景\n\n用testNG写用例的时候，只是打印了请求的日志，没有打印这个用例的开始和结束的标识，想加上这个标识这样更好的排查问题\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503118908-2f222be0-6c2b-4d2c-86b2-a45fec5550e3.png#align=left&display=inline&height=260&originHeight=310&originWidth=889&status=done&width=746)\n\n这种日志是加在用例开始执行和结束，相当于spring中的AOP功能，今天翻阅了testNG的文档发现有监听器这玩意，这玩意可以在testNG执行的某一过程中进行操作；\n\n<a name=\"1c53b310\"></a>\n# 操作步骤\n\n直接show the code：\n\n```java\npublic class TestNGLogListener extends TestListenerAdapter {\n\n    static Logger logger = LogManager.getLogger(TestNGLogListener.class.getName());\n\n    @Override\n    public void onTestFailure(ITestResult tr) {\n        log(String.format(\"[method: %s]\",tr.getName())+ \"--Test method failed\\n\");\n    }\n\n    @Override\n    public void onTestSkipped(ITestResult tr) {\n        log(String.format(\"[method: %s]\",tr.getName())+ \"--Test method skipped\\n\");\n    }\n\n    @Override\n    public void onTestSuccess(ITestResult tr) {\n        log(String.format(\"[method: %s]\",tr.getName())+ \"--Test method success\\n\");\n    }\n\n    @Override\n    public void onTestStart(ITestResult tr) {\n        log(String.format(\"[method: %s]\",tr.getName())+ \"-- START\");\n    }\n\n    private void log(String string) {\n        logger.info(string);\n    }\n}\n```\n\n\n1. 写编写一个监听器的类，继承 TestListenerAdapter 这个类，需要重写对应的几个方法\n\n```java\nvoid onTestFailure(ITestResult result) // 用例执行结果失败\nvoid onTestSkipped(ITestResult result) // 跳过该条用例\nvoid onTestSuccess(ITestResult result) // 用例执行结果成功\nvoid onTestStart(ITestResult tr) // 用例开始执行的时候\n```\n\n2. 使用这个监听器，有两种方法\n\n2.1 第一种是直接在测试用例的class上加Listener注解，如下：\n\n```java\n@Listeners({CustomListener.class })\npublic class SampleTest {\n\n    @Test\n    public void testMethodOne(){\n        Assert.assertTrue(true);\n    }\n\n    @Test\n    public void testMethodTwo(){\n        Assert.assertTrue(false);\n    }\n\n    @Test(dependsOnMethods={\"testMethodTwo\"})\n    public void testMethodThree(){\n        Assert.assertTrue(true);\n    }\n\n}\n```\n\n\n2.2 直接在testNG.xml文件中添加，如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE suite SYSTEM \"http://testng.org/testng-1.0.dtd\">\n<suite name=\"wm-api-autotest\">\n    <test name=\"Test\">\n        <packages>\n            <package name=\"com.jwen.demo\"/>\n        </packages>\n    </test>\n    <listeners>\n        <listener class-name=com.jwen.demo.common.TestNGLogListener'/>\n    </listeners>\n</suite> <!-- Suite -->\n```\n\n2.3 效果展示：\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555503119013-41ca3e7b-220e-4b0b-bd67-5367bd7441ad.png#align=left&display=inline&height=88&originHeight=140&originWidth=1191&status=done&width=746)\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>用testNG写用例的时候，只是打印了请求的日志，没有打印这个用例的开始和结束的标识，想加上这个标识这样更好的排查问题</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503118908-2f222be0-6c2b-4d2c-86b2-a45fec5550e3.png#align=left&amp;display=inline&amp;height=260&amp;originHeight=310&amp;originWidth=889&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><p>这种日志是加在用例开始执行和结束，相当于spring中的AOP功能，今天翻阅了testNG的文档发现有监听器这玩意，这玩意可以在testNG执行的某一过程中进行操作；</p><p><br /></p><h1 id=\"1c53b310\">操作步骤</h1><p><br /></p><p>直接show the code：</p><p><br /></p><pre data-lang=\"java\"><code>public class TestNGLogListener extends TestListenerAdapter {\n\n    static Logger logger = LogManager.getLogger(TestNGLogListener.class.getName());\n\n    @Override\n    public void onTestFailure(ITestResult tr) {\n        log(String.format(&quot;[method: %s]&quot;,tr.getName())+ &quot;--Test method failed\\n&quot;);\n    }\n\n    @Override\n    public void onTestSkipped(ITestResult tr) {\n        log(String.format(&quot;[method: %s]&quot;,tr.getName())+ &quot;--Test method skipped\\n&quot;);\n    }\n\n    @Override\n    public void onTestSuccess(ITestResult tr) {\n        log(String.format(&quot;[method: %s]&quot;,tr.getName())+ &quot;--Test method success\\n&quot;);\n    }\n\n    @Override\n    public void onTestStart(ITestResult tr) {\n        log(String.format(&quot;[method: %s]&quot;,tr.getName())+ &quot;-- START&quot;);\n    }\n\n    private void log(String string) {\n        logger.info(string);\n    }\n}</code></pre><p><br /></p><p><br /></p><p>1. 写编写一个监听器的类，继承 TestListenerAdapter 这个类，需要重写对应的几个方法</p><p><br /></p><pre data-lang=\"java\"><code>void onTestFailure(ITestResult result) // 用例执行结果失败\nvoid onTestSkipped(ITestResult result) // 跳过该条用例\nvoid onTestSuccess(ITestResult result) // 用例执行结果成功\nvoid onTestStart(ITestResult tr) // 用例开始执行的时候</code></pre><p><br /></p><p>2. 使用这个监听器，有两种方法</p><p><br /></p><p>2.1 第一种是直接在测试用例的class上加Listener注解，如下：</p><p><br /></p><pre data-lang=\"java\"><code>@Listeners({CustomListener.class })\npublic class SampleTest {\n\n    @Test\n    public void testMethodOne(){\n        Assert.assertTrue(true);\n    }\n\n    @Test\n    public void testMethodTwo(){\n        Assert.assertTrue(false);\n    }\n\n    @Test(dependsOnMethods={&quot;testMethodTwo&quot;})\n    public void testMethodThree(){\n        Assert.assertTrue(true);\n    }\n\n}</code></pre><p><br /></p><p><br /></p><p>2.2 直接在testNG.xml文件中添加，如下：</p><p><br /></p><pre data-lang=\"xml\"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;\n&lt;suite name=&quot;wm-api-autotest&quot;&gt;\n    &lt;test name=&quot;Test&quot;&gt;\n        &lt;packages&gt;\n            &lt;package name=&quot;com.jwen.demo&quot;/&gt;\n        &lt;/packages&gt;\n    &lt;/test&gt;\n    &lt;listeners&gt;\n        &lt;listener class-name=com.jwen.demo.common.TestNGLogListener'/&gt;\n    &lt;/listeners&gt;\n&lt;/suite&gt; &lt;!-- Suite --&gt;</code></pre><p><br /></p><p>2.3 效果展示：</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555503119013-41ca3e7b-220e-4b0b-bd67-5367bd7441ad.png#align=left&amp;display=inline&amp;height=88&amp;originHeight=140&amp;originWidth=1191&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>用testNG写用例的时候，只是打印了请求的日志，没有打印这个用例的开始和结束的标识，想加上这个标识这样更好的排查问题</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503118908-2f222be0-6c2b-4d2c-86b2-a45fec5550e3.png%22%2C%22originWidth%22%3A889%2C%22originHeight%22%3A310%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A260%7D\"></card></p><p><br /></p><p>这种日志是加在用例开始执行和结束，相当于spring中的AOP功能，今天翻阅了testNG的文档发现有监听器这玩意，这玩意可以在testNG执行的某一过程中进行操作；</p><p><br /></p><h1 id=\"1c53b310\">操作步骤</h1><p><br /></p><p>直接show the code：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22public%20class%20TestNGLogListener%20extends%20TestListenerAdapter%20%7B%5Cn%5Cn%20%20%20%20static%20Logger%20logger%20%3D%20LogManager.getLogger(TestNGLogListener.class.getName())%3B%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20void%20onTestFailure(ITestResult%20tr)%20%7B%5Cn%20%20%20%20%20%20%20%20log(String.format(%5C%22%5Bmethod%3A%20%25s%5D%5C%22%2Ctr.getName())%2B%20%5C%22--Test%20method%20failed%5C%5Cn%5C%22)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20void%20onTestSkipped(ITestResult%20tr)%20%7B%5Cn%20%20%20%20%20%20%20%20log(String.format(%5C%22%5Bmethod%3A%20%25s%5D%5C%22%2Ctr.getName())%2B%20%5C%22--Test%20method%20skipped%5C%5Cn%5C%22)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20void%20onTestSuccess(ITestResult%20tr)%20%7B%5Cn%20%20%20%20%20%20%20%20log(String.format(%5C%22%5Bmethod%3A%20%25s%5D%5C%22%2Ctr.getName())%2B%20%5C%22--Test%20method%20success%5C%5Cn%5C%22)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20void%20onTestStart(ITestResult%20tr)%20%7B%5Cn%20%20%20%20%20%20%20%20log(String.format(%5C%22%5Bmethod%3A%20%25s%5D%5C%22%2Ctr.getName())%2B%20%5C%22--%20START%5C%22)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20private%20void%20log(String%20string)%20%7B%5Cn%20%20%20%20%20%20%20%20logger.info(string)%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22id%22%3A%22PnmzK%22%7D\"></card><p><br /></p><p><br /></p><p>1. 写编写一个监听器的类，继承 TestListenerAdapter 这个类，需要重写对应的几个方法</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22void%20onTestFailure(ITestResult%20result)%20%2F%2F%20%E7%94%A8%E4%BE%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%A4%B1%E8%B4%A5%5Cnvoid%20onTestSkipped(ITestResult%20result)%20%2F%2F%20%E8%B7%B3%E8%BF%87%E8%AF%A5%E6%9D%A1%E7%94%A8%E4%BE%8B%5Cnvoid%20onTestSuccess(ITestResult%20result)%20%2F%2F%20%E7%94%A8%E4%BE%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%88%90%E5%8A%9F%5Cnvoid%20onTestStart(ITestResult%20tr)%20%2F%2F%20%E7%94%A8%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%22%2C%22id%22%3A%22v3UVJ%22%7D\"></card><p><br /></p><p>2. 使用这个监听器，有两种方法</p><p><br /></p><p>2.1 第一种是直接在测试用例的class上加Listener注解，如下：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22%40Listeners(%7BCustomListener.class%20%7D)%5Cnpublic%20class%20SampleTest%20%7B%5Cn%5Cn%20%20%20%20%40Test%5Cn%20%20%20%20public%20void%20testMethodOne()%7B%5Cn%20%20%20%20%20%20%20%20Assert.assertTrue(true)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%40Test%5Cn%20%20%20%20public%20void%20testMethodTwo()%7B%5Cn%20%20%20%20%20%20%20%20Assert.assertTrue(false)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%40Test(dependsOnMethods%3D%7B%5C%22testMethodTwo%5C%22%7D)%5Cn%20%20%20%20public%20void%20testMethodThree()%7B%5Cn%20%20%20%20%20%20%20%20Assert.assertTrue(true)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%7D%22%2C%22id%22%3A%22859ccefa%22%7D\"></card><p><br /></p><p><br /></p><p>2.2 直接在testNG.xml文件中添加，如下：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22xml%22%2C%22code%22%3A%22%3C%3Fxml%20version%3D%5C%221.0%5C%22%20encoding%3D%5C%22UTF-8%5C%22%3F%3E%5Cn%3C!DOCTYPE%20suite%20SYSTEM%20%5C%22http%3A%2F%2Ftestng.org%2Ftestng-1.0.dtd%5C%22%3E%5Cn%3Csuite%20name%3D%5C%22wm-api-autotest%5C%22%3E%5Cn%20%20%20%20%3Ctest%20name%3D%5C%22Test%5C%22%3E%5Cn%20%20%20%20%20%20%20%20%3Cpackages%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Cpackage%20name%3D%5C%22com.jwen.demo%5C%22%2F%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Fpackages%3E%5Cn%20%20%20%20%3C%2Ftest%3E%5Cn%20%20%20%20%3Clisteners%3E%5Cn%20%20%20%20%20%20%20%20%3Clistener%20class-name%3Dcom.jwen.demo.common.TestNGLogListener'%2F%3E%5Cn%20%20%20%20%3C%2Flisteners%3E%5Cn%3C%2Fsuite%3E%20%3C!--%20Suite%20--%3E%22%2C%22id%22%3A%22Qji8R%22%7D\"></card><p><br /></p><p>2.3 效果展示：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555503119013-41ca3e7b-220e-4b0b-bd67-5367bd7441ad.png%22%2C%22originWidth%22%3A1191%2C%22originHeight%22%3A140%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A88%7D\"></card></p><p><br /><cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T12:14:02.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T12:12:00.000Z",
    "updated_at": "2019-04-17T12:14:02.000Z",
    "published_at": "2019-04-17T12:14:02.000Z",
    "first_published_at": null,
    "word_count": 474,
    "cover": null,
    "description": "背景用testNG写用例的时候，只是打印了请求的日志，没有打印这个用例的开始和结束的标识，想加上这个标识这样更好的排查问题这种日志是加在用例开始执行和结束，相当于spring中的AOP功能，今天翻阅了testNG的文档发现有监听器这玩意，这玩意可以在testNG执行的某一过程中进行操作；操作步...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553097,
    "slug": "f384f355-3377-4276-a40c-8b039547299a",
    "title": "Python之dict(或对象)与json之间的互相转化",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "> 转载：[https://blog.csdn.net/qq_33689414/article/details/78307018](https://blog.csdn.net/qq_33689414/article/details/78307018)\n\n\n在Python语言中，json数据与dict字典以及对象之间的转化，是必不可少的操作。\n\n在Python中自带json库。通过`import json`导入。\n\n在json模块有2个方法，\n\n- `loads()`：将json数据转化成dict数据\n- `dumps()`：将dict数据转化成json数据\n- `load()`：读取json文件数据，转成dict数据\n- `dump()`：将dict数据转化成json数据后写入json文件\n\n下面是具体的示例：\n\n<a name=\"a7125fa1\"></a>\n#### dict字典转json数据\n\n```python\nimport json\n \ndef dict_to_json():\n    dict = {}\n    dict['name'] = 'many'\n    dict['age'] = 10\n    dict['sex'] = 'male'\n    print(dict)  # 输出：{'name': 'many', 'age': 10, 'sex': 'male'}\n    j = json.dumps(dict)\n    print(j)  # 输出：{\"name\": \"many\", \"age\": 10, \"sex\": \"male\"}\n \n \nif __name__ == '__main__':\n    dict_to_json()\n```\n\n<a name=\"250b37ff\"></a>\n#### 对象转json数据\n\n```python\nimport json\n\ndef obj_to_json():\n    stu = Student('007', '007', 28, 'male', '13000000000', '123@qq.com')\n    print(type(stu))  # <class 'json_test.student.Student'>\n    stu = stu.__dict__  # 将对象转成dict字典\n    print(type(stu))  # <class 'dict'>\n    print(stu)  # {'id': '007', 'name': '007', 'age': 28, 'sex': 'male', 'phone': '13000000000', 'email': '123@qq.com'}\n    j = json.dumps(obj=stu)\n    print(j)  # {\"id\": \"007\", \"name\": \"007\", \"age\": 28, \"sex\": \"male\", \"phone\": \"13000000000\", \"email\": \"123@qq.com\"}\n\n\nif __name__ == '__main__':\n    obj_to_json()\n```\n\n<a name=\"810a6fb4\"></a>\n#### json数据转成dict字典\n\n```python\nimport json\n\ndef json_to_dict():\n    j = '{\"id\": \"007\", \"name\": \"007\", \"age\": 28, \"sex\": \"male\", \"phone\": \"13000000000\", \"email\": \"123@qq.com\"}'\n    dict = json.loads(s=j)\n    print(dict)  # {'id': '007', 'name': '007', 'age': 28, 'sex': 'male', 'phone': '13000000000', 'email': '123@qq.com'}\n\n\nif __name__ == '__main__':\n    json_to_dict()\n```\n\n<a name=\"fcbcfe6a\"></a>\n#### json数据转成对象\n\n```python\nimport json\n\ndef json_to_obj():\n    j = '{\"id\": \"007\", \"name\": \"007\", \"age\": 28, \"sex\": \"male\", \"phone\": \"13000000000\", \"email\": \"123@qq.com\"}'\n    dict = json.loads(s=j)\n    stu = Student()\n    stu.__dict__ = dict\n    print('id: ' + stu.id + ' name: ' + stu.name + ' age: ' + str(stu.age) + ' sex: ' + str(\n        stu.sex) + ' phone: ' + stu.phone + ' email: ' + stu.email)  # id: 007 name: 007 age: 28 sex: male phone: 13000000000 email: 123@qq.com\n\n\nif __name__ == '__main__':\n    json_to_obj()\n```\n\n<a name=\"f4a209d7\"></a>\n#### json的`load()`与`dump()`方法的使用\n\n- `dump()`方法的使用\n\n```python\nimport json\n\ndef dict_to_json_write_file():\n    dict = {}\n    dict['name'] = 'many'\n    dict['age'] = 10\n    dict['sex'] = 'male'\n    print(dict)  # {'name': 'many', 'age': 10, 'sex': 'male'}\n    with open('1.json', 'w') as f:\n        json.dump(dict, f)  # 会在目录下生成一个1.json的文件，文件内容是dict数据转成的json数据\n\n\nif __name__ == '__main__':\n    dict_to_json_write_file()\n```\n\n\n- `load()`的使用\n\n```python\nimport json\n\ndef json_file_to_dict():\n    with open('1.json', 'r') as f:\n        dict = json.load(fp=f)\n        print(dict)  # {'name': 'many', 'age': 10, 'sex': 'male'}\n\n\nif __name__ == '__main__':\n    json_file_to_dict()\n```\n\n",
    "body_draft": "",
    "body_html": "<blockquote><p>转载：<a href=\"https://blog.csdn.net/qq_33689414/article/details/78307018\" target=\"_blank\">https://blog.csdn.net/qq_33689414/article/details/78307018</a></p></blockquote><p><br /></p><p>在Python语言中，json数据与dict字典以及对象之间的转化，是必不可少的操作。</p><p><br /></p><p>在Python中自带json库。通过<code>import json</code>导入。</p><p><br /></p><p>在json模块有2个方法，</p><p><br /></p><ul><li><code>loads()</code>：将json数据转化成dict数据</li></ul><ul><li><code>dumps()</code>：将dict数据转化成json数据</li></ul><ul><li><code>load()</code>：读取json文件数据，转成dict数据</li></ul><ul><li><code>dump()</code>：将dict数据转化成json数据后写入json文件</li></ul><p><br /></p><p>下面是具体的示例：</p><p><br /></p><h4 id=\"a7125fa1\">dict字典转json数据</h4><p><br /></p><pre data-lang=\"python\"><code>import json\n \ndef dict_to_json():\n    dict = {}\n    dict['name'] = 'many'\n    dict['age'] = 10\n    dict['sex'] = 'male'\n    print(dict)  # 输出：{'name': 'many', 'age': 10, 'sex': 'male'}\n    j = json.dumps(dict)\n    print(j)  # 输出：{&quot;name&quot;: &quot;many&quot;, &quot;age&quot;: 10, &quot;sex&quot;: &quot;male&quot;}\n \n \nif __name__ == '__main__':\n    dict_to_json()</code></pre><p><br /></p><h4 id=\"250b37ff\">对象转json数据</h4><p><br /></p><pre data-lang=\"python\"><code>import json\n\ndef obj_to_json():\n    stu = Student('007', '007', 28, 'male', '13000000000', '123@qq.com')\n    print(type(stu))  # &lt;class 'json_test.student.Student'&gt;\n    stu = stu.__dict__  # 将对象转成dict字典\n    print(type(stu))  # &lt;class 'dict'&gt;\n    print(stu)  # {'id': '007', 'name': '007', 'age': 28, 'sex': 'male', 'phone': '13000000000', 'email': '123@qq.com'}\n    j = json.dumps(obj=stu)\n    print(j)  # {&quot;id&quot;: &quot;007&quot;, &quot;name&quot;: &quot;007&quot;, &quot;age&quot;: 28, &quot;sex&quot;: &quot;male&quot;, &quot;phone&quot;: &quot;13000000000&quot;, &quot;email&quot;: &quot;123@qq.com&quot;}\n\n\nif __name__ == '__main__':\n    obj_to_json()</code></pre><p><br /></p><h4 id=\"810a6fb4\">json数据转成dict字典</h4><p><br /></p><pre data-lang=\"python\"><code>import json\n\ndef json_to_dict():\n    j = '{&quot;id&quot;: &quot;007&quot;, &quot;name&quot;: &quot;007&quot;, &quot;age&quot;: 28, &quot;sex&quot;: &quot;male&quot;, &quot;phone&quot;: &quot;13000000000&quot;, &quot;email&quot;: &quot;123@qq.com&quot;}'\n    dict = json.loads(s=j)\n    print(dict)  # {'id': '007', 'name': '007', 'age': 28, 'sex': 'male', 'phone': '13000000000', 'email': '123@qq.com'}\n\n\nif __name__ == '__main__':\n    json_to_dict()</code></pre><p><br /></p><h4 id=\"fcbcfe6a\">json数据转成对象</h4><p><br /></p><pre data-lang=\"python\"><code>import json\n\ndef json_to_obj():\n    j = '{&quot;id&quot;: &quot;007&quot;, &quot;name&quot;: &quot;007&quot;, &quot;age&quot;: 28, &quot;sex&quot;: &quot;male&quot;, &quot;phone&quot;: &quot;13000000000&quot;, &quot;email&quot;: &quot;123@qq.com&quot;}'\n    dict = json.loads(s=j)\n    stu = Student()\n    stu.__dict__ = dict\n    print('id: ' + stu.id + ' name: ' + stu.name + ' age: ' + str(stu.age) + ' sex: ' + str(\n        stu.sex) + ' phone: ' + stu.phone + ' email: ' + stu.email)  # id: 007 name: 007 age: 28 sex: male phone: 13000000000 email: 123@qq.com\n\n\nif __name__ == '__main__':\n    json_to_obj()</code></pre><p><br /></p><h4 id=\"f4a209d7\">json的<code>load()</code>与<code>dump()</code>方法的使用</h4><p><br /></p><ul><li><code>dump()</code>方法的使用</li><p><br /></p></ul><pre data-lang=\"python\"><code>import json\n\ndef dict_to_json_write_file():\n    dict = {}\n    dict['name'] = 'many'\n    dict['age'] = 10\n    dict['sex'] = 'male'\n    print(dict)  # {'name': 'many', 'age': 10, 'sex': 'male'}\n    with open('1.json', 'w') as f:\n        json.dump(dict, f)  # 会在目录下生成一个1.json的文件，文件内容是dict数据转成的json数据\n\n\nif __name__ == '__main__':\n    dict_to_json_write_file()</code></pre><ul><p><br /></p><li><code>load()</code>的使用</li><p><br /></p></ul><pre data-lang=\"python\"><code>import json\n\ndef json_file_to_dict():\n    with open('1.json', 'r') as f:\n        dict = json.load(fp=f)\n        print(dict)  # {'name': 'many', 'age': 10, 'sex': 'male'}\n\n\nif __name__ == '__main__':\n    json_file_to_dict()</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><blockquote><p>转载：<a href=\"https://blog.csdn.net/qq_33689414/article/details/78307018\" target=\"_blank\">https://blog.csdn.net/qq_33689414/article/details/78307018</a></p></blockquote><p><br /></p><p>在Python语言中，json数据与dict字典以及对象之间的转化，是必不可少的操作。</p><p><br /></p><p>在Python中自带json库。通过<code>import json</code>导入。</p><p><br /></p><p>在json模块有2个方法，</p><p><br /></p><ul><li><code>loads()</code>：将json数据转化成dict数据</li></ul><ul><li><code>dumps()</code>：将dict数据转化成json数据</li></ul><ul><li><code>load()</code>：读取json文件数据，转成dict数据</li></ul><ul><li><code>dump()</code>：将dict数据转化成json数据后写入json文件</li></ul><p><br /></p><p>下面是具体的示例：</p><p><br /></p><h4 id=\"a7125fa1\">dict字典转json数据</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22import%20json%5Cn%20%5Cndef%20dict_to_json()%3A%5Cn%20%20%20%20dict%20%3D%20%7B%7D%5Cn%20%20%20%20dict%5B'name'%5D%20%3D%20'many'%5Cn%20%20%20%20dict%5B'age'%5D%20%3D%2010%5Cn%20%20%20%20dict%5B'sex'%5D%20%3D%20'male'%5Cn%20%20%20%20print(dict)%20%20%23%20%E8%BE%93%E5%87%BA%EF%BC%9A%7B'name'%3A%20'many'%2C%20'age'%3A%2010%2C%20'sex'%3A%20'male'%7D%5Cn%20%20%20%20j%20%3D%20json.dumps(dict)%5Cn%20%20%20%20print(j)%20%20%23%20%E8%BE%93%E5%87%BA%EF%BC%9A%7B%5C%22name%5C%22%3A%20%5C%22many%5C%22%2C%20%5C%22age%5C%22%3A%2010%2C%20%5C%22sex%5C%22%3A%20%5C%22male%5C%22%7D%5Cn%20%5Cn%20%5Cnif%20__name__%20%3D%3D%20'__main__'%3A%5Cn%20%20%20%20dict_to_json()%22%2C%22id%22%3A%22Wld0u%22%7D\"></card><p><br /></p><h4 id=\"250b37ff\">对象转json数据</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22import%20json%5Cn%5Cndef%20obj_to_json()%3A%5Cn%20%20%20%20stu%20%3D%20Student('007'%2C%20'007'%2C%2028%2C%20'male'%2C%20'13000000000'%2C%20'123%40qq.com')%5Cn%20%20%20%20print(type(stu))%20%20%23%20%3Cclass%20'json_test.student.Student'%3E%5Cn%20%20%20%20stu%20%3D%20stu.__dict__%20%20%23%20%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%88%90dict%E5%AD%97%E5%85%B8%5Cn%20%20%20%20print(type(stu))%20%20%23%20%3Cclass%20'dict'%3E%5Cn%20%20%20%20print(stu)%20%20%23%20%7B'id'%3A%20'007'%2C%20'name'%3A%20'007'%2C%20'age'%3A%2028%2C%20'sex'%3A%20'male'%2C%20'phone'%3A%20'13000000000'%2C%20'email'%3A%20'123%40qq.com'%7D%5Cn%20%20%20%20j%20%3D%20json.dumps(obj%3Dstu)%5Cn%20%20%20%20print(j)%20%20%23%20%7B%5C%22id%5C%22%3A%20%5C%22007%5C%22%2C%20%5C%22name%5C%22%3A%20%5C%22007%5C%22%2C%20%5C%22age%5C%22%3A%2028%2C%20%5C%22sex%5C%22%3A%20%5C%22male%5C%22%2C%20%5C%22phone%5C%22%3A%20%5C%2213000000000%5C%22%2C%20%5C%22email%5C%22%3A%20%5C%22123%40qq.com%5C%22%7D%5Cn%5Cn%5Cnif%20__name__%20%3D%3D%20'__main__'%3A%5Cn%20%20%20%20obj_to_json()%22%2C%22id%22%3A%22pRDow%22%7D\"></card><p><br /></p><h4 id=\"810a6fb4\">json数据转成dict字典</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22import%20json%5Cn%5Cndef%20json_to_dict()%3A%5Cn%20%20%20%20j%20%3D%20'%7B%5C%22id%5C%22%3A%20%5C%22007%5C%22%2C%20%5C%22name%5C%22%3A%20%5C%22007%5C%22%2C%20%5C%22age%5C%22%3A%2028%2C%20%5C%22sex%5C%22%3A%20%5C%22male%5C%22%2C%20%5C%22phone%5C%22%3A%20%5C%2213000000000%5C%22%2C%20%5C%22email%5C%22%3A%20%5C%22123%40qq.com%5C%22%7D'%5Cn%20%20%20%20dict%20%3D%20json.loads(s%3Dj)%5Cn%20%20%20%20print(dict)%20%20%23%20%7B'id'%3A%20'007'%2C%20'name'%3A%20'007'%2C%20'age'%3A%2028%2C%20'sex'%3A%20'male'%2C%20'phone'%3A%20'13000000000'%2C%20'email'%3A%20'123%40qq.com'%7D%5Cn%5Cn%5Cnif%20__name__%20%3D%3D%20'__main__'%3A%5Cn%20%20%20%20json_to_dict()%22%2C%22id%22%3A%22QXNkg%22%7D\"></card><p><br /></p><h4 id=\"fcbcfe6a\">json数据转成对象</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22import%20json%5Cn%5Cndef%20json_to_obj()%3A%5Cn%20%20%20%20j%20%3D%20'%7B%5C%22id%5C%22%3A%20%5C%22007%5C%22%2C%20%5C%22name%5C%22%3A%20%5C%22007%5C%22%2C%20%5C%22age%5C%22%3A%2028%2C%20%5C%22sex%5C%22%3A%20%5C%22male%5C%22%2C%20%5C%22phone%5C%22%3A%20%5C%2213000000000%5C%22%2C%20%5C%22email%5C%22%3A%20%5C%22123%40qq.com%5C%22%7D'%5Cn%20%20%20%20dict%20%3D%20json.loads(s%3Dj)%5Cn%20%20%20%20stu%20%3D%20Student()%5Cn%20%20%20%20stu.__dict__%20%3D%20dict%5Cn%20%20%20%20print('id%3A%20'%20%2B%20stu.id%20%2B%20'%20name%3A%20'%20%2B%20stu.name%20%2B%20'%20age%3A%20'%20%2B%20str(stu.age)%20%2B%20'%20sex%3A%20'%20%2B%20str(%5Cn%20%20%20%20%20%20%20%20stu.sex)%20%2B%20'%20phone%3A%20'%20%2B%20stu.phone%20%2B%20'%20email%3A%20'%20%2B%20stu.email)%20%20%23%20id%3A%20007%20name%3A%20007%20age%3A%2028%20sex%3A%20male%20phone%3A%2013000000000%20email%3A%20123%40qq.com%5Cn%5Cn%5Cnif%20__name__%20%3D%3D%20'__main__'%3A%5Cn%20%20%20%20json_to_obj()%22%2C%22id%22%3A%228lZX0%22%7D\"></card><p><br /></p><h4 id=\"f4a209d7\">json的<code>load()</code>与<code>dump()</code>方法的使用</h4><p><br /></p><ul><li><code>dump()</code>方法的使用</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22import%20json%5Cn%5Cndef%20dict_to_json_write_file()%3A%5Cn%20%20%20%20dict%20%3D%20%7B%7D%5Cn%20%20%20%20dict%5B'name'%5D%20%3D%20'many'%5Cn%20%20%20%20dict%5B'age'%5D%20%3D%2010%5Cn%20%20%20%20dict%5B'sex'%5D%20%3D%20'male'%5Cn%20%20%20%20print(dict)%20%20%23%20%7B'name'%3A%20'many'%2C%20'age'%3A%2010%2C%20'sex'%3A%20'male'%7D%5Cn%20%20%20%20with%20open('1.json'%2C%20'w')%20as%20f%3A%5Cn%20%20%20%20%20%20%20%20json.dump(dict%2C%20f)%20%20%23%20%E4%BC%9A%E5%9C%A8%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA1.json%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%98%AFdict%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%88%90%E7%9A%84json%E6%95%B0%E6%8D%AE%5Cn%5Cn%5Cnif%20__name__%20%3D%3D%20'__main__'%3A%5Cn%20%20%20%20dict_to_json_write_file()%22%2C%22id%22%3A%22Ai9J6%22%7D\"></card><ul><p><br /></p><li><code>load()</code>的使用<cursor /></li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22import%20json%5Cn%5Cndef%20json_file_to_dict()%3A%5Cn%20%20%20%20with%20open('1.json'%2C%20'r')%20as%20f%3A%5Cn%20%20%20%20%20%20%20%20dict%20%3D%20json.load(fp%3Df)%5Cn%20%20%20%20%20%20%20%20print(dict)%20%20%23%20%7B'name'%3A%20'many'%2C%20'age'%3A%2010%2C%20'sex'%3A%20'male'%7D%5Cn%5Cn%5Cnif%20__name__%20%3D%3D%20'__main__'%3A%5Cn%20%20%20%20json_file_to_dict()%22%2C%22id%22%3A%22wHENI%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T12:01:57.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T11:57:50.000Z",
    "updated_at": "2019-04-17T12:01:57.000Z",
    "published_at": "2019-04-17T12:01:57.000Z",
    "first_published_at": null,
    "word_count": 638,
    "cover": null,
    "description": "转载：https://blog.csdn.net/qq_33689414/article/details/78307018在Python语言中，json数据与dict字典以及对象之间的转化，是必不可少的操作。在Python中自带json库。通过import json导入。在json模块有2个方...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553096,
    "slug": "89755bd6-9dc3-4d8f-b617-4bb20158c901",
    "title": "java 执行sql文件",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"42550742\"></a>\n# # 背景\n\n用例执行完毕，期望回滚数据，因此希望执行sql来回滚数据\n\n<a name=\"65638618\"></a>\n# # 步骤\n\n直接show代码，借助的是mybatis的ScriptRunner\n\n\n```java\n/**\n     * 执行xx库下的表备份脚本\n     *\n     * @param tableName\n     */\n    public static void runSqlInStat(String tableName) {\n\n        String className = Configurations.INSTANCE.get(\"jdbc.xx.driver\");\n        String dbUrl = Configurations.INSTANCE.get(\"jdbc.xx.url\");\n        String dbUsername = Configurations.INSTANCE.get(\"jdbc.xx.username\");\n        String dbPassword = Configurations.INSTANCE.get(\"jdbc.xx.password\");\n\n        try {\n            Class.forName(className);\n            Connection conn = DriverManager.getConnection(dbUrl, dbUsername, dbPassword);\n            ScriptRunner runner = new ScriptRunner(conn);\n            runner.setAutoCommit(true);\n\n            String fileName = String.format(\"src/main/resources/db/%s.sql\", tableName);\n            File file = new File(fileName);\n\n            try {\n                if (file.getName().endsWith(\".sql\")) {\n                    runner.setFullLineDelimiter(false);\n                    runner.setDelimiter(\";\");//语句结束符号设置\n                    runner.setLogWriter(null);//日志数据输出，这样就不会输出过程\n                    runner.setSendFullScript(false);\n                    runner.setAutoCommit(true);\n                    runner.setStopOnError(true);\n                    runner.runScript(new InputStreamReader(new FileInputStream(fileName), \"utf8\"));\n                    logger.info(String.format(\"【%s】回滚成功\", tableName));\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n            conn.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n\n            e.printStackTrace();\n        }\n\n    }\n```\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"42550742\"># 背景</h1><p><br /></p><p>用例执行完毕，期望回滚数据，因此希望执行sql来回滚数据</p><p><br /></p><h1 id=\"65638618\"># 步骤</h1><p><br /></p><p>直接show代码，借助的是mybatis的ScriptRunner</p><p><br /></p><p><br /></p><pre data-lang=\"java\"><code>/**\n     * 执行xx库下的表备份脚本\n     *\n     * @param tableName\n     */\n    public static void runSqlInStat(String tableName) {\n\n        String className = Configurations.INSTANCE.get(&quot;jdbc.xx.driver&quot;);\n        String dbUrl = Configurations.INSTANCE.get(&quot;jdbc.xx.url&quot;);\n        String dbUsername = Configurations.INSTANCE.get(&quot;jdbc.xx.username&quot;);\n        String dbPassword = Configurations.INSTANCE.get(&quot;jdbc.xx.password&quot;);\n\n        try {\n            Class.forName(className);\n            Connection conn = DriverManager.getConnection(dbUrl, dbUsername, dbPassword);\n            ScriptRunner runner = new ScriptRunner(conn);\n            runner.setAutoCommit(true);\n\n            String fileName = String.format(&quot;src/main/resources/db/%s.sql&quot;, tableName);\n            File file = new File(fileName);\n\n            try {\n                if (file.getName().endsWith(&quot;.sql&quot;)) {\n                    runner.setFullLineDelimiter(false);\n                    runner.setDelimiter(&quot;;&quot;);//语句结束符号设置\n                    runner.setLogWriter(null);//日志数据输出，这样就不会输出过程\n                    runner.setSendFullScript(false);\n                    runner.setAutoCommit(true);\n                    runner.setStopOnError(true);\n                    runner.runScript(new InputStreamReader(new FileInputStream(fileName), &quot;utf8&quot;));\n                    logger.info(String.format(&quot;【%s】回滚成功&quot;, tableName));\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n            conn.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n\n            e.printStackTrace();\n        }\n\n    }</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>用例执行完毕，期望回滚数据，因此希望执行sql来回滚数据</p><p><br /></p><h1 id=\"65638618\"># 步骤</h1><p><br /></p><p>直接show代码，借助的是mybatis的ScriptRunner</p><p><br /></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22%2F**%5Cn%20%20%20%20%20*%20%E6%89%A7%E8%A1%8Cxx%E5%BA%93%E4%B8%8B%E7%9A%84%E8%A1%A8%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC%5Cn%20%20%20%20%20*%5Cn%20%20%20%20%20*%20%40param%20tableName%5Cn%20%20%20%20%20*%2F%5Cn%20%20%20%20public%20static%20void%20runSqlInStat(String%20tableName)%20%7B%5Cn%5Cn%20%20%20%20%20%20%20%20String%20className%20%3D%20Configurations.INSTANCE.get(%5C%22jdbc.xx.driver%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20String%20dbUrl%20%3D%20Configurations.INSTANCE.get(%5C%22jdbc.xx.url%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20String%20dbUsername%20%3D%20Configurations.INSTANCE.get(%5C%22jdbc.xx.username%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20String%20dbPassword%20%3D%20Configurations.INSTANCE.get(%5C%22jdbc.xx.password%5C%22)%3B%5Cn%5Cn%20%20%20%20%20%20%20%20try%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20Class.forName(className)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20Connection%20conn%20%3D%20DriverManager.getConnection(dbUrl%2C%20dbUsername%2C%20dbPassword)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20ScriptRunner%20runner%20%3D%20new%20ScriptRunner(conn)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20runner.setAutoCommit(true)%3B%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20String%20fileName%20%3D%20String.format(%5C%22src%2Fmain%2Fresources%2Fdb%2F%25s.sql%5C%22%2C%20tableName)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20File%20file%20%3D%20new%20File(fileName)%3B%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20try%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(file.getName().endsWith(%5C%22.sql%5C%22))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20runner.setFullLineDelimiter(false)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20runner.setDelimiter(%5C%22%3B%5C%22)%3B%2F%2F%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%8F%B7%E8%AE%BE%E7%BD%AE%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20runner.setLogWriter(null)%3B%2F%2F%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%BE%93%E5%87%BA%E8%BF%87%E7%A8%8B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20runner.setSendFullScript(false)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20runner.setAutoCommit(true)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20runner.setStopOnError(true)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20runner.runScript(new%20InputStreamReader(new%20FileInputStream(fileName)%2C%20%5C%22utf8%5C%22))%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20logger.info(String.format(%5C%22%E3%80%90%25s%E3%80%91%E5%9B%9E%E6%BB%9A%E6%88%90%E5%8A%9F%5C%22%2C%20tableName))%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%20catch%20(Exception%20e)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20e.printStackTrace()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20conn.close()%3B%5Cn%20%20%20%20%20%20%20%20%7D%20catch%20(SQLException%20e)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20e.printStackTrace()%3B%5Cn%20%20%20%20%20%20%20%20%7D%20catch%20(ClassNotFoundException%20e)%20%7B%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20e.printStackTrace()%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%7D%22%2C%22id%22%3A%22208b42fc%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T12:02:47.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T11:57:14.000Z",
    "updated_at": "2019-04-17T12:02:47.000Z",
    "published_at": "2019-04-17T12:02:47.000Z",
    "first_published_at": null,
    "word_count": 233,
    "cover": null,
    "description": "# 背景用例执行完毕，期望回滚数据，因此希望执行sql来回滚数据# 步骤直接show代码，借助的是mybatis的ScriptRunner/**      * 执行xx库下的表备份脚本      *      * @param tableName      */     public stat...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553093,
    "slug": "9588715a-4a94-49cc-b267-57f735bff326",
    "title": "修改jenkins启动的默认用户",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "\\# 背景\n=====\n\n通过yum命令安装的jenkins，通过service jenkins去启动jenkins的话，默认的用户是jenkins，但jenkins这个用户是无法通过su切换过去的 ，在某些环节可能产生问题，期望修改默认启动用户\n\n\\# 过程\n=====\n\n1\\. 先修改/etc/sysconfig/jenkins文件中的参数，JENKINS\\_USER\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555502187913-44f286e4-a6cf-44c1-a998-db25176034e4.png)\n\n2\\. 修改jenkins启动涉及到的目录权限，修改为nemo\n\n目录如下：\n\n/var/lib/jenkins/\n/var/log/jenkins/\n/var/cache/jenkins/\n/usr/lib/jenkins/jenkins.war /etc/sysconfig/jenkins\n\n修改命令如下：\n\nchown -R nemo:nemo 目录\n\n注：nemo是一个用户名字，修改为期望的用户即可",
    "body_draft": "",
    "body_html": "<a name=\"#-背景\"></a><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>通过yum命令安装的jenkins，通过service jenkins去启动jenkins的话，默认的用户是jenkins，但jenkins这个用户是无法通过su切换过去的 ，在某些环节可能产生问题，期望修改默认启动用户</p><p><br /></p><a name=\"#-过程\"></a><h1 id=\"7ce5d7fe\"># 过程</h1><p><br /></p><p>1. 先修改/etc/sysconfig/jenkins文件中的参数，JENKINS_USER</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555502187913-44f286e4-a6cf-44c1-a998-db25176034e4.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>2. 修改jenkins启动涉及到的目录权限，修改为nemo</p><p><br /></p><p>目录如下：</p><p><br /></p><p>/var/lib/jenkins/<br />\n/var/log/jenkins/<br />\n/var/cache/jenkins/<br />\n/usr/lib/jenkins/jenkins.war /etc/sysconfig/jenkins</p><p><br /></p><p>修改命令如下：</p><p><br /></p><p>chown -R nemo:nemo 目录</p><p><br /></p><p>注：nemo是一个用户名字，修改为期望的用户即可</p>",
    "body_lake": "<!doctype lake><a name=\"#-背景\"></a><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>通过yum命令安装的jenkins，通过service jenkins去启动jenkins的话，默认的用户是jenkins，但jenkins这个用户是无法通过su切换过去的 ，在某些环节可能产生问题，期望修改默认启动用户</p><p><br /></p><a name=\"#-过程\"></a><h1 id=\"7ce5d7fe\"># 过程</h1><p><br /></p><p>1. 先修改/etc/sysconfig/jenkins文件中的参数，JENKINS_USER</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555502187913-44f286e4-a6cf-44c1-a998-db25176034e4.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>2. 修改jenkins启动涉及到的目录权限，修改为nemo</p><p><br /></p><p>目录如下：</p><p><br /></p><p>/var/lib/jenkins/<br />\n/var/log/jenkins/<br />\n/var/cache/jenkins/<br />\n/usr/lib/jenkins/jenkins.war /etc/sysconfig/jenkins</p><p><br /></p><p>修改命令如下：</p><p><br /></p><p>chown -R nemo:nemo 目录</p><p><br /></p><p>注：nemo是一个用户名字，修改为期望的用户即可</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T11:56:38.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T11:56:38.000Z",
    "updated_at": "2019-04-17T11:56:38.000Z",
    "published_at": "2019-04-17T11:56:38.000Z",
    "first_published_at": null,
    "word_count": 153,
    "cover": null,
    "description": "# 背景 通过yum命令安装的jenkins，通过service jenkins去启动jenkins的话，默认的用户是jenkins，但jenkins这个用户是无法通过su切换过去的 ，在某些环节可能产生问题，期望修改默认启动用户  # 过程 1. 先修改/etc/sysconfig/jenk...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553089,
    "slug": "0566dd91-af66-4597-a5ce-f94d176610bf",
    "title": "jenkins 后台程序运行",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "\\# 背景\n=====\n\njenkins持续集成，需要任务后台执行（nohup执行）结果发现jenkins的job执行完后，看不到运行的进程\n\n\\# 步骤\n=====\n\n原因就是这么一个情况：**Jenkins任务结束时候自动关掉了所有的子进程**\n\n**不过可以设置一些东西让其可以在后台运行**\n\n**其实就是在脚本中加入一句**\n\nBUILD\\_ID=DONTKILLME\n\n问题的根本在于是Jenkins使用processTreeKiller杀掉了所有子进程，而且这是Jenkins的默认行为。其实回头来看这个问题，就发现Jenkins的做法非常合理。当一次build异常结束，或被人终止时，必然需要结束所有这次build启动的子进程。下面的link提供了更多细节，以及解决方法。https://wiki.jenkins-ci.org/display/JENKINS/ProcessTreeKiller",
    "body_draft": "",
    "body_html": "<a name=\"#-背景\"></a><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>jenkins持续集成，需要任务后台执行（nohup执行）结果发现jenkins的job执行完后，看不到运行的进程</p><p><br /></p><a name=\"#-步骤\"></a><h1 id=\"65638618\"># 步骤</h1><p><br /></p><p>原因就是这么一个情况：<strong>Jenkins任务结束时候自动关掉了所有的子进程</strong></p><p><br /></p><p><strong>不过可以设置一些东西让其可以在后台运行</strong></p><p><br /></p><p><strong>其实就是在脚本中加入一句</strong></p><p><br /></p><p>BUILD_ID=DONTKILLME</p><p><br /></p><p>问题的根本在于是Jenkins使用processTreeKiller杀掉了所有子进程，而且这是Jenkins的默认行为。其实回头来看这个问题，就发现Jenkins的做法非常合理。当一次build异常结束，或被人终止时，必然需要结束所有这次build启动的子进程。下面的link提供了更多细节，以及解决方法。<a href=\"https://wiki.jenkins-ci.org/display/JENKINS/ProcessTreeKiller\" target=\"_blank\">https://wiki.jenkins-ci.org/display/JENKINS/ProcessTreeKiller</a></p>",
    "body_lake": "<!doctype lake><a name=\"#-背景\"></a><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>jenkins持续集成，需要任务后台执行（nohup执行）结果发现jenkins的job执行完后，看不到运行的进程</p><p><br /></p><a name=\"#-步骤\"></a><h1 id=\"65638618\"># 步骤</h1><p><br /></p><p>原因就是这么一个情况：<strong>Jenkins任务结束时候自动关掉了所有的子进程</strong></p><p><br /></p><p><strong>不过可以设置一些东西让其可以在后台运行</strong></p><p><br /></p><p><strong>其实就是在脚本中加入一句</strong></p><p><br /></p><p>BUILD_ID=DONTKILLME</p><p><br /></p><p>问题的根本在于是Jenkins使用processTreeKiller杀掉了所有子进程，而且这是Jenkins的默认行为。其实回头来看这个问题，就发现Jenkins的做法非常合理。当一次build异常结束，或被人终止时，必然需要结束所有这次build启动的子进程。下面的link提供了更多细节，以及解决方法。<a href=\"https://wiki.jenkins-ci.org/display/JENKINS/ProcessTreeKiller\" target=\"_blank\">https://wiki.jenkins-ci.org/display/JENKINS/ProcessTreeKiller</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T11:56:11.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T11:56:11.000Z",
    "updated_at": "2019-04-17T11:56:11.000Z",
    "published_at": "2019-04-17T11:56:11.000Z",
    "first_published_at": null,
    "word_count": 207,
    "cover": null,
    "description": "# 背景 jenkins持续集成，需要任务后台执行（nohup执行）结果发现jenkins的job执行完后，看不到运行的进程  # 步骤 原因就是这么一个情况：Jenkins任务结束时候自动关掉了所有的子进程 不过可以设置一些东西让其可以在后台运行 其实就是在脚本中加入一句 BUILD_ID=...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553085,
    "slug": "00ce43d1-9c72-4bcf-aefe-2d0bc8a1ebbc",
    "title": "jvm linux 时区设置",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "\\# 背景\n=====\n\n在接入集团一个平台的时候，发现录制某个接口到测试环境回放，发现接口入参一致，一个start\\_day 一个end\\_day，但回放的时候会多调用一次数据库查询，很是奇怪；\n\n查阅业务代码，发现确实有逻辑会导致多查询一次，于是重点观察数据变化，发现录制回放两个时间不一致，相差12个小时；\n\n继续查阅业务日志，发现在第一次查询DB的时候，两次的时间不一样，就是说接口入参（String类型）一致，通过应用转化为int类型的时候就出问题了的，相差12个小时；\n\n因此猜测是**时区问题！！！**\n\n\\# 思路&解决\n========\n\n1\\. 既然发现是时区问题，比较好搞咯，去到录制机器A和回放机器B，通过linux命令查看时区\n\ndate -R  \n发现都是Fri, 06 Jul 2018 12:11:22 +0800  \n都是+8,东八区  \n  \ndate +\"%Z %z\"  \n结果发现还是一致呀，都是CST +0800\n\n2\\. 不对，时区一样呀，那么问题就是java执行不一样？ 核对了jdk版本，发现一致\n\n3\\. 那么就在两台机器上执行java代码试下：\n\nSystem.out.println(TimeZone.getDefault()); //输出当前默认时区\n\n发现了问题了，两台机器打印的不一致，A是上海，而B是纽约。。。\n\n4\\. 那么问题变成了jvm从哪里去获取时区的呢？经过查询大致如下：\n\n> 1)如有环境变量 TZ设置，则用TZ中设置的时区\n> \n> 2) 在 /etc/sysconfig/clock文件中找 \"ZONE\"的值\n> \n> 3）如2)都没，就用/etc/localtime 和 /usr/share/zoneinfo 下的时区文件进行匹配，如找到匹配的，就返回对应的路径和文件名。\n\n简单来说就是:\n\nTZ环境变量 --> /etc/sysconfig/clock文件  --> /etc/localtime文件 依次寻找\n\n5\\. 于是开始设置了，TZ不管了，加了/etc/sysconfig/clock，如下操作：\n\n新建一个/etc/sysconfig/clock，内容如下：\n\nZONE=\"Asia/Shanghai\" UTC\\=false ARC\\=false\n\n然后继续去查看时区，还是不对呀！！\n\n6\\. 继续设置/etc/localtime文件，如下操作：\n\nunlink /etc/localtime \nln \\-s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n就是初始化/etc/localtime ，然后将东八区的绑定上\n\n7\\. 在查看时区成功了，重新执行java代码，发现正常了\n\n8\\. 继续翻阅资料，发现：\n\n> 时区的配置文件是/etc/sysconfig/clock。用tzselect命令就可以修改这个配置文件，根据命令的提示进行修改就好了。\n> \n> 但是在实际工作中，发现这种方式是不能够使得服务器上的时间设置马上生效的，而且使用ntpdate去同步时间服务器也不能够更改时间。即使你使用了 date命令手工设置了时间的话，如果使用ntpdate去进行时间同步的话，时间又会被改动到原来的错误时区的时间。而生产的机器往往是非常重要的，不能够进行重启等操作。\n> \n> 1）/etc/sysconfig/clock 文件，只对 hwclock   \n> 命令有效，且只在系统启动和关闭的时候才有用（修改了其中的 UTC=true 到 UTC=false 的前后，执行 hwclock (--utc,  \n> 或 --localtime) 都没有变化，要重启系统后才生效）；  \n> 在 /etc/sysconfig/clock 中 UTC=false 时，date、hwclock、hwclcok --localtime 输出的时间应该都一致，且此时 hwclock --utc是没有意义的；  \n>   \n> 在 /etc/sysconfig/clock 中 UTC=ture 时，date、hwclock 的输出是一致的，hwclock --localtime 的输出则是UTC时间；  \n> 系统关闭时会同步系统时间到硬件时钟，系统启动时会从硬件时钟读取时间更新到系统，这2个步骤都要根据 /etc/sysconfig/clock 文件中UTC的参数来设置时区转换。\n\n意思就是修改/etc/sysconfi/clock是可行的，但是不会立即生效，需要重启。那么一切就说的通了\n\n\\# 后记\n=====\n\n参考资料：\n\nhttps://www.nowcoder.com/questionTerminal/1e794493ad564324a16da1c47545c117\n\nhttp://blog.51cto.com/5iwww/661863\n\nhttps://my.oschina.net/huawu/blog/4646\n\nhttp://linux.it.net.cn/CentOS/fast/2016/0511/21660.html\n\nhttps://blog.csdn.net/splenday/article/details/47065557\n\nhttps://unix.stackexchange.com/questions/110522/timezone-setting-in-linux",
    "body_draft": "",
    "body_html": "<a name=\"#-背景\"></a><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>在接入集团一个平台的时候，发现录制某个接口到测试环境回放，发现接口入参一致，一个start_day 一个end_day，但回放的时候会多调用一次数据库查询，很是奇怪；</p><p><br /></p><p>查阅业务代码，发现确实有逻辑会导致多查询一次，于是重点观察数据变化，发现录制回放两个时间不一致，相差12个小时；</p><p><br /></p><p>继续查阅业务日志，发现在第一次查询DB的时候，两次的时间不一样，就是说接口入参（String类型）一致，通过应用转化为int类型的时候就出问题了的，相差12个小时；</p><p><br /></p><p>因此猜测是<strong>时区问题！！！</strong></p><p><br /></p><a name=\"#-思路&amp;解决\"></a><h1 id=\"b1f1a302\"># 思路&amp;解决</h1><p><br /></p><p>1. 既然发现是时区问题，比较好搞咯，去到录制机器A和回放机器B，通过linux命令查看时区</p><p><br /></p><p>date -R<br />\n发现都是Fri, 06 Jul 2018 12:11:22 +0800<br />\n都是+8,东八区</p><p><br /></p><p>date +&quot;%Z %z&quot;<br />\n结果发现还是一致呀，都是CST +0800</p><p><br /></p><p>2. 不对，时区一样呀，那么问题就是java执行不一样？ 核对了jdk版本，发现一致</p><p><br /></p><p>3. 那么就在两台机器上执行java代码试下：</p><p><br /></p><p>System.out.println(TimeZone.getDefault()); //输出当前默认时区</p><p><br /></p><p>发现了问题了，两台机器打印的不一致，A是上海，而B是纽约。。。</p><p><br /></p><p>4. 那么问题变成了jvm从哪里去获取时区的呢？经过查询大致如下：</p><p><br /></p><blockquote><p>1)如有环境变量 TZ设置，则用TZ中设置的时区</p>\n<ol start=\"2\"><li>在 /etc/sysconfig/clock文件中找 &quot;ZONE&quot;的值</li></ol>\n<p>3）如2)都没，就用/etc/localtime 和 /usr/share/zoneinfo 下的时区文件进行匹配，如找到匹配的，就返回对应的路径和文件名。</p></blockquote><p><br /></p><p>简单来说就是:</p><p><br /></p><p>TZ环境变量 --&gt; /etc/sysconfig/clock文件  --&gt; /etc/localtime文件 依次寻找</p><p><br /></p><p>5. 于是开始设置了，TZ不管了，加了/etc/sysconfig/clock，如下操作：</p><p><br /></p><p>新建一个/etc/sysconfig/clock，内容如下：</p><p><br /></p><p>ZONE=&quot;Asia/Shanghai&quot; UTC=false ARC=false</p><p><br /></p><p>然后继续去查看时区，还是不对呀！！</p><p><br /></p><p>6. 继续设置/etc/localtime文件，如下操作：</p><p><br /></p><p>unlink /etc/localtime<br />\nln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p><p><br /></p><p>就是初始化/etc/localtime ，然后将东八区的绑定上</p><p><br /></p><p>7. 在查看时区成功了，重新执行java代码，发现正常了</p><p><br /></p><p>8. 继续翻阅资料，发现：</p><p><br /></p><blockquote><p>时区的配置文件是/etc/sysconfig/clock。用tzselect命令就可以修改这个配置文件，根据命令的提示进行修改就好了。</p>\n<p>但是在实际工作中，发现这种方式是不能够使得服务器上的时间设置马上生效的，而且使用ntpdate去同步时间服务器也不能够更改时间。即使你使用了 date命令手工设置了时间的话，如果使用ntpdate去进行时间同步的话，时间又会被改动到原来的错误时区的时间。而生产的机器往往是非常重要的，不能够进行重启等操作。</p>\n<p>1）/etc/sysconfig/clock 文件，只对 hwclock <br />\n命令有效，且只在系统启动和关闭的时候才有用（修改了其中的 UTC=true 到 UTC=false 的前后，执行 hwclock (--utc,<br />\n或 --localtime) 都没有变化，要重启系统后才生效）；<br />\n在 /etc/sysconfig/clock 中 UTC=false 时，date、hwclock、hwclcok --localtime 输出的时间应该都一致，且此时 hwclock --utc是没有意义的；</p>\n<p>在 /etc/sysconfig/clock 中 UTC=ture 时，date、hwclock 的输出是一致的，hwclock --localtime 的输出则是UTC时间；<br />\n系统关闭时会同步系统时间到硬件时钟，系统启动时会从硬件时钟读取时间更新到系统，这2个步骤都要根据 /etc/sysconfig/clock 文件中UTC的参数来设置时区转换。</p></blockquote><p><br /></p><p>意思就是修改/etc/sysconfi/clock是可行的，但是不会立即生效，需要重启。那么一切就说的通了</p><p><br /></p><a name=\"#-后记\"></a><h1 id=\"ec030200\"># 后记</h1><p><br /></p><p>参考资料：</p><p><br /></p><p><a href=\"https://www.nowcoder.com/questionTerminal/1e794493ad564324a16da1c47545c117\" target=\"_blank\">https://www.nowcoder.com/questionTerminal/1e794493ad564324a16da1c47545c117</a></p><p><br /></p><p><a href=\"http://blog.51cto.com/5iwww/661863\" target=\"_blank\">http://blog.51cto.com/5iwww/661863</a></p><p><br /></p><p><a href=\"https://my.oschina.net/huawu/blog/4646\" target=\"_blank\">https://my.oschina.net/huawu/blog/4646</a></p><p><br /></p><p><a href=\"http://linux.it.net.cn/CentOS/fast/2016/0511/21660.html\" target=\"_blank\">http://linux.it.net.cn/CentOS/fast/2016/0511/21660.html</a></p><p><br /></p><p><a href=\"https://blog.csdn.net/splenday/article/details/47065557\" target=\"_blank\">https://blog.csdn.net/splenday/article/details/47065557</a></p><p><br /></p><p><a href=\"https://unix.stackexchange.com/questions/110522/timezone-setting-in-linux\" target=\"_blank\">https://unix.stackexchange.com/questions/110522/timezone-setting-in-linux</a></p>",
    "body_lake": "<!doctype lake><a name=\"#-背景\"></a><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>在接入集团一个平台的时候，发现录制某个接口到测试环境回放，发现接口入参一致，一个start_day 一个end_day，但回放的时候会多调用一次数据库查询，很是奇怪；</p><p><br /></p><p>查阅业务代码，发现确实有逻辑会导致多查询一次，于是重点观察数据变化，发现录制回放两个时间不一致，相差12个小时；</p><p><br /></p><p>继续查阅业务日志，发现在第一次查询DB的时候，两次的时间不一样，就是说接口入参（String类型）一致，通过应用转化为int类型的时候就出问题了的，相差12个小时；</p><p><br /></p><p>因此猜测是<strong>时区问题！！！</strong></p><p><br /></p><a name=\"#-思路&解决\"></a><h1 id=\"b1f1a302\"># 思路&amp;解决</h1><p><br /></p><p>1. 既然发现是时区问题，比较好搞咯，去到录制机器A和回放机器B，通过linux命令查看时区</p><p><br /></p><p>date -R<br />\n发现都是Fri, 06 Jul 2018 12:11:22 +0800<br />\n都是+8,东八区</p><p><br /></p><p>date +&quot;%Z %z&quot;<br />\n结果发现还是一致呀，都是CST +0800</p><p><br /></p><p>2. 不对，时区一样呀，那么问题就是java执行不一样？ 核对了jdk版本，发现一致</p><p><br /></p><p>3. 那么就在两台机器上执行java代码试下：</p><p><br /></p><p>System.out.println(TimeZone.getDefault()); //输出当前默认时区</p><p><br /></p><p>发现了问题了，两台机器打印的不一致，A是上海，而B是纽约。。。</p><p><br /></p><p>4. 那么问题变成了jvm从哪里去获取时区的呢？经过查询大致如下：</p><p><br /></p><blockquote><p>1)如有环境变量 TZ设置，则用TZ中设置的时区</p>\n<ol start=\"2\"><li>在 /etc/sysconfig/clock文件中找 &quot;ZONE&quot;的值</li></ol>\n<p>3）如2)都没，就用/etc/localtime 和 /usr/share/zoneinfo 下的时区文件进行匹配，如找到匹配的，就返回对应的路径和文件名。</p></blockquote><p><br /></p><p>简单来说就是:</p><p><br /></p><p>TZ环境变量 --&gt; /etc/sysconfig/clock文件  --&gt; /etc/localtime文件 依次寻找</p><p><br /></p><p>5. 于是开始设置了，TZ不管了，加了/etc/sysconfig/clock，如下操作：</p><p><br /></p><p>新建一个/etc/sysconfig/clock，内容如下：</p><p><br /></p><p>ZONE=&quot;Asia/Shanghai&quot; UTC=false ARC=false</p><p><br /></p><p>然后继续去查看时区，还是不对呀！！</p><p><br /></p><p>6. 继续设置/etc/localtime文件，如下操作：</p><p><br /></p><p>unlink /etc/localtime<br />\nln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p><p><br /></p><p>就是初始化/etc/localtime ，然后将东八区的绑定上</p><p><br /></p><p>7. 在查看时区成功了，重新执行java代码，发现正常了</p><p><br /></p><p>8. 继续翻阅资料，发现：</p><p><br /></p><blockquote><p>时区的配置文件是/etc/sysconfig/clock。用tzselect命令就可以修改这个配置文件，根据命令的提示进行修改就好了。</p>\n<p>但是在实际工作中，发现这种方式是不能够使得服务器上的时间设置马上生效的，而且使用ntpdate去同步时间服务器也不能够更改时间。即使你使用了 date命令手工设置了时间的话，如果使用ntpdate去进行时间同步的话，时间又会被改动到原来的错误时区的时间。而生产的机器往往是非常重要的，不能够进行重启等操作。</p>\n<p>1）/etc/sysconfig/clock 文件，只对 hwclock <br />\n命令有效，且只在系统启动和关闭的时候才有用（修改了其中的 UTC=true 到 UTC=false 的前后，执行 hwclock (--utc,<br />\n或 --localtime) 都没有变化，要重启系统后才生效）；<br />\n在 /etc/sysconfig/clock 中 UTC=false 时，date、hwclock、hwclcok --localtime 输出的时间应该都一致，且此时 hwclock --utc是没有意义的；</p>\n<p>在 /etc/sysconfig/clock 中 UTC=ture 时，date、hwclock 的输出是一致的，hwclock --localtime 的输出则是UTC时间；<br />\n系统关闭时会同步系统时间到硬件时钟，系统启动时会从硬件时钟读取时间更新到系统，这2个步骤都要根据 /etc/sysconfig/clock 文件中UTC的参数来设置时区转换。</p></blockquote><p><br /></p><p>意思就是修改/etc/sysconfi/clock是可行的，但是不会立即生效，需要重启。那么一切就说的通了</p><p><br /></p><a name=\"#-后记\"></a><h1 id=\"ec030200\"># 后记</h1><p><br /></p><p>参考资料：</p><p><br /></p><p><a href=\"https://www.nowcoder.com/questionTerminal/1e794493ad564324a16da1c47545c117\" target=\"_blank\">https://www.nowcoder.com/questionTerminal/1e794493ad564324a16da1c47545c117</a></p><p><br /></p><p><a href=\"http://blog.51cto.com/5iwww/661863\" target=\"_blank\">http://blog.51cto.com/5iwww/661863</a></p><p><br /></p><p><a href=\"https://my.oschina.net/huawu/blog/4646\" target=\"_blank\">https://my.oschina.net/huawu/blog/4646</a></p><p><br /></p><p><a href=\"http://linux.it.net.cn/CentOS/fast/2016/0511/21660.html\" target=\"_blank\">http://linux.it.net.cn/CentOS/fast/2016/0511/21660.html</a></p><p><br /></p><p><a href=\"https://blog.csdn.net/splenday/article/details/47065557\" target=\"_blank\">https://blog.csdn.net/splenday/article/details/47065557</a></p><p><br /></p><p><a href=\"https://unix.stackexchange.com/questions/110522/timezone-setting-in-linux\" target=\"_blank\">https://unix.stackexchange.com/questions/110522/timezone-setting-in-linux</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T11:55:43.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T11:55:43.000Z",
    "updated_at": "2019-04-17T11:55:43.000Z",
    "published_at": "2019-04-17T11:55:43.000Z",
    "first_published_at": null,
    "word_count": 1040,
    "cover": null,
    "description": "# 背景 在接入集团一个平台的时候，发现录制某个接口到测试环境回放，发现接口入参一致，一个start_day 一个end_day，但回放的时候会多调用一次数据库查询，很是奇怪； 查阅业务代码，发现确实有逻辑会导致多查询一次，于是重点观察数据变化，发现录制回放两个时间不一致，相差12个小时； 继...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553081,
    "slug": "f35b5be0-15b0-4273-b377-8915607aaea5",
    "title": "maven仓库地址配置",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"42550742\"></a>\n# # 背景\n\nmaven中央存库在国外，访问缓慢，一般国内镜像，这里推荐阿里云的 [http://maven.aliyun.com/nexus/content/groups/public](http://maven.aliyun.com/nexus/content/groups/public)\n\n我之前采用的方式是修改setting.xml文件，后续跟研发了解下，实际使用的时候不会修改这个玩意，团队协作因为你不能强制别人去修改本地setting.xml的\n\n而是在pom.xml中设置仓库地址就可以的\n\n<a name=\"80ed3385\"></a>\n# # 具体\n\npom.xml中project节点新增如下：\n\n```xml\n<repositories>\n        <!-- 远程仓库地址 -->\n        <repository>\n            <id>nexus-aliyun</id>  \n     　　　　<name>Nexus aliyun</name>  \n    　　　　 <url>http://maven.aliyun.com/nexus/content/groups/public</url>  \n        </repository>\n\n</repositories>\n```\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"42550742\"># 背景</h1><p><br /></p><p>maven中央存库在国外，访问缓慢，一般国内镜像，这里推荐阿里云的 <a href=\"http://maven.aliyun.com/nexus/content/groups/public\" target=\"_blank\">http://maven.aliyun.com/nexus/content/groups/public</a></p><p><br /></p><p>我之前采用的方式是修改setting.xml文件，后续跟研发了解下，实际使用的时候不会修改这个玩意，团队协作因为你不能强制别人去修改本地setting.xml的</p><p><br /></p><p>而是在pom.xml中设置仓库地址就可以的</p><p><br /></p><h1 id=\"80ed3385\"># 具体</h1><p><br /></p><p>pom.xml中project节点新增如下：</p><p><br /></p><pre data-lang=\"xml\"><code>&lt;repositories&gt;\n        &lt;!-- 远程仓库地址 --&gt;\n        &lt;repository&gt;\n            &lt;id&gt;nexus-aliyun&lt;/id&gt;  \n     　　　　&lt;name&gt;Nexus aliyun&lt;/name&gt;  \n    　　　　 &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;  \n        &lt;/repository&gt;\n\n&lt;/repositories&gt;</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>maven中央存库在国外，访问缓慢，一般国内镜像，这里推荐阿里云的 <a href=\"http://maven.aliyun.com/nexus/content/groups/public\" target=\"_blank\">http://maven.aliyun.com/nexus/content/groups/public</a></p><p><br /></p><p>我之前采用的方式是修改setting.xml文件，后续跟研发了解下，实际使用的时候不会修改这个玩意，团队协作因为你不能强制别人去修改本地setting.xml的</p><p><br /></p><p>而是在pom.xml中设置仓库地址就可以的</p><p><br /></p><h1 id=\"80ed3385\"># 具体<cursor /></h1><p><br /></p><p>pom.xml中project节点新增如下：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22xml%22%2C%22code%22%3A%22%3Crepositories%3E%5Cn%20%20%20%20%20%20%20%20%3C!--%20%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%20--%3E%5Cn%20%20%20%20%20%20%20%20%3Crepository%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Cid%3Enexus-aliyun%3C%2Fid%3E%20%20%5Cn%20%20%20%20%20%E3%80%80%E3%80%80%E3%80%80%E3%80%80%3Cname%3ENexus%20aliyun%3C%2Fname%3E%20%20%5Cn%20%20%20%20%E3%80%80%E3%80%80%E3%80%80%E3%80%80%20%3Curl%3Ehttp%3A%2F%2Fmaven.aliyun.com%2Fnexus%2Fcontent%2Fgroups%2Fpublic%3C%2Furl%3E%20%20%5Cn%20%20%20%20%20%20%20%20%3C%2Frepository%3E%5Cn%5Cn%3C%2Frepositories%3E%22%2C%22id%22%3A%22H965l%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T12:04:36.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T11:55:11.000Z",
    "updated_at": "2019-04-17T12:04:36.000Z",
    "published_at": "2019-04-17T12:04:36.000Z",
    "first_published_at": null,
    "word_count": 173,
    "cover": null,
    "description": "# 背景maven中央存库在国外，访问缓慢，一般国内镜像，这里推荐阿里云的 http://maven.aliyun.com/nexus/content/groups/public我之前采用的方式是修改setting.xml文件，后续跟研发了解下，实际使用的时候不会修改这个玩意，团队协作因为你不...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553076,
    "slug": "4d52fdea-5757-4580-93ae-13ba629283f7",
    "title": "java序列化",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"42550742\"></a>\n# # 背景\n\njava对象是在jvm中，如果jvm销毁，那么对象都不存在了。如果想继续使用java对象的话，需要用到序列化，将java中的对象转化为字节序列，用于存储和运输；\n\n那么可以将DB理解为一种序列化，将java对象序列化后存储在DB中，将java对象保存在文本中也是一种序列化\n\n<a name=\"10ea5bac\"></a>\n# # 细节\n\n**需要被序列化的类，需要实现Serializable接口**\n\n虽然Serializable接口是空的，没有任何方法，但也要实现，起到标识的作用\n\n**同一字节流中的引用是得到保存的**\n\nUser user =  new User(\"jwen\");\n\nOrder o1 =  new Order(user, \"o1\");\n\nOrder o2 =  new Order(user, \"o2\");\n\n将这两个对象o1和o2序列化保存在同一文本中（同一输出流），会发现两个对象的o1.user == o2.user\n\n但将两个对象分别保存在不同文件中，file1和file2的话，引用是不一样的 o1.user != o2.user\n\n**反序列化没有调用构造函数**\n\n```java\npublic class User implements Serializable {\n\n    private String name;\n    private int id = 1;\n\n    public User(String name, int id) {\n        System.out.println(\"构造函数调用\");\n        this.name = name;\n\n    }\n}\n```\n\n\n这里的构造方法不会被调用\n\n**序列化Id标识版本信息**\n\nprivate static final long serialVersionUID = -5809782578272943999L;\n\n<a name=\"ec030200\"></a>\n# # 后记\n\n推荐博客：[https://www.cnblogs.com/xdp-gacl/p/3777987.html](https://www.cnblogs.com/xdp-gacl/p/3777987.html)\n",
    "body_draft": "",
    "body_html": "<h1 id=\"42550742\"># 背景</h1><p><br /></p><p>java对象是在jvm中，如果jvm销毁，那么对象都不存在了。如果想继续使用java对象的话，需要用到序列化，将java中的对象转化为字节序列，用于存储和运输；</p><p><br /></p><p>那么可以将DB理解为一种序列化，将java对象序列化后存储在DB中，将java对象保存在文本中也是一种序列化</p><p><br /></p><h1 id=\"10ea5bac\"># 细节</h1><p><br /></p><p><strong>需要被序列化的类，需要实现Serializable接口</strong></p><p><br /></p><p>虽然Serializable接口是空的，没有任何方法，但也要实现，起到标识的作用</p><p><br /></p><p><strong>同一字节流中的引用是得到保存的</strong></p><p><br /></p><p>User user =  new User(&quot;jwen&quot;);</p><p><br /></p><p>Order o1 =  new Order(user, &quot;o1&quot;);</p><p><br /></p><p>Order o2 =  new Order(user, &quot;o2&quot;);</p><p><br /></p><p>将这两个对象o1和o2序列化保存在同一文本中（同一输出流），会发现两个对象的o1.user == o2.user</p><p><br /></p><p>但将两个对象分别保存在不同文件中，file1和file2的话，引用是不一样的 o1.user != o2.user</p><p><br /></p><p><strong>反序列化没有调用构造函数</strong></p><p><br /></p><pre data-lang=\"java\"><code>public class User implements Serializable {\n\n    private String name;\n    private int id = 1;\n\n    public User(String name, int id) {\n        System.out.println(&quot;构造函数调用&quot;);\n        this.name = name;\n\n    }\n}</code></pre><p><br /></p><p><br /></p><p>这里的构造方法不会被调用</p><p><br /></p><p><strong>序列化Id标识版本信息</strong></p><p><br /></p><p>private static final long serialVersionUID = -5809782578272943999L;</p><p><br /></p><h1 id=\"ec030200\"># 后记</h1><p><br /></p><p>推荐博客：<a href=\"https://www.cnblogs.com/xdp-gacl/p/3777987.html\" target=\"_blank\">https://www.cnblogs.com/xdp-gacl/p/3777987.html</a></p>",
    "body_lake": "<!doctype lake><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>java对象是在jvm中，如果jvm销毁，那么对象都不存在了。如果想继续使用java对象的话，需要用到序列化，将java中的对象转化为字节序列，用于存储和运输；</p><p><br /></p><p>那么可以将DB理解为一种序列化，将java对象序列化后存储在DB中，将java对象保存在文本中也是一种序列化</p><p><br /></p><h1 id=\"10ea5bac\"># 细节</h1><p><br /></p><p><strong>需要被序列化的类，需要实现Serializable接口</strong></p><p><br /></p><p>虽然Serializable接口是空的，没有任何方法，但也要实现，起到标识的作用</p><p><br /></p><p><strong>同一字节流中的引用是得到保存的</strong></p><p><br /></p><p>User user =  new User(&quot;jwen&quot;);</p><p><br /></p><p>Order o1 =  new Order(user, &quot;o1&quot;);</p><p><br /></p><p>Order o2 =  new Order(user, &quot;o2&quot;);</p><p><br /></p><p>将这两个对象o1和o2序列化保存在同一文本中（同一输出流），会发现两个对象的o1.user == o2.user</p><p><br /></p><p>但将两个对象分别保存在不同文件中，file1和file2的话，引用是不一样的 o1.user != o2.user</p><p><br /></p><p><strong>反序列化没有调用构造函数<cursor /></strong></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22public%20class%20User%20implements%20Serializable%20%7B%5Cn%5Cn%20%20%20%20private%20String%20name%3B%5Cn%20%20%20%20private%20int%20id%20%3D%201%3B%5Cn%5Cn%20%20%20%20public%20User(String%20name%2C%20int%20id)%20%7B%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20this.name%20%3D%20name%3B%5Cn%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22id%22%3A%2233869b20%22%7D\"></card><p><br /></p><p><br /></p><p>这里的构造方法不会被调用</p><p><br /></p><p><strong>序列化Id标识版本信息</strong></p><p><br /></p><p>private static final long serialVersionUID = -5809782578272943999L;</p><p><br /></p><h1 id=\"ec030200\"># 后记</h1><p><br /></p><p>推荐博客：<a href=\"https://www.cnblogs.com/xdp-gacl/p/3777987.html\" target=\"_blank\">https://www.cnblogs.com/xdp-gacl/p/3777987.html</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T12:05:30.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T11:54:23.000Z",
    "updated_at": "2019-04-17T12:05:30.000Z",
    "published_at": "2019-04-17T12:05:30.000Z",
    "first_published_at": null,
    "word_count": 351,
    "cover": null,
    "description": "# 背景java对象是在jvm中，如果jvm销毁，那么对象都不存在了。如果想继续使用java对象的话，需要用到序列化，将java中的对象转化为字节序列，用于存储和运输；那么可以将DB理解为一种序列化，将java对象序列化后存储在DB中，将java对象保存在文本中也是一种序列化# 细节需要被序列...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1553069,
    "slug": "5dc8ae06-0c24-4641-920f-16a13fa750fa",
    "title": "python - http请求带Authorization",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"42550742\"></a>\n# # 背景\n\n接入公司的一个数据统计平台，该平台的接口是带上了Authorization验证方式来保证验签计算安全\n\n<a name=\"466f7b97\"></a>\n# # 方法\n\n其实很简单，就是在header中加入key=Authorization，value是协商好的协议即可；\n\n如，我们这边是base64.b64encode(uae_name + \":\" + uae_passwd);\n\n因此计算就是：\n\n```python\n# 计算uae的authorization\ndef get_authorization():\n    return base64.b64encode(uae_name + \":\" + uae_passwd);\n\nheaders = {\n            'Authorization': 'Basic {}'.format(get_authorization()),\n            'ua': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.125 Safari/537.36'\n        }\n\nresp = requests.get(url, headers=headers)\nget_result(json.loads(resp.content))\nprint \"\"\n```\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"42550742\"># 背景</h1><p><br /></p><p>接入公司的一个数据统计平台，该平台的接口是带上了Authorization验证方式来保证验签计算安全</p><p><br /></p><h1 id=\"466f7b97\"># 方法</h1><p><br /></p><p>其实很简单，就是在header中加入key=Authorization，value是协商好的协议即可；</p><p><br /></p><p>如，我们这边是base64.b64encode(uae_name + &quot;:&quot; + uae_passwd);</p><p><br /></p><p>因此计算就是：</p><p><br /></p><pre data-lang=\"python\"><code># 计算uae的authorization\ndef get_authorization():\n    return base64.b64encode(uae_name + &quot;:&quot; + uae_passwd);\n\nheaders = {\n            'Authorization': 'Basic {}'.format(get_authorization()),\n            'ua': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.125 Safari/537.36'\n        }\n\nresp = requests.get(url, headers=headers)\nget_result(json.loads(resp.content))\nprint &quot;&quot;</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"42550742\"># 背景</h1><p><br /></p><p>接入公司的一个数据统计平台，该平台的接口是带上了Authorization验证方式来保证验签计算安全</p><p><br /></p><h1 id=\"466f7b97\"># 方法</h1><p><br /></p><p>其实很简单，就是在header中加入key=Authorization，value是协商好的协议即可；</p><p><br /></p><p>如，我们这边是base64.b64encode(uae_name + &quot;:&quot; + uae_passwd);</p><p><br /></p><p>因此计算就是：</p><p><cursor /><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22%23%20%E8%AE%A1%E7%AE%97uae%E7%9A%84authorization%5Cndef%20get_authorization()%3A%5Cn%20%20%20%20return%20base64.b64encode(uae_name%20%2B%20%5C%22%3A%5C%22%20%2B%20uae_passwd)%3B%5Cn%5Cnheaders%20%3D%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20'Authorization'%3A%20'Basic%20%7B%7D'.format(get_authorization())%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20'ua'%3A%20'Mozilla%2F5.0%20(Windows%20NT%206.1%3B%20WOW64)%20AppleWebKit%2F537.36%20(KHTML%2C%20like%20Gecko)%20Chrome%2F44.0.2403.125%20Safari%2F537.36'%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cnresp%20%3D%20requests.get(url%2C%20headers%3Dheaders)%5Cnget_result(json.loads(resp.content))%5Cnprint%20%5C%22%5C%22%22%2C%22id%22%3A%22131e696f%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-17T11:53:44.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T11:53:19.000Z",
    "updated_at": "2019-04-17T11:53:44.000Z",
    "published_at": "2019-04-17T11:53:44.000Z",
    "first_published_at": null,
    "word_count": 150,
    "cover": null,
    "description": "# 背景接入公司的一个数据统计平台，该平台的接口是带上了Authorization验证方式来保证验签计算安全# 方法其实很简单，就是在header中加入key=Authorization，value是协商好的协议即可；如，我们这边是base64.b64encode(uae_name + &qu...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547451,
    "slug": "9329bd9c-4af0-459c-b7ea-b473dca84279",
    "title": "初始化git项目",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-17T12:10:57.774Z",
      "updated_at": "2019-07-17T12:10:57.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"66879f44\"></a>\n### Command line instructions\n\n<a name=\"d8418652\"></a>\n##### Git global setup\n\ngit config --global user.name \"你的名字\"<br />\ngit config --global user.email \"你的邮箱\"\n\n<a name=\"ebc6fc20\"></a>\n##### Create a new repository\n\ngit clone ${git地址} cd demo<br />\ntouch README.md<br />\ngit add README.md<br />\ngit commit -m \"add README\"<br />\ngit push -u origin master\n\n<a name=\"97618b45\"></a>\n##### Existing folder or Git repository\n\ncd existing_folder<br />\ngit init<br />\ngit remote add origin ${git地址} git add .<br />\ngit commit<br />\ngit push -u origin master\n\n",
    "body_draft": "",
    "body_html": "<h3 id=\"66879f44\">Command line instructions</h3><p><br /></p><h5 id=\"d8418652\">Git global setup</h5><p><br /></p><p>git config --global user.name &quot;你的名字&quot;<br />\ngit config --global user.email &quot;你的邮箱&quot;</p><p><br /></p><h5 id=\"ebc6fc20\">Create a new repository</h5><p><br /></p><p>git clone ${git地址} cd demo<br />\ntouch README.md<br />\ngit add README.md<br />\ngit commit -m &quot;add README&quot;<br />\ngit push -u origin master</p><p><br /></p><h5 id=\"97618b45\">Existing folder or Git repository</h5><p><br /></p><p>cd existing_folder<br />\ngit init<br />\ngit remote add origin ${git地址} git add .<br />\ngit commit<br />\ngit push -u origin master</p><p><br /></p>",
    "body_lake": "<!doctype lake><h3 id=\"66879f44\">Command line instructions</h3><p><br /></p><h5 id=\"d8418652\">Git global setup</h5><p><br /></p><p>git config --global user.name &quot;你的名字&quot;<br />\ngit config --global user.email &quot;你的邮箱&quot;</p><p><br /></p><h5 id=\"ebc6fc20\">Create a new repository</h5><p><br /></p><p>git clone ${git地址} cd demo<br />\ntouch README.md<br />\ngit add README.md<br />\ngit commit -m &quot;add README&quot;<br />\ngit push -u origin master</p><p><br /></p><h5 id=\"97618b45\">Existing folder or Git repository</h5><p><br /></p><p>cd existing_folder<br />\ngit init<br />\ngit remote add origin ${git地址} git add .<br />\ngit commit<br />\ngit push -u origin master</p><p><br /><cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T12:24:50.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T12:24:28.000Z",
    "updated_at": "2019-07-17T12:10:57.000Z",
    "published_at": "2019-07-17T12:10:57.000Z",
    "first_published_at": null,
    "word_count": 86,
    "cover": null,
    "description": "Command line instructionsGit global setupgit config --global user.name &quot;你的名字&quot; git config --global user.email &quot;你的邮箱&quot;Create a new...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547434,
    "slug": "91a4dfc0-af80-43f0-a1b9-6c2ad33b104e",
    "title": "spring boot 使用 HandlerInterceptor",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8e1b944f\"></a>\n# 背景\n\n在实际项目中，接口出于安全考虑，都会有验签的计算。目前接触的项目来看基本都是时间戳+干扰因子 然后md5计算的方式。现在学习，写一个简单demo，\n\n其实如果不引入拦截器的话，验签计算全部在controller层实现也是可以的，但每个请求都需要去做一次计算，这种把公共功能的抽离，针对于所有请求前的判断，个人感觉有点切面的意思；\n\n<a name=\"2a0459f9\"></a>\n# # DEMO\n\n<a name=\"8c6ab814\"></a>\n## 核心点：\n1. controller层还是和原来的一模一样，不做修改\n\n2. 创建一个ApiSignInterceptor 类 ，实现HandlerInterceptor 接口，完成 验签计算的核心代码；\n\n3. 创建一个WebConfig类，继承WebMvcConfigurationSupport类，引入步骤2中创建的拦截器；\n\n<a name=\"141f3596\"></a>\n## 前言：\njdk8+spring boot2.0 版本 如果低版本些许不一致\n<a name=\"3600dd9d\"></a>\n## show CODE\n\ncontroller层：\n```java\n@RestController\npublic class PeopleController {\n\n    @GetMapping(value = \"/1/people/{people_id}\")\n    public String getPeopleInfo(@PathVariable(value = \"people_id\", required = true) String peopleId) {\n        return \"hello world, this is people info of \" + peopleId;\n    }\n\n\n    @GetMapping(value = \"/2/people/{people_id}\")\n    public String getPeopleInfoV2(@PathVariable(value = \"people_id\", required = true) String peopleId) {\n        return \"hello THIS is v2 world, this is people info V2 of \" + peopleId;\n    }\n}\n```\n\n}\n\n没有任何变化，简单demo例子\n\n拦截器，ApiSignInterceptor ：\n\n```java\npublic class ApiSignInterceptor implements HandlerInterceptor {\n\n\n    private final static String SEPERATOR = \"_\";\n    private final static String SECRET = \"jwentest\";\n    private final static String NO_PERMISSION_ERROR_MESSAGE = \"Api Token Error, You have no permission to access this api\";\n\n\n    // md5计算\n    private String md5Hex(String data) {\n        return DigestUtils.md5Hex(data).toLowerCase();\n    }\n\n    private String getSign(String t) {\n        return md5Hex(t + SEPERATOR + SECRET);\n    }\n\n    // sign计算，t为时间戳,sign为md5(t+\"_\"+\"jwentest\")\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        try {\n            String t = request.getParameter(\"t\");\n            String sign = request.getParameter(\"sign\");\n\n            if (t.isEmpty() || sign.isEmpty()) {\n                response.sendError(403, NO_PERMISSION_ERROR_MESSAGE);\n                return false;\n            }\n\n            String expectedSign = getSign(t);\n\n            if (!expectedSign.equals(sign)) {\n                response.sendError(403, NO_PERMISSION_ERROR_MESSAGE);\n                return false;\n            }\n\n        } catch (Throwable t) {\n            response.sendError(403, NO_PERMISSION_ERROR_MESSAGE);\n            return false;\n        }\n\n        return true;\n\n    }\n\n}\n```\n\n\n其中HandlerInterceptor 接口定义了三个方法，第一次看到我有点懵逼了，为啥接口定义的方法里面会有方法体呢，为什么可以不实现所有的方法了的，原因是JDK8中可以这样写了：\n\n```java\ndefault boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        return true;\n    }\n\n    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n    }\n\n    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n    }\n```\n\n本次我们使用到的是preHandle方法，三个方法的执行顺序如下：\n\npreHandler -> Controller -> postHandler -> model渲染-> afterCompletion\n\n因此可以在进入controller层之前拦截判断是否符合我们的安全要求；\n\n使用，WebConfig 类：\n\n\n```java\n@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new ApiSignInterceptor()).addPathPatterns(\"/1/people/**\").excludePathPatterns(\"/2/people/**\");\n        super.addInterceptors(registry);\n    }\n}\n```\n\n\n这里是在项目引入拦截器，\n\n@Configuration，config形式加载在容器中<br />其中addPathPatterns 和 excludePathPatterns 方法，从方法名就可以看出来，是针对拦截器的范围控制，上面的代码就是针对/1/people/** 生效，对/2/people/**  不生效\n\n目录结构如下：\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555417189381-e54a2bdc-aed9-45ff-85f2-6f969952e010.png#align=left&display=inline&height=231&originHeight=231&originWidth=261&status=done&width=261)\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>在实际项目中，接口出于安全考虑，都会有验签的计算。目前接触的项目来看基本都是时间戳+干扰因子 然后md5计算的方式。现在学习，写一个简单demo，</p><p><br /></p><p>其实如果不引入拦截器的话，验签计算全部在controller层实现也是可以的，但每个请求都需要去做一次计算，这种把公共功能的抽离，针对于所有请求前的判断，个人感觉有点切面的意思；</p><p><br /></p><h1 id=\"2a0459f9\"># DEMO</h1><p><br /></p><h2 id=\"8c6ab814\">核心点：</h2><p>1. controller层还是和原来的一模一样，不做修改</p><p><br /></p><p>2. 创建一个ApiSignInterceptor 类 ，实现HandlerInterceptor 接口，完成 验签计算的核心代码；</p><p><br /></p><p>3. 创建一个WebConfig类，继承WebMvcConfigurationSupport类，引入步骤2中创建的拦截器；</p><p><br /></p><h2 id=\"141f3596\">前言：</h2><p>jdk8+spring boot2.0 版本 如果低版本些许不一致</p><h2 id=\"3600dd9d\">show CODE</h2><p><br /></p><p>controller层：</p><pre data-lang=\"java\"><code>@RestController\npublic class PeopleController {\n\n    @GetMapping(value = &quot;/1/people/{people_id}&quot;)\n    public String getPeopleInfo(@PathVariable(value = &quot;people_id&quot;, required = true) String peopleId) {\n        return &quot;hello world, this is people info of &quot; + peopleId;\n    }\n\n\n    @GetMapping(value = &quot;/2/people/{people_id}&quot;)\n    public String getPeopleInfoV2(@PathVariable(value = &quot;people_id&quot;, required = true) String peopleId) {\n        return &quot;hello THIS is v2 world, this is people info V2 of &quot; + peopleId;\n    }\n}</code></pre><p><br /></p><p>}</p><p><br /></p><p>没有任何变化，简单demo例子</p><p><br /></p><p>拦截器，ApiSignInterceptor ：</p><p><br /></p><pre data-lang=\"java\"><code>public class ApiSignInterceptor implements HandlerInterceptor {\n\n\n    private final static String SEPERATOR = &quot;_&quot;;\n    private final static String SECRET = &quot;jwentest&quot;;\n    private final static String NO_PERMISSION_ERROR_MESSAGE = &quot;Api Token Error, You have no permission to access this api&quot;;\n\n\n    // md5计算\n    private String md5Hex(String data) {\n        return DigestUtils.md5Hex(data).toLowerCase();\n    }\n\n    private String getSign(String t) {\n        return md5Hex(t + SEPERATOR + SECRET);\n    }\n\n    // sign计算，t为时间戳,sign为md5(t+&quot;_&quot;+&quot;jwentest&quot;)\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        try {\n            String t = request.getParameter(&quot;t&quot;);\n            String sign = request.getParameter(&quot;sign&quot;);\n\n            if (t.isEmpty() || sign.isEmpty()) {\n                response.sendError(403, NO_PERMISSION_ERROR_MESSAGE);\n                return false;\n            }\n\n            String expectedSign = getSign(t);\n\n            if (!expectedSign.equals(sign)) {\n                response.sendError(403, NO_PERMISSION_ERROR_MESSAGE);\n                return false;\n            }\n\n        } catch (Throwable t) {\n            response.sendError(403, NO_PERMISSION_ERROR_MESSAGE);\n            return false;\n        }\n\n        return true;\n\n    }\n\n}</code></pre><p><br /></p><p><br /></p><p>其中HandlerInterceptor 接口定义了三个方法，第一次看到我有点懵逼了，为啥接口定义的方法里面会有方法体呢，为什么可以不实现所有的方法了的，原因是JDK8中可以这样写了：</p><p><br /></p><pre data-lang=\"java\"><code>default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        return true;\n    }\n\n    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n    }\n\n    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n    }</code></pre><p><br /></p><p>本次我们使用到的是preHandle方法，三个方法的执行顺序如下：</p><p><br /></p><p>preHandler -&gt; Controller -&gt; postHandler -&gt; model渲染-&gt; afterCompletion</p><p><br /></p><p>因此可以在进入controller层之前拦截判断是否符合我们的安全要求；</p><p><br /></p><p>使用，WebConfig 类：</p><p><br /></p><p><br /></p><pre data-lang=\"java\"><code>@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new ApiSignInterceptor()).addPathPatterns(&quot;/1/people/**&quot;).excludePathPatterns(&quot;/2/people/**&quot;);\n        super.addInterceptors(registry);\n    }\n}</code></pre><p><br /></p><p><br /></p><p>这里是在项目引入拦截器，</p><p><br /></p><p>@Configuration，config形式加载在容器中</p><p>其中addPathPatterns 和 excludePathPatterns 方法，从方法名就可以看出来，是针对拦截器的范围控制，上面的代码就是针对/1/people/** 生效，对/2/people/**  不生效</p><p><br /></p><p>目录结构如下：</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555417189381-e54a2bdc-aed9-45ff-85f2-6f969952e010.png#align=left&amp;display=inline&amp;height=231&amp;originHeight=231&amp;originWidth=261&amp;status=done&amp;width=261\" style=\"max-width: 600px; width: 261px;\" /></p>",
    "body_lake": "<!doctype lake><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>在实际项目中，接口出于安全考虑，都会有验签的计算。目前接触的项目来看基本都是时间戳+干扰因子 然后md5计算的方式。现在学习，写一个简单demo，</p><p><br /></p><p>其实如果不引入拦截器的话，验签计算全部在controller层实现也是可以的，但每个请求都需要去做一次计算，这种把公共功能的抽离，针对于所有请求前的判断，个人感觉有点切面的意思；</p><p><br /></p><h1 id=\"2a0459f9\"># DEMO</h1><p><br /></p><h2 id=\"8c6ab814\">核心点：</h2><p>1. controller层还是和原来的一模一样，不做修改</p><p><br /></p><p>2. 创建一个ApiSignInterceptor 类 ，实现HandlerInterceptor 接口，完成 验签计算的核心代码；</p><p><br /></p><p>3. 创建一个WebConfig类，继承WebMvcConfigurationSupport类，引入步骤2中创建的拦截器；</p><p><br /></p><h2 id=\"141f3596\">前言：</h2><p>jdk8+spring boot2.0 版本 如果低版本些许不一致</p><h2 id=\"3600dd9d\">show CODE</h2><p><br /></p><p>controller层：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22%40RestController%5Cnpublic%20class%20PeopleController%20%7B%5Cn%5Cn%20%20%20%20%40GetMapping(value%20%3D%20%5C%22%2F1%2Fpeople%2F%7Bpeople_id%7D%5C%22)%5Cn%20%20%20%20public%20String%20getPeopleInfo(%40PathVariable(value%20%3D%20%5C%22people_id%5C%22%2C%20required%20%3D%20true)%20String%20peopleId)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20%5C%22hello%20world%2C%20this%20is%20people%20info%20of%20%5C%22%20%2B%20peopleId%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%5Cn%20%20%20%20%40GetMapping(value%20%3D%20%5C%22%2F2%2Fpeople%2F%7Bpeople_id%7D%5C%22)%5Cn%20%20%20%20public%20String%20getPeopleInfoV2(%40PathVariable(value%20%3D%20%5C%22people_id%5C%22%2C%20required%20%3D%20true)%20String%20peopleId)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20%5C%22hello%20THIS%20is%20v2%20world%2C%20this%20is%20people%20info%20V2%20of%20%5C%22%20%2B%20peopleId%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22id%22%3A%22900868f2%22%7D\"></card><p><br /></p><p>}</p><p><br /></p><p>没有任何变化，简单demo例子</p><p><br /></p><p>拦截器，ApiSignInterceptor ：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22public%20class%20ApiSignInterceptor%20implements%20HandlerInterceptor%20%7B%5Cn%5Cn%5Cn%20%20%20%20private%20final%20static%20String%20SEPERATOR%20%3D%20%5C%22_%5C%22%3B%5Cn%20%20%20%20private%20final%20static%20String%20SECRET%20%3D%20%5C%22jwentest%5C%22%3B%5Cn%20%20%20%20private%20final%20static%20String%20NO_PERMISSION_ERROR_MESSAGE%20%3D%20%5C%22Api%20Token%20Error%2C%20You%20have%20no%20permission%20to%20access%20this%20api%5C%22%3B%5Cn%5Cn%5Cn%20%20%20%20%2F%2F%20md5%E8%AE%A1%E7%AE%97%5Cn%20%20%20%20private%20String%20md5Hex(String%20data)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20DigestUtils.md5Hex(data).toLowerCase()%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20private%20String%20getSign(String%20t)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20md5Hex(t%20%2B%20SEPERATOR%20%2B%20SECRET)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%20sign%E8%AE%A1%E7%AE%97%EF%BC%8Ct%E4%B8%BA%E6%97%B6%E9%97%B4%E6%88%B3%2Csign%E4%B8%BAmd5(t%2B%5C%22_%5C%22%2B%5C%22jwentest%5C%22)%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20boolean%20preHandle(HttpServletRequest%20request%2C%20HttpServletResponse%20response%2C%20Object%20handler)%20throws%20Exception%20%7B%5Cn%5Cn%20%20%20%20%20%20%20%20try%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20String%20t%20%3D%20request.getParameter(%5C%22t%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20String%20sign%20%3D%20request.getParameter(%5C%22sign%5C%22)%3B%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(t.isEmpty()%20%7C%7C%20sign.isEmpty())%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20response.sendError(403%2C%20NO_PERMISSION_ERROR_MESSAGE)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20String%20expectedSign%20%3D%20getSign(t)%3B%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(!expectedSign.equals(sign))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20response.sendError(403%2C%20NO_PERMISSION_ERROR_MESSAGE)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%7D%20catch%20(Throwable%20t)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20response.sendError(403%2C%20NO_PERMISSION_ERROR_MESSAGE)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20return%20true%3B%5Cn%5Cn%20%20%20%20%7D%5Cn%5Cn%7D%22%2C%22id%22%3A%22BCikR%22%7D\"></card><p><br /></p><p><br /></p><p>其中HandlerInterceptor 接口定义了三个方法，第一次看到我有点懵逼了，为啥接口定义的方法里面会有方法体呢，为什么可以不实现所有的方法了的，原因是JDK8中可以这样写了：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22default%20boolean%20preHandle(HttpServletRequest%20request%2C%20HttpServletResponse%20response%2C%20Object%20handler)%20throws%20Exception%20%7B%5Cn%20%20%20%20%20%20%20%20return%20true%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20default%20void%20postHandle(HttpServletRequest%20request%2C%20HttpServletResponse%20response%2C%20Object%20handler%2C%20%40Nullable%20ModelAndView%20modelAndView)%20throws%20Exception%20%7B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20default%20void%20afterCompletion(HttpServletRequest%20request%2C%20HttpServletResponse%20response%2C%20Object%20handler%2C%20%40Nullable%20Exception%20ex)%20throws%20Exception%20%7B%5Cn%20%20%20%20%7D%22%2C%22id%22%3A%227bK1Y%22%7D\"></card><p><br /></p><p>本次我们使用到的是preHandle方法，三个方法的执行顺序如下：</p><p><br /></p><p>preHandler -&gt; Controller -&gt; postHandler -&gt; model渲染-&gt; afterCompletion</p><p><br /></p><p>因此可以在进入controller层之前拦截判断是否符合我们的安全要求；</p><p><br /></p><p>使用，WebConfig 类：</p><p><br /></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22%40Configuration%5Cnpublic%20class%20WebConfig%20extends%20WebMvcConfigurationSupport%20%7B%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20protected%20void%20addInterceptors(InterceptorRegistry%20registry)%20%7B%5Cn%20%20%20%20%20%20%20%20registry.addInterceptor(new%20ApiSignInterceptor()).addPathPatterns(%5C%22%2F1%2Fpeople%2F**%5C%22).excludePathPatterns(%5C%22%2F2%2Fpeople%2F**%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20super.addInterceptors(registry)%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22id%22%3A%22bb5ea83e%22%7D\"></card><p><br /></p><p><br /></p><p>这里是在项目引入拦截器，</p><p><br /></p><p>@Configuration，config形式加载在容器中<cursor /></p><p>其中addPathPatterns 和 excludePathPatterns 方法，从方法名就可以看出来，是针对拦截器的范围控制，上面的代码就是针对/1/people/** 生效，对/2/people/**  不生效</p><p><br /></p><p>目录结构如下：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555417189381-e54a2bdc-aed9-45ff-85f2-6f969952e010.png%22%2C%22originWidth%22%3A261%2C%22originHeight%22%3A231%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A261%2C%22height%22%3A231%7D\"></card></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T12:24:09.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T12:19:53.000Z",
    "updated_at": "2019-04-16T12:24:09.000Z",
    "published_at": "2019-04-16T12:24:09.000Z",
    "first_published_at": null,
    "word_count": 756,
    "cover": null,
    "description": "背景在实际项目中，接口出于安全考虑，都会有验签的计算。目前接触的项目来看基本都是时间戳+干扰因子 然后md5计算的方式。现在学习，写一个简单demo，其实如果不引入拦截器的话，验签计算全部在controller层实现也是可以的，但每个请求都需要去做一次计算，这种把公共功能的抽离，针对于所有请求...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547432,
    "slug": "b75d23e5-2a73-4095-8799-dc3219978665",
    "title": "测试分层",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "# 背景\n纯属个人总结，总结下目前接触到测试方法/体系\n\n从开发架构上来分层\n---------\n\n目前接触到项目，基本上都是如下图的架构模式（MVC），每一层都衍生出对应的测试\n\n![](https://images2018.cnblogs.com/blog/411616/201808/411616-20180818163757279-21225637.png)\n\n对应的测试：\n\n![](https://images2018.cnblogs.com/blog/411616/201808/411616-20180818164524475-309960583.png)\n\n看看市场上的测试岗位，大多数都是围绕这这些来设定的：功能测试，自动化测试，测试开发，性能测试，服务端测试\n\n个人最近几年都是服务端测试，基本上也是在接口层，但目前偏重数据层，也明白了数据的重要性，**业务的根源在数据，从数据上可以反应业务的健康度**\n\n不要被表象中的自动化，性能所迷惑，觉得做测试往上走就是搞自动化，性能，这样太局限了；\n\n有这么一种情况值得思考：即使你自动化搞的非常牛逼，性能也是吊炸天，然而业务没了怎么办？ 即使你是工具组的测试开发，没有业务团队接入也是扯淡。因此测试的本质的业务的质量，而不是为了测试而测试\n\n自动化是为了提高效率，是为了保证的解决业务的稳定性，性能是为了保证业务的体感\n\n从流程上来分层\n-------\n\n![](https://images2018.cnblogs.com/blog/411616/201808/411616-20180818170142112-902640062.png)\n\n上图是公司大致的研测流程，应该都是大同小异，备注是测试可以涉及的点\n\n**质量体系的建设都跟跟随研测流程**，好的质量体系是非常有必要的\n\n说下目前团队的建设：\n\n需求阶段：研发怼产品在这边很常见，公司的文化就是人人都是产品，这也是对业务的一种帮助，\n\n要勇于对产品需求提出建议看法，要产品提出数据支撑，不能你想做什么功能就做什么功能，要有预期的值的估算，如做了XX项目，可以预计xx指标上升20%；\n\n提测：提测需要研发保证主功能没有问题，列出测试点和自测结果、测试难点，测试记录打回次数，这是质量的体现，还有单元测试要全部通过，push代码触发；\n\n回归测试：回归测试平台保证之前积累的回归用例全部pass，上线卡点\n\n线上：监控体系建设，服务器资源的监控依赖于公司部署平台，如500错误，CPU资源；核心业务场景接口监控，保证核心业务无误；接口可用性监控；第三方接口拨测监控...保证线上无重大问题；\n\n数据层：大盘数据的监控（阈值，波动值），数据分析衡量业务健康度；\n\n监控体系是保证线上的无重大故障，或者提前感知问题；\n\n自动化是测试效率的提升，保障业务迭代的稳定性；\n\n数据分析是数据的累积，业务健康度的考察；\n\n以上每一项展开的话，都是一个个课题，测试的水也很深，个人期望自己也能成为某一方面的专家，随着细化，测试也在慢慢细化，如现在的app专项测试，大数据测试，算法测试....\n\n路很长...",
    "body_draft": "",
    "body_html": "<a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>纯属个人总结，总结下目前接触到测试方法/体系</p><p><br /></p><a name=\"从开发架构上来分层\"></a><h2 id=\"eecb0684\">从开发架构上来分层</h2><p><br /></p><p>目前接触到项目，基本上都是如下图的架构模式（MVC），每一层都衍生出对应的测试</p><p><br /></p><p><img src=\"https://images2018.cnblogs.com/blog/411616/201808/411616-20180818163757279-21225637.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>对应的测试：</p><p><br /></p><p><img src=\"https://images2018.cnblogs.com/blog/411616/201808/411616-20180818164524475-309960583.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>看看市场上的测试岗位，大多数都是围绕这这些来设定的：功能测试，自动化测试，测试开发，性能测试，服务端测试</p><p><br /></p><p>个人最近几年都是服务端测试，基本上也是在接口层，但目前偏重数据层，也明白了数据的重要性，<strong>业务的根源在数据，从数据上可以反应业务的健康度</strong></p><p><br /></p><p>不要被表象中的自动化，性能所迷惑，觉得做测试往上走就是搞自动化，性能，这样太局限了；</p><p><br /></p><p>有这么一种情况值得思考：即使你自动化搞的非常牛逼，性能也是吊炸天，然而业务没了怎么办？ 即使你是工具组的测试开发，没有业务团队接入也是扯淡。因此测试的本质的业务的质量，而不是为了测试而测试</p><p><br /></p><p>自动化是为了提高效率，是为了保证的解决业务的稳定性，性能是为了保证业务的体感</p><p><br /></p><a name=\"从流程上来分层\"></a><h2 id=\"2765a1bf\">从流程上来分层</h2><p><br /></p><p><img src=\"https://images2018.cnblogs.com/blog/411616/201808/411616-20180818170142112-902640062.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>上图是公司大致的研测流程，应该都是大同小异，备注是测试可以涉及的点</p><p><br /></p><p><strong>质量体系的建设都跟跟随研测流程</strong>，好的质量体系是非常有必要的</p><p><br /></p><p>说下目前团队的建设：</p><p><br /></p><p>需求阶段：研发怼产品在这边很常见，公司的文化就是人人都是产品，这也是对业务的一种帮助，</p><p><br /></p><p>要勇于对产品需求提出建议看法，要产品提出数据支撑，不能你想做什么功能就做什么功能，要有预期的值的估算，如做了XX项目，可以预计xx指标上升20%；</p><p><br /></p><p>提测：提测需要研发保证主功能没有问题，列出测试点和自测结果、测试难点，测试记录打回次数，这是质量的体现，还有单元测试要全部通过，push代码触发；</p><p><br /></p><p>回归测试：回归测试平台保证之前积累的回归用例全部pass，上线卡点</p><p><br /></p><p>线上：监控体系建设，服务器资源的监控依赖于公司部署平台，如500错误，CPU资源；核心业务场景接口监控，保证核心业务无误；接口可用性监控；第三方接口拨测监控...保证线上无重大问题；</p><p><br /></p><p>数据层：大盘数据的监控（阈值，波动值），数据分析衡量业务健康度；</p><p><br /></p><p>监控体系是保证线上的无重大故障，或者提前感知问题；</p><p><br /></p><p>自动化是测试效率的提升，保障业务迭代的稳定性；</p><p><br /></p><p>数据分析是数据的累积，业务健康度的考察；</p><p><br /></p><p>以上每一项展开的话，都是一个个课题，测试的水也很深，个人期望自己也能成为某一方面的专家，随着细化，测试也在慢慢细化，如现在的app专项测试，大数据测试，算法测试....</p><p><br /></p><p>路很长...</p>",
    "body_lake": "<!doctype lake><a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>纯属个人总结，总结下目前接触到测试方法/体系</p><p><br /></p><a name=\"从开发架构上来分层\"></a><h2 id=\"eecb0684\">从开发架构上来分层</h2><p><br /></p><p>目前接触到项目，基本上都是如下图的架构模式（MVC），每一层都衍生出对应的测试</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fimages2018.cnblogs.com%2Fblog%2F411616%2F201808%2F411616-20180818163757279-21225637.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>对应的测试：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fimages2018.cnblogs.com%2Fblog%2F411616%2F201808%2F411616-20180818164524475-309960583.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>看看市场上的测试岗位，大多数都是围绕这这些来设定的：功能测试，自动化测试，测试开发，性能测试，服务端测试</p><p><br /></p><p>个人最近几年都是服务端测试，基本上也是在接口层，但目前偏重数据层，也明白了数据的重要性，<strong>业务的根源在数据，从数据上可以反应业务的健康度</strong></p><p><br /></p><p>不要被表象中的自动化，性能所迷惑，觉得做测试往上走就是搞自动化，性能，这样太局限了；</p><p><br /></p><p>有这么一种情况值得思考：即使你自动化搞的非常牛逼，性能也是吊炸天，然而业务没了怎么办？ 即使你是工具组的测试开发，没有业务团队接入也是扯淡。因此测试的本质的业务的质量，而不是为了测试而测试</p><p><br /></p><p>自动化是为了提高效率，是为了保证的解决业务的稳定性，性能是为了保证业务的体感</p><p><br /></p><a name=\"从流程上来分层\"></a><h2 id=\"2765a1bf\">从流程上来分层</h2><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fimages2018.cnblogs.com%2Fblog%2F411616%2F201808%2F411616-20180818170142112-902640062.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>上图是公司大致的研测流程，应该都是大同小异，备注是测试可以涉及的点</p><p><br /></p><p><strong>质量体系的建设都跟跟随研测流程</strong>，好的质量体系是非常有必要的</p><p><br /></p><p>说下目前团队的建设：</p><p><br /></p><p>需求阶段：研发怼产品在这边很常见，公司的文化就是人人都是产品，这也是对业务的一种帮助，</p><p><br /></p><p>要勇于对产品需求提出建议看法，要产品提出数据支撑，不能你想做什么功能就做什么功能，要有预期的值的估算，如做了XX项目，可以预计xx指标上升20%；</p><p><br /></p><p>提测：提测需要研发保证主功能没有问题，列出测试点和自测结果、测试难点，测试记录打回次数，这是质量的体现，还有单元测试要全部通过，push代码触发；</p><p><br /></p><p>回归测试：回归测试平台保证之前积累的回归用例全部pass，上线卡点</p><p><br /></p><p>线上：监控体系建设，服务器资源的监控依赖于公司部署平台，如500错误，CPU资源；核心业务场景接口监控，保证核心业务无误；接口可用性监控；第三方接口拨测监控...保证线上无重大问题；</p><p><br /></p><p>数据层：大盘数据的监控（阈值，波动值），数据分析衡量业务健康度；</p><p><br /></p><p>监控体系是保证线上的无重大故障，或者提前感知问题；</p><p><br /></p><p>自动化是测试效率的提升，保障业务迭代的稳定性；</p><p><br /></p><p>数据分析是数据的累积，业务健康度的考察；</p><p><br /></p><p>以上每一项展开的话，都是一个个课题，测试的水也很深，个人期望自己也能成为某一方面的专家，随着细化，测试也在慢慢细化，如现在的app专项测试，大数据测试，算法测试....</p><p><br /></p><p>路很长...</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T12:19:07.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T12:19:07.000Z",
    "updated_at": "2019-06-24T01:13:07.000Z",
    "published_at": "2019-04-16T12:19:07.000Z",
    "first_published_at": null,
    "word_count": 839,
    "cover": null,
    "description": "背景 纯属个人总结，总结下目前接触到测试方法/体系  从开发架构上来分层 目前接触到项目，基本上都是如下图的架构模式（MVC），每一层都衍生出对应的测试  对应的测试：  看看市场上的测试岗位，大多数都是围绕这这些来设定的：功能测试，自动化测试，测试开发，性能测试，服务端测试 个人最近几年都是...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547426,
    "slug": "662919a3-c59b-486f-83ad-0af04dfb8e2a",
    "title": "SQL语句小tips（持续更新）",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"7dcb1c28\"></a>\n# 统计非法数据\n\n判断people_id是否是32为字母组成的，统计不满足要求的数据\n\nSELECT COUNT(IF(BINARY people_id NOT REGEXP '^[0-9a-z]{32}',TRUE,NULL)) AS people_id_illegality_cnt FROM people_day\n\n<a name=\"97def91a\"></a>\n### if 表达式\n\n> `IF( expr1 , expr2 , expr3 )`\n\n\nexpr1 的值为 TRUE，则返回值为 expr2 <br />\nexpr1 的值为FALSE，则返回值为 expr3\n\n其中TRUE，select出来是1\n\n**BINARY**\n\nwhere条件加入BINARY的话，可以对大小写敏感，默认mysql是不区分大小写的\n\n**非空判断，如果为空置为0，非空取当前值**\n\n两种方法：\n\n1. 利用if+isnull判断是否为空\n\n```sql\nselect if(ISNULL(sum(final_amount)),0,sum(final_amount)) as final_amount_total from day_income where day=20180821 and income_type=1;\n```\n\n2 . 利用COALESCE函数\n\nCOALESCE(value1,...) ：返回第一个非NULL的参数\n\n说明：返回列表中第一个非空值，如果没有非NULL值，则返回NULL。\n\n```sql\nmysql> SELECT COALESCE(NULL,1); -> 1 mysql> SELECT COALESCE(NULL,NULL,NULL); -> NULL\nselect COALESCE(sum(final_amount),0)  as final_amount_total from day_income where day=20180822 and income_type=1;\n```\n\nwhere语句里使用if判断。好难，感觉不好\n\n```sql\nSELECT COUNT(1) FROM test_tabel WHERE month = ( SELECT CASE 1\nWHEN DAY(CURDATE()) > 5 THEN date_format(curdate(), '%Y-%m') ELSE date_format(date_sub(curdate(), INTERVAL 1 MONTH), '%Y-%m') END AS correctMonth\n);\n```\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"7dcb1c28\">统计非法数据</h1><p><br /></p><p>判断people_id是否是32为字母组成的，统计不满足要求的数据</p><p><br /></p><p>SELECT COUNT(IF(BINARY people_id NOT REGEXP '^[0-9a-z]{32}',TRUE,NULL)) AS people_id_illegality_cnt FROM people_day</p><p><br /></p><h3 id=\"97def91a\">if 表达式</h3><p><br /></p><blockquote><p><code>IF( expr1 , expr2 , expr3 )</code></p></blockquote><p><br /></p><p>expr1 的值为 TRUE，则返回值为 expr2 <br />\nexpr1 的值为FALSE，则返回值为 expr3</p><p><br /></p><p>其中TRUE，select出来是1</p><p><br /></p><p><strong>BINARY</strong></p><p><br /></p><p>where条件加入BINARY的话，可以对大小写敏感，默认mysql是不区分大小写的</p><p><br /></p><p><strong>非空判断，如果为空置为0，非空取当前值</strong></p><p><br /></p><p>两种方法：</p><p><br /></p><p>1. 利用if+isnull判断是否为空</p><p><br /></p><pre data-lang=\"sql\"><code>select if(ISNULL(sum(final_amount)),0,sum(final_amount)) as final_amount_total from day_income where day=20180821 and income_type=1;</code></pre><p><br /></p><p>2 . 利用COALESCE函数</p><p><br /></p><p>COALESCE(value1,...) ：返回第一个非NULL的参数</p><p><br /></p><p>说明：返回列表中第一个非空值，如果没有非NULL值，则返回NULL。</p><p><br /></p><pre data-lang=\"sql\"><code>mysql&gt; SELECT COALESCE(NULL,1); -&gt; 1 mysql&gt; SELECT COALESCE(NULL,NULL,NULL); -&gt; NULL\nselect COALESCE(sum(final_amount),0)  as final_amount_total from day_income where day=20180822 and income_type=1;</code></pre><p><br /></p><p>where语句里使用if判断。好难，感觉不好</p><p><br /></p><pre data-lang=\"sql\"><code>SELECT COUNT(1) FROM test_tabel WHERE month = ( SELECT CASE 1\nWHEN DAY(CURDATE()) &gt; 5 THEN date_format(curdate(), '%Y-%m') ELSE date_format(date_sub(curdate(), INTERVAL 1 MONTH), '%Y-%m') END AS correctMonth\n);</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"7dcb1c28\">统计非法数据</h1><p><br /></p><p>判断people_id是否是32为字母组成的，统计不满足要求的数据</p><p><br /></p><p>SELECT COUNT(IF(BINARY people_id NOT REGEXP '^[0-9a-z]{32}',TRUE,NULL)) AS people_id_illegality_cnt FROM people_day</p><p><br /></p><h3 id=\"97def91a\">if 表达式</h3><p><br /></p><blockquote><p><code>IF( expr1 , expr2 , expr3 )</code></p></blockquote><p><br /></p><p>expr1 的值为 TRUE，则返回值为 expr2 <br />\nexpr1 的值为FALSE，则返回值为 expr3</p><p><br /></p><p>其中TRUE，select出来是1</p><p><br /></p><p><strong>BINARY</strong></p><p><br /></p><p>where条件加入BINARY的话，可以对大小写敏感，默认mysql是不区分大小写的</p><p><br /></p><p><strong>非空判断，如果为空置为0，非空取当前值</strong></p><p><br /></p><p>两种方法：</p><p><br /></p><p>1. 利用if+isnull判断是否为空</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22sql%22%2C%22code%22%3A%22select%20if(ISNULL(sum(final_amount))%2C0%2Csum(final_amount))%20as%20final_amount_total%20from%20day_income%20where%20day%3D20180821%20and%20income_type%3D1%3B%22%2C%22id%22%3A%22Bh82f%22%7D\"></card><p><br /></p><p>2 . 利用COALESCE函数</p><p><br /></p><p>COALESCE(value1,...) ：返回第一个非NULL的参数</p><p><br /></p><p>说明：返回列表中第一个非空值，如果没有非NULL值，则返回NULL。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22sql%22%2C%22code%22%3A%22mysql%3E%20SELECT%20COALESCE(NULL%2C1)%3B%20-%3E%201%20mysql%3E%20SELECT%20COALESCE(NULL%2CNULL%2CNULL)%3B%20-%3E%20NULL%5Cnselect%20COALESCE(sum(final_amount)%2C0)%20%20as%20final_amount_total%20from%20day_income%20where%20day%3D20180822%20and%20income_type%3D1%3B%22%2C%22id%22%3A%22lQzy7%22%7D\"></card><p><br /></p><p>where语句里使用if判断。好难，感觉不好</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22sql%22%2C%22code%22%3A%22SELECT%20COUNT(1)%20FROM%20test_tabel%20WHERE%20month%20%3D%20(%20SELECT%20CASE%201%5CnWHEN%20DAY(CURDATE())%20%3E%205%20THEN%20date_format(curdate()%2C%20'%25Y-%25m')%20ELSE%20date_format(date_sub(curdate()%2C%20INTERVAL%201%20MONTH)%2C%20'%25Y-%25m')%20END%20AS%20correctMonth%5Cn)%3B%22%2C%22id%22%3A%22HDDBM%22%7D\"></card><p><br /><cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T12:18:39.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T12:17:21.000Z",
    "updated_at": "2019-04-16T12:18:39.000Z",
    "published_at": "2019-04-16T12:18:39.000Z",
    "first_published_at": null,
    "word_count": 301,
    "cover": null,
    "description": "统计非法数据判断people_id是否是32为字母组成的，统计不满足要求的数据SELECT COUNT(IF(BINARY people_id NOT REGEXP '^[0-9a-z]{32}',TRUE,NULL)) AS people_id_illegality_cnt FROM peo...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547421,
    "slug": "f1d18502-1065-4a7c-bd7d-a8eaebc434cc",
    "title": "redis基本操作",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "# 背景\n业务版本中使用到了redis，需要验证数据存进redis是否正确\n\n# 前言\nRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。\n\n# 基本操作\n登录redis，两种方式都可以\n\n1\\. 使用telnet方式 \n\n2\\. 使用redis-cli命令进入\n\n但都需要指定端口，查看redis占用了哪个端口\n\ntelnet 127.0.0.1 6380   \n\n./redis-cli -p 6380\n\n**根据key查看value**\n\nget \"key\"\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555417003380-f96f6573-b429-426f-9c58-ca82786eacf6.png)\n\n**删除key-value**\n\nDEL \"key\"\n\n更多请参考：http://www.runoob.com/redis/redis-tutorial.html",
    "body_draft": "",
    "body_html": "<a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>业务版本中使用到了redis，需要验证数据存进redis是否正确</p><p><br /></p><a name=\"前言\"></a><h1 id=\"df368884\">前言</h1><p><br /></p><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</p><p><br /></p><a name=\"基本操作\"></a><h1 id=\"b7b05952\">基本操作</h1><p><br /></p><p>登录redis，两种方式都可以</p><p><br /></p><p>1. 使用telnet方式</p><p><br /></p><p>2. 使用redis-cli命令进入</p><p><br /></p><p>但都需要指定端口，查看redis占用了哪个端口</p><p><br /></p><p>telnet 127.0.0.1 6380</p><p><br /></p><p>./redis-cli -p 6380</p><p><br /></p><p><strong>根据key查看value</strong></p><p><br /></p><p>get &quot;key&quot;</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555417003380-f96f6573-b429-426f-9c58-ca82786eacf6.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p><strong>删除key-value</strong></p><p><br /></p><p>DEL &quot;key&quot;</p><p><br /></p><p>更多请参考：<a href=\"http://www.runoob.com/redis/redis-tutorial.html\" target=\"_blank\">http://www.runoob.com/redis/redis-tutorial.html</a></p>",
    "body_lake": "<!doctype lake><a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>业务版本中使用到了redis，需要验证数据存进redis是否正确</p><p><br /></p><a name=\"前言\"></a><h1 id=\"df368884\">前言</h1><p><br /></p><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</p><p><br /></p><a name=\"基本操作\"></a><h1 id=\"b7b05952\">基本操作</h1><p><br /></p><p>登录redis，两种方式都可以</p><p><br /></p><p>1. 使用telnet方式</p><p><br /></p><p>2. 使用redis-cli命令进入</p><p><br /></p><p>但都需要指定端口，查看redis占用了哪个端口</p><p><br /></p><p>telnet 127.0.0.1 6380</p><p><br /></p><p>./redis-cli -p 6380</p><p><br /></p><p><strong>根据key查看value</strong></p><p><br /></p><p>get &quot;key&quot;</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555417003380-f96f6573-b429-426f-9c58-ca82786eacf6.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p><strong>删除key-value</strong></p><p><br /></p><p>DEL &quot;key&quot;</p><p><br /></p><p>更多请参考：<a href=\"http://www.runoob.com/redis/redis-tutorial.html\" target=\"_blank\">http://www.runoob.com/redis/redis-tutorial.html</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T12:16:48.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T12:16:48.000Z",
    "updated_at": "2019-06-19T13:53:08.000Z",
    "published_at": "2019-04-16T12:16:48.000Z",
    "first_published_at": null,
    "word_count": 191,
    "cover": null,
    "description": "背景 业务版本中使用到了redis，需要验证数据存进redis是否正确  前言 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547418,
    "slug": "1090b937-013d-4de7-aa74-f655eb5c5631",
    "title": "唯品会osp简介（转）",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "> 转自 https://blog.csdn.net/panyongcsd/article/details/58617810\n\n> 公司(VIP)从2015年开始在内部推动Venus框架的使用，这是一款基于Apache Thrift远程调用框架二次开发的高性能、高可扩展的、服务治理的RPC框架。服务端使用IDL进行服务的定义，客户端集成服务的SDK即可调用服务端的服务，开发简单，大部分的公共功能都在Proxy代理层工作，减轻了开发者的负担，使其只需要关注业务部分。下面是对该框架的基本原理的简单介绍。   \n> 参考文献:   \n> 1. [Apache Thrift - 可伸缩的跨语言服务开发框架](https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/)   \n> 2\\. 公司内部的Venux文档(内网文档，无法分享)\n\n一、Thrift简介\n----------\n\nThrift采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，使用代码生成引擎可以在多种语言之中创建高效、无缝的服务，采用二进制格式进行数据的传输，相对于xml和json体积更小，对于高并发、大数据量的环境更有优势。   \n1\\. Hello World示例   \nHello.thrift\n\n     namespace java service.demo \n      service Hello{ \n           string helloString(1:string para) \n         i32 helloInt(1:i32 para) \n         bool helloBoolean(1:bool para) \n         void helloVoid() \n         string helloNull() \n      }\n\n这段IDL定义了服务的名称和五个方法，Thrift是对IDL的一种具体实现，使用Thrift的工具编译该idl文件，就会生成相应的Hello.java文件。该文件包含了在Hello.thrift文件中描述的服务Hello的接口定义，即Hello.Iface接口，以及服务调用的底层通信细节，包括客户端的饿调用逻辑Hello.Client以及服务端的处理逻辑Hello.Processor，用于构建客户端和服务端的功能。   \n创建HelloServiceImpl.java文件并实现Hello.java文件中的Hello.Iface接口，代码：\n\n    package service.demo; \n     import org.apache.thrift.TException; \n     public class HelloServiceImpl implements Hello.Iface { \n        @Override \n        public boolean helloBoolean(boolean para) throws TException { \n            return para; \n        } \n        @Override \n        public int helloInt(int para) throws TException { \n            try { \n                Thread.sleep(20000); \n            } catch (InterruptedException e) { \n                e.printStackTrace(); \n            } \n            return para; \n        } \n        @Override \n        public String helloNull() throws TException { \n            return null; \n        } \n        @Override \n        public String helloString(String para) throws TException { \n            return para; \n        } \n        @Override \n        public void helloVoid() throws TException { \n            System.out.println(\"Hello World\"); \n        } \n     }\n\n1.  Thrift架构   \n    架构图如下：   \n    ![](https://cdn.nlark.com/yuque/0/2019/jpeg/92887/1555416965096-636cbaa3-4557-418b-9de6-627c5b1b6197.jpeg)   \n    图中黄色部分是用户的业务代码，褐色部分是编译工具生成的代码框架，紫色部分和蓝色部分是我们所选择的传输层和传输协议。   \n    Thrift服务器包含用于绑定协议和传输层的基础架构，它提供阻塞、非阻塞、单线程和多线程的模式运行在服务器上。\n2.  传输协议   \n    Thrift可以让用户选择客户端和服务端之间的传输通信协议的类别，分为文本(text)和二进制(binary)。   \n    *   TBinaryProtocol：二进制编码格式进行数据传输\n    *   TCompactProtocol：高效率的密集的二进制编码协议\n    *   TJSONProtocol：使用Json的数据编码协议\n    *   TSimpleJSONProtocol：只提供Json读写的协议，适用于脚本语言解析\n3.  传输层   \n    *   TSocket：使用阻塞式IO进行传输\n    *   TFramedTransport：非阻塞方式，按块的大小进行传输，类似NIO；服务器必须为非阻塞的服务类型\n    *   TNonblockingTransport：非阻塞模式，用于构建异步客户端\n4.  服务端类型   \n    *   TSimpleServer：单线程服务器，阻塞IO\n    *   TThreadPoolServer：多线程服务器，阻塞式IO\n    *   TNonblockingServer：多线程服务器，非阻塞IO\n\n二、Venus的配置中心\n------------\n\n配置中心实现了集中配置、主动推送、规范配置、配置可读等优点。\n\n三、OSP详解\n-------\n\n开放服务平台(venus-osp)是Venus体系的核心组成部分之一， 主要目标是提供服务化的核心远程调用机制以及基础服务治理功能。契约化的服务接口保证系统间的解耦清晰、干净；基于Thrift的通信和协议层确保系统的高性能；服务可以自动注册并被发现，易于部署；配合配置中心，服务配置可以动态更新；客户端与治理逻辑的分离使服务接入得到极大简化；除此之外，OSP提供了丰富的服务治理能力，如路由、负载均衡、服务保护和优雅降级等。   \n1\\. 远程调用机制   \n![](http://i.imgur.com/0JjEErZ.png)\n\nOSP是一套高性能、高可扩展的远程过程调用(RPC)框架，基于Apache Thrift作为基本框架，采用Thrift的 工作模式。   \n每个客户端机器上都运行这一个proxy进程，该进程会将客户端的调用请求进行转发，优先转发到同机器的服务层、其次是同机房的服务、如果本机的proxy出现问题，会使用中央代理集群进行备份替换；   \n客户端在请求的时候和proxy保持长连接，proxy和服务容器保持长连接，从而获得服务容器中的服务的动态信息，如机器的健康状况、配置信息、新增机器等。   \n2\\. 服务协议(OSP Protocol)   \nOSP采用了基于二进制的通讯协议，以消息为基本通讯单元；每条消息包含消息头和消息体。协议设计上以无状态为原则，每条消息包含调用所需的所有信息，一次调用通过一次消息交换(请求/响应)完成。   \n3\\. 服务提供方(服务端)   \n\\- 服务端包含服务容器和服务本身。服务容器集中管理共享功能；服务本身以业务逻辑为主；   \n\\- OSP服务端容错基于无状态服务的理念，服务实例之间互不感知，通过代理层的错误感知和负载均衡等功能自动摘除有问题的服务器；   \n\\- 每个服务启动时，首先从配置中心获取配置，然后将自己的信息(ID、地址和端口)注册到服务注册中心；服务代理层(Proxy)从注册中心获取当前服务提供方的所有实例，通过设定的负载均衡策略对服务进行调用。   \n4\\. 服务代理层(OSP-Proxy)   \n![](http://i.imgur.com/ihYSWxI.png)   \nProxy集中了绝大部分的服务治理智能，可以说是远程调用的大脑。   \n\\- Proxy部署在每台服务器上，已进程的方式运行，客户端将请求发送到Proxy进程，Proxy根据服务治理逻辑(负载均衡、路由等)对请求进行处理(转发、降级或拒绝)，这样使服务治理的实现保持对客户端和服务端的完全透明，且动态可控。   \n\\- 出于容错考虑，每个IDC(机房)都会部署一个Proxy集群作为备用，当本机Proxy出现故障时，自动切换到备用Proxy集群。   \n5\\. 服务治理   \n这里的所谓服务治理主要集中在对负载均衡，路由选择以及自我保护等领域所提供的功能以及灵活性。   \n![](http://i.imgur.com/OoMVUln.png)   \n\\- 负载均衡：OSP的负载均衡功能由osp-proxy提供，目前支持Least Active First, RR，Random等多种负载均衡策略；通过与配置中心集成，策略可以动态变更；另外，在支持基本服务端健康度检测（如ping）的基础上，利用对丰富的服务信息的统计（调用流量、延迟、错误率等），可以提供更加智能的健康检测机制。   \n\\- 路由选择：服务路由决定一个服务请求是否应该得到处理，以及由哪一个服务实例处理。这部分是各种服务治理政策的执行地，是一个极为重要的模块。大量的使用场景都可以结合服务路由来实现，如服务的上线/下线，在线测试，机房选择，A/B测试，灰度发布，流量控制，权限控制以及优雅降级等。   \n6\\. 服务管理   \n\\- 注册：OSP通过服务容器加载启动，服务容器需要从配置中心获取服务的配置信息，服务容器根据获取的参数，对服务进行初始化操作。服务启动成功后，容器向服务注册中心（Service Registry）进行注册，系统记录该服务的一个实例已经运行。服务容器与服务注册中心保持长连接，当服务卸载或者服务容器故障退出时，服务注册中心可以自动的删除服务实例，维护最新有效的服务实例列表。   \n\\- 发现：当代理层需要调用一个服务时，代理层查询服务注册中心，获取所需服务的全部服务实例，并结合服务路由策略（决定可以为当前服务请求提供服务的实例）及负载均衡策略（选择那一个服务实例进行服务），选择一个服务实例。代理层维护到服务注册中心的长连接，这样如果有新的服务实例或者老的服务实例失效时，代理层可以及时获得最新的服务实例列表。与服务端不同，当代理层失去长连接后，仍然可以通过之前获得的实例列表进行服务调用。   \n\\- 服务路由策略：OSP Proxy查询服务注册中心，获取所需服务的全部服务实例列表，OSP Proxy选择被调用的服务实列策略如下：   \n\\- 本地主机服务实例优先，OSP Proxy优先先择与其部署在同一个主机上的服务实例；   \n\\- 同机房服务实例优先，OSP Proxy优先先择与其部署在同机房主机上的服务实例，同机房的判断条件：主机ipv4地址前两段相同；   \n\\- 多个务服实例采用LeastActive(最少当前连接数，策略表示服务请求优先选择最少操作的服务器进行请求处理)选择服务实例进行。",
    "body_draft": "",
    "body_html": "<blockquote><p>转自 <a href=\"https://blog.csdn.net/panyongcsd/article/details/58617810\" target=\"_blank\">https://blog.csdn.net/panyongcsd/article/details/58617810</a></p></blockquote><p><br /></p><blockquote><p>公司(VIP)从2015年开始在内部推动Venus框架的使用，这是一款基于Apache Thrift远程调用框架二次开发的高性能、高可扩展的、服务治理的RPC框架。服务端使用IDL进行服务的定义，客户端集成服务的SDK即可调用服务端的服务，开发简单，大部分的公共功能都在Proxy代理层工作，减轻了开发者的负担，使其只需要关注业务部分。下面是对该框架的基本原理的简单介绍。 <br />\n参考文献: <br />\n1. <a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/\" target=\"_blank\">Apache Thrift - 可伸缩的跨语言服务开发框架</a> <br />\n2. 公司内部的Venux文档(内网文档，无法分享)</p></blockquote><p><br /></p><a name=\"一、Thrift简介\"></a><h2 id=\"fc17de1f\">一、Thrift简介</h2><p><br /></p><p>Thrift采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，使用代码生成引擎可以在多种语言之中创建高效、无缝的服务，采用二进制格式进行数据的传输，相对于xml和json体积更小，对于高并发、大数据量的环境更有优势。 <br />\n1. Hello World示例 <br />\nHello.thrift</p><p><br /></p><pre><code>namespace java service.demo \n  service Hello{ \n       string helloString(1:string para) \n     i32 helloInt(1:i32 para) \n     bool helloBoolean(1:bool para) \n     void helloVoid() \n     string helloNull() \n  }</code></pre><p><br /></p><p>这段IDL定义了服务的名称和五个方法，Thrift是对IDL的一种具体实现，使用Thrift的工具编译该idl文件，就会生成相应的Hello.java文件。该文件包含了在Hello.thrift文件中描述的服务Hello的接口定义，即Hello.Iface接口，以及服务调用的底层通信细节，包括客户端的饿调用逻辑Hello.Client以及服务端的处理逻辑Hello.Processor，用于构建客户端和服务端的功能。 <br />\n创建HelloServiceImpl.java文件并实现Hello.java文件中的Hello.Iface接口，代码：</p><p><br /></p><pre><code>package service.demo; \n import org.apache.thrift.TException; \n public class HelloServiceImpl implements Hello.Iface { \n    @Override \n    public boolean helloBoolean(boolean para) throws TException { \n        return para; \n    } \n    @Override \n    public int helloInt(int para) throws TException { \n        try { \n            Thread.sleep(20000); \n        } catch (InterruptedException e) { \n            e.printStackTrace(); \n        } \n        return para; \n    } \n    @Override \n    public String helloNull() throws TException { \n        return null; \n    } \n    @Override \n    public String helloString(String para) throws TException { \n        return para; \n    } \n    @Override \n    public void helloVoid() throws TException { \n        System.out.println(&quot;Hello World&quot;); \n    } \n }</code></pre><p><br /></p><ol start=\"1\"><li>Thrift架构 <br />\n架构图如下： <br />\n<img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/92887/1555416965096-636cbaa3-4557-418b-9de6-627c5b1b6197.jpeg#alt=\" style=\"max-width: 600px;\" /> <br />\n图中黄色部分是用户的业务代码，褐色部分是编译工具生成的代码框架，紫色部分和蓝色部分是我们所选择的传输层和传输协议。 <br />\nThrift服务器包含用于绑定协议和传输层的基础架构，它提供阻塞、非阻塞、单线程和多线程的模式运行在服务器上。</li></ol><ol start=\"2\"><li>传输协议 <br />\nThrift可以让用户选择客户端和服务端之间的传输通信协议的类别，分为文本(text)和二进制(binary)。\n</li></ol><ul data-lake-indent=\"1\"><li>TBinaryProtocol：二进制编码格式进行数据传输</li></ul><ul data-lake-indent=\"1\"><li>TCompactProtocol：高效率的密集的二进制编码协议</li></ul><ul data-lake-indent=\"1\"><li>TJSONProtocol：使用Json的数据编码协议</li></ul><ul data-lake-indent=\"1\"><li>TSimpleJSONProtocol：只提供Json读写的协议，适用于脚本语言解析</li></ul>\n<ol start=\"3\"><li>传输层\n</li></ol><ul data-lake-indent=\"1\"><li>TSocket：使用阻塞式IO进行传输</li></ul><ul data-lake-indent=\"1\"><li>TFramedTransport：非阻塞方式，按块的大小进行传输，类似NIO；服务器必须为非阻塞的服务类型</li></ul><ul data-lake-indent=\"1\"><li>TNonblockingTransport：非阻塞模式，用于构建异步客户端</li></ul>\n<ol start=\"4\"><li>服务端类型\n</li></ol><ul data-lake-indent=\"1\"><li>TSimpleServer：单线程服务器，阻塞IO</li></ul><ul data-lake-indent=\"1\"><li>TThreadPoolServer：多线程服务器，阻塞式IO</li></ul><ul data-lake-indent=\"1\"><li>TNonblockingServer：多线程服务器，非阻塞IO</li></ul>\n<p><br /></p><a name=\"二、Venus的配置中心\"></a><h2 id=\"790a1c2f\">二、Venus的配置中心</h2><p><br /></p><p>配置中心实现了集中配置、主动推送、规范配置、配置可读等优点。</p><p><br /></p><a name=\"三、OSP详解\"></a><h2 id=\"e7160d0e\">三、OSP详解</h2><p><br /></p><p>开放服务平台(venus-osp)是Venus体系的核心组成部分之一， 主要目标是提供服务化的核心远程调用机制以及基础服务治理功能。契约化的服务接口保证系统间的解耦清晰、干净；基于Thrift的通信和协议层确保系统的高性能；服务可以自动注册并被发现，易于部署；配合配置中心，服务配置可以动态更新；客户端与治理逻辑的分离使服务接入得到极大简化；除此之外，OSP提供了丰富的服务治理能力，如路由、负载均衡、服务保护和优雅降级等。 <br />\n1. 远程调用机制 <br />\n<img src=\"http://i.imgur.com/0JjEErZ.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p>OSP是一套高性能、高可扩展的远程过程调用(RPC)框架，基于Apache Thrift作为基本框架，采用Thrift的 工作模式。 <br />\n每个客户端机器上都运行这一个proxy进程，该进程会将客户端的调用请求进行转发，优先转发到同机器的服务层、其次是同机房的服务、如果本机的proxy出现问题，会使用中央代理集群进行备份替换； <br />\n客户端在请求的时候和proxy保持长连接，proxy和服务容器保持长连接，从而获得服务容器中的服务的动态信息，如机器的健康状况、配置信息、新增机器等。 <br />\n2. 服务协议(OSP Protocol) <br />\nOSP采用了基于二进制的通讯协议，以消息为基本通讯单元；每条消息包含消息头和消息体。协议设计上以无状态为原则，每条消息包含调用所需的所有信息，一次调用通过一次消息交换(请求/响应)完成。 <br />\n3. 服务提供方(服务端) <br />\n- 服务端包含服务容器和服务本身。服务容器集中管理共享功能；服务本身以业务逻辑为主； <br />\n- OSP服务端容错基于无状态服务的理念，服务实例之间互不感知，通过代理层的错误感知和负载均衡等功能自动摘除有问题的服务器； <br />\n- 每个服务启动时，首先从配置中心获取配置，然后将自己的信息(ID、地址和端口)注册到服务注册中心；服务代理层(Proxy)从注册中心获取当前服务提供方的所有实例，通过设定的负载均衡策略对服务进行调用。 <br />\n4. 服务代理层(OSP-Proxy) <br />\n<img src=\"http://i.imgur.com/ihYSWxI.png#alt=\" style=\"max-width: 600px;\" /> <br />\nProxy集中了绝大部分的服务治理智能，可以说是远程调用的大脑。 <br />\n- Proxy部署在每台服务器上，已进程的方式运行，客户端将请求发送到Proxy进程，Proxy根据服务治理逻辑(负载均衡、路由等)对请求进行处理(转发、降级或拒绝)，这样使服务治理的实现保持对客户端和服务端的完全透明，且动态可控。 <br />\n- 出于容错考虑，每个IDC(机房)都会部署一个Proxy集群作为备用，当本机Proxy出现故障时，自动切换到备用Proxy集群。 <br />\n5. 服务治理 <br />\n这里的所谓服务治理主要集中在对负载均衡，路由选择以及自我保护等领域所提供的功能以及灵活性。 <br />\n<img src=\"http://i.imgur.com/OoMVUln.png#alt=\" style=\"max-width: 600px;\" /> <br />\n- 负载均衡：OSP的负载均衡功能由osp-proxy提供，目前支持Least Active First, RR，Random等多种负载均衡策略；通过与配置中心集成，策略可以动态变更；另外，在支持基本服务端健康度检测（如ping）的基础上，利用对丰富的服务信息的统计（调用流量、延迟、错误率等），可以提供更加智能的健康检测机制。 <br />\n- 路由选择：服务路由决定一个服务请求是否应该得到处理，以及由哪一个服务实例处理。这部分是各种服务治理政策的执行地，是一个极为重要的模块。大量的使用场景都可以结合服务路由来实现，如服务的上线/下线，在线测试，机房选择，A/B测试，灰度发布，流量控制，权限控制以及优雅降级等。 <br />\n6. 服务管理 <br />\n- 注册：OSP通过服务容器加载启动，服务容器需要从配置中心获取服务的配置信息，服务容器根据获取的参数，对服务进行初始化操作。服务启动成功后，容器向服务注册中心（Service Registry）进行注册，系统记录该服务的一个实例已经运行。服务容器与服务注册中心保持长连接，当服务卸载或者服务容器故障退出时，服务注册中心可以自动的删除服务实例，维护最新有效的服务实例列表。 <br />\n- 发现：当代理层需要调用一个服务时，代理层查询服务注册中心，获取所需服务的全部服务实例，并结合服务路由策略（决定可以为当前服务请求提供服务的实例）及负载均衡策略（选择那一个服务实例进行服务），选择一个服务实例。代理层维护到服务注册中心的长连接，这样如果有新的服务实例或者老的服务实例失效时，代理层可以及时获得最新的服务实例列表。与服务端不同，当代理层失去长连接后，仍然可以通过之前获得的实例列表进行服务调用。 <br />\n- 服务路由策略：OSP Proxy查询服务注册中心，获取所需服务的全部服务实例列表，OSP Proxy选择被调用的服务实列策略如下： <br />\n- 本地主机服务实例优先，OSP Proxy优先先择与其部署在同一个主机上的服务实例； <br />\n- 同机房服务实例优先，OSP Proxy优先先择与其部署在同机房主机上的服务实例，同机房的判断条件：主机ipv4地址前两段相同； <br />\n- 多个务服实例采用LeastActive(最少当前连接数，策略表示服务请求优先选择最少操作的服务器进行请求处理)选择服务实例进行。</p>",
    "body_lake": "<!doctype lake><blockquote><p>转自 <a href=\"https://blog.csdn.net/panyongcsd/article/details/58617810\" target=\"_blank\">https://blog.csdn.net/panyongcsd/article/details/58617810</a></p></blockquote><p><br /></p><blockquote><p>公司(VIP)从2015年开始在内部推动Venus框架的使用，这是一款基于Apache Thrift远程调用框架二次开发的高性能、高可扩展的、服务治理的RPC框架。服务端使用IDL进行服务的定义，客户端集成服务的SDK即可调用服务端的服务，开发简单，大部分的公共功能都在Proxy代理层工作，减轻了开发者的负担，使其只需要关注业务部分。下面是对该框架的基本原理的简单介绍。 <br />\n参考文献: <br />\n1. <a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/\" target=\"_blank\">Apache Thrift - 可伸缩的跨语言服务开发框架</a> <br />\n2. 公司内部的Venux文档(内网文档，无法分享)</p></blockquote><p><br /></p><a name=\"一、Thrift简介\"></a><h2 id=\"fc17de1f\">一、Thrift简介</h2><p><br /></p><p>Thrift采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，使用代码生成引擎可以在多种语言之中创建高效、无缝的服务，采用二进制格式进行数据的传输，相对于xml和json体积更小，对于高并发、大数据量的环境更有优势。 <br />\n1. Hello World示例 <br />\nHello.thrift</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%223e803297%22%2C%22code%22%3A%22namespace%20java%20service.demo%20%5Cn%20%20service%20Hello%7B%20%5Cn%20%20%20%20%20%20%20string%20helloString(1%3Astring%20para)%20%5Cn%20%20%20%20%20i32%20helloInt(1%3Ai32%20para)%20%5Cn%20%20%20%20%20bool%20helloBoolean(1%3Abool%20para)%20%5Cn%20%20%20%20%20void%20helloVoid()%20%5Cn%20%20%20%20%20string%20helloNull()%20%5Cn%20%20%7D%22%7D\"></card><p><br /></p><p>这段IDL定义了服务的名称和五个方法，Thrift是对IDL的一种具体实现，使用Thrift的工具编译该idl文件，就会生成相应的Hello.java文件。该文件包含了在Hello.thrift文件中描述的服务Hello的接口定义，即Hello.Iface接口，以及服务调用的底层通信细节，包括客户端的饿调用逻辑Hello.Client以及服务端的处理逻辑Hello.Processor，用于构建客户端和服务端的功能。 <br />\n创建HelloServiceImpl.java文件并实现Hello.java文件中的Hello.Iface接口，代码：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%229337518d%22%2C%22code%22%3A%22package%20service.demo%3B%20%5Cn%20import%20org.apache.thrift.TException%3B%20%5Cn%20public%20class%20HelloServiceImpl%20implements%20Hello.Iface%20%7B%20%5Cn%20%20%20%20%40Override%20%5Cn%20%20%20%20public%20boolean%20helloBoolean(boolean%20para)%20throws%20TException%20%7B%20%5Cn%20%20%20%20%20%20%20%20return%20para%3B%20%5Cn%20%20%20%20%7D%20%5Cn%20%20%20%20%40Override%20%5Cn%20%20%20%20public%20int%20helloInt(int%20para)%20throws%20TException%20%7B%20%5Cn%20%20%20%20%20%20%20%20try%20%7B%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20Thread.sleep(20000)%3B%20%5Cn%20%20%20%20%20%20%20%20%7D%20catch%20(InterruptedException%20e)%20%7B%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20e.printStackTrace()%3B%20%5Cn%20%20%20%20%20%20%20%20%7D%20%5Cn%20%20%20%20%20%20%20%20return%20para%3B%20%5Cn%20%20%20%20%7D%20%5Cn%20%20%20%20%40Override%20%5Cn%20%20%20%20public%20String%20helloNull()%20throws%20TException%20%7B%20%5Cn%20%20%20%20%20%20%20%20return%20null%3B%20%5Cn%20%20%20%20%7D%20%5Cn%20%20%20%20%40Override%20%5Cn%20%20%20%20public%20String%20helloString(String%20para)%20throws%20TException%20%7B%20%5Cn%20%20%20%20%20%20%20%20return%20para%3B%20%5Cn%20%20%20%20%7D%20%5Cn%20%20%20%20%40Override%20%5Cn%20%20%20%20public%20void%20helloVoid()%20throws%20TException%20%7B%20%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22Hello%20World%5C%22)%3B%20%5Cn%20%20%20%20%7D%20%5Cn%20%7D%22%7D\"></card><p><br /></p><ol start=\"1\"><li>Thrift架构 <br />\n架构图如下： <br />\n<card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F92887%2F1555416965096-636cbaa3-4557-418b-9de6-627c5b1b6197.jpeg%22%2C%22alt%22%3A%22%22%7D\"></card> <br />\n图中黄色部分是用户的业务代码，褐色部分是编译工具生成的代码框架，紫色部分和蓝色部分是我们所选择的传输层和传输协议。 <br />\nThrift服务器包含用于绑定协议和传输层的基础架构，它提供阻塞、非阻塞、单线程和多线程的模式运行在服务器上。</li></ol><ol start=\"2\"><li>传输协议 <br />\nThrift可以让用户选择客户端和服务端之间的传输通信协议的类别，分为文本(text)和二进制(binary)。\n</li></ol><ul data-lake-indent=\"1\"><li>TBinaryProtocol：二进制编码格式进行数据传输</li></ul><ul data-lake-indent=\"1\"><li>TCompactProtocol：高效率的密集的二进制编码协议</li></ul><ul data-lake-indent=\"1\"><li>TJSONProtocol：使用Json的数据编码协议</li></ul><ul data-lake-indent=\"1\"><li>TSimpleJSONProtocol：只提供Json读写的协议，适用于脚本语言解析</li></ul>\n<ol start=\"3\"><li>传输层\n</li></ol><ul data-lake-indent=\"1\"><li>TSocket：使用阻塞式IO进行传输</li></ul><ul data-lake-indent=\"1\"><li>TFramedTransport：非阻塞方式，按块的大小进行传输，类似NIO；服务器必须为非阻塞的服务类型</li></ul><ul data-lake-indent=\"1\"><li>TNonblockingTransport：非阻塞模式，用于构建异步客户端</li></ul>\n<ol start=\"4\"><li>服务端类型\n</li></ol><ul data-lake-indent=\"1\"><li>TSimpleServer：单线程服务器，阻塞IO</li></ul><ul data-lake-indent=\"1\"><li>TThreadPoolServer：多线程服务器，阻塞式IO</li></ul><ul data-lake-indent=\"1\"><li>TNonblockingServer：多线程服务器，非阻塞IO</li></ul>\n<p><br /></p><a name=\"二、Venus的配置中心\"></a><h2 id=\"790a1c2f\">二、Venus的配置中心</h2><p><br /></p><p>配置中心实现了集中配置、主动推送、规范配置、配置可读等优点。</p><p><br /></p><a name=\"三、OSP详解\"></a><h2 id=\"e7160d0e\">三、OSP详解</h2><p><br /></p><p>开放服务平台(venus-osp)是Venus体系的核心组成部分之一， 主要目标是提供服务化的核心远程调用机制以及基础服务治理功能。契约化的服务接口保证系统间的解耦清晰、干净；基于Thrift的通信和协议层确保系统的高性能；服务可以自动注册并被发现，易于部署；配合配置中心，服务配置可以动态更新；客户端与治理逻辑的分离使服务接入得到极大简化；除此之外，OSP提供了丰富的服务治理能力，如路由、负载均衡、服务保护和优雅降级等。 <br />\n1. 远程调用机制 <br />\n<card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22http%3A%2F%2Fi.imgur.com%2F0JjEErZ.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p>OSP是一套高性能、高可扩展的远程过程调用(RPC)框架，基于Apache Thrift作为基本框架，采用Thrift的 工作模式。 <br />\n每个客户端机器上都运行这一个proxy进程，该进程会将客户端的调用请求进行转发，优先转发到同机器的服务层、其次是同机房的服务、如果本机的proxy出现问题，会使用中央代理集群进行备份替换； <br />\n客户端在请求的时候和proxy保持长连接，proxy和服务容器保持长连接，从而获得服务容器中的服务的动态信息，如机器的健康状况、配置信息、新增机器等。 <br />\n2. 服务协议(OSP Protocol) <br />\nOSP采用了基于二进制的通讯协议，以消息为基本通讯单元；每条消息包含消息头和消息体。协议设计上以无状态为原则，每条消息包含调用所需的所有信息，一次调用通过一次消息交换(请求/响应)完成。 <br />\n3. 服务提供方(服务端) <br />\n- 服务端包含服务容器和服务本身。服务容器集中管理共享功能；服务本身以业务逻辑为主； <br />\n- OSP服务端容错基于无状态服务的理念，服务实例之间互不感知，通过代理层的错误感知和负载均衡等功能自动摘除有问题的服务器； <br />\n- 每个服务启动时，首先从配置中心获取配置，然后将自己的信息(ID、地址和端口)注册到服务注册中心；服务代理层(Proxy)从注册中心获取当前服务提供方的所有实例，通过设定的负载均衡策略对服务进行调用。 <br />\n4. 服务代理层(OSP-Proxy) <br />\n<card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22http%3A%2F%2Fi.imgur.com%2FihYSWxI.png%22%2C%22alt%22%3A%22%22%7D\"></card> <br />\nProxy集中了绝大部分的服务治理智能，可以说是远程调用的大脑。 <br />\n- Proxy部署在每台服务器上，已进程的方式运行，客户端将请求发送到Proxy进程，Proxy根据服务治理逻辑(负载均衡、路由等)对请求进行处理(转发、降级或拒绝)，这样使服务治理的实现保持对客户端和服务端的完全透明，且动态可控。 <br />\n- 出于容错考虑，每个IDC(机房)都会部署一个Proxy集群作为备用，当本机Proxy出现故障时，自动切换到备用Proxy集群。 <br />\n5. 服务治理 <br />\n这里的所谓服务治理主要集中在对负载均衡，路由选择以及自我保护等领域所提供的功能以及灵活性。 <br />\n<card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22http%3A%2F%2Fi.imgur.com%2FOoMVUln.png%22%2C%22alt%22%3A%22%22%7D\"></card> <br />\n- 负载均衡：OSP的负载均衡功能由osp-proxy提供，目前支持Least Active First, RR，Random等多种负载均衡策略；通过与配置中心集成，策略可以动态变更；另外，在支持基本服务端健康度检测（如ping）的基础上，利用对丰富的服务信息的统计（调用流量、延迟、错误率等），可以提供更加智能的健康检测机制。 <br />\n- 路由选择：服务路由决定一个服务请求是否应该得到处理，以及由哪一个服务实例处理。这部分是各种服务治理政策的执行地，是一个极为重要的模块。大量的使用场景都可以结合服务路由来实现，如服务的上线/下线，在线测试，机房选择，A/B测试，灰度发布，流量控制，权限控制以及优雅降级等。 <br />\n6. 服务管理 <br />\n- 注册：OSP通过服务容器加载启动，服务容器需要从配置中心获取服务的配置信息，服务容器根据获取的参数，对服务进行初始化操作。服务启动成功后，容器向服务注册中心（Service Registry）进行注册，系统记录该服务的一个实例已经运行。服务容器与服务注册中心保持长连接，当服务卸载或者服务容器故障退出时，服务注册中心可以自动的删除服务实例，维护最新有效的服务实例列表。 <br />\n- 发现：当代理层需要调用一个服务时，代理层查询服务注册中心，获取所需服务的全部服务实例，并结合服务路由策略（决定可以为当前服务请求提供服务的实例）及负载均衡策略（选择那一个服务实例进行服务），选择一个服务实例。代理层维护到服务注册中心的长连接，这样如果有新的服务实例或者老的服务实例失效时，代理层可以及时获得最新的服务实例列表。与服务端不同，当代理层失去长连接后，仍然可以通过之前获得的实例列表进行服务调用。 <br />\n- 服务路由策略：OSP Proxy查询服务注册中心，获取所需服务的全部服务实例列表，OSP Proxy选择被调用的服务实列策略如下： <br />\n- 本地主机服务实例优先，OSP Proxy优先先择与其部署在同一个主机上的服务实例； <br />\n- 同机房服务实例优先，OSP Proxy优先先择与其部署在同机房主机上的服务实例，同机房的判断条件：主机ipv4地址前两段相同； <br />\n- 多个务服实例采用LeastActive(最少当前连接数，策略表示服务请求优先选择最少操作的服务器进行请求处理)选择服务实例进行。</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T12:16:13.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T12:16:13.000Z",
    "updated_at": "2019-04-16T12:16:14.000Z",
    "published_at": "2019-04-16T12:16:13.000Z",
    "first_published_at": null,
    "word_count": 2494,
    "cover": null,
    "description": "转自 https://blog.csdn.net/panyongcsd/article/details/58617810   公司(VIP)从2015年开始在内部推动Venus框架的使用，这是一款基于Apache Thrift远程调用框架二次开发的高性能、高可扩展的、服务治理的RPC框架。服务...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547416,
    "slug": "a82855e9-930e-4018-b747-a17be59e8ad1",
    "title": "mac下的抓包工具 -- Charles",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "# 背景\n换了mac电脑，😜，需要抓包，之前windows上使用的fiddler使用不了，需要找到替代工具，随意百度下知道了 -- Charles\n\ncharles（读法，查尔斯）\n\n# 介绍\n官网：https://www.charlesproxy.com/\n`破解方法，嘿嘿：`\n\n`// Charles Proxy License`\n\n`// 适用于Charles任意版本的注册码，谁还会想要使用破解版呢。`\n\n`// Charles 4.2目前是最新版，可用。`\n\n`Registered Name: https:``//zhile.io`\n\n`License Key: 48891cf209c6d32bf4`\n\n`--------------------- 本文来自 花``2``不谢 的CSDN 博客 ，全文地址请点击：https:``//blog.csdn.net/qq_25821067/article/details/79848589?utm_source=copy`\n\n# 使用方法\n界面化工具的使用相对来说是非常好搞定的，直接搬运其他博客的了的\n\nhttps://blog.csdn.net/qq\\_38179167/article/details/80654093",
    "body_draft": "",
    "body_html": "<a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>换了mac电脑，😜，需要抓包，之前windows上使用的fiddler使用不了，需要找到替代工具，随意百度下知道了 -- Charles</p><p><br /></p><p>charles（读法，查尔斯）</p><p><br /></p><a name=\"介绍\"></a><h1 id=\"61a3ec66\">介绍</h1><p><br /></p><p>官网：<a href=\"https://www.charlesproxy.com/\" target=\"_blank\">https://www.charlesproxy.com/</a><br />\n<code>破解方法，嘿嘿：</code></p><p><br /></p><p><code>// Charles Proxy License</code></p><p><br /></p><p><code>// 适用于Charles任意版本的注册码，谁还会想要使用破解版呢。</code></p><p><br /></p><p><code>// Charles 4.2目前是最新版，可用。</code></p><p><br /></p><p><code>Registered Name: https:``//zhile.io</code></p><p><br /></p><p><code>License Key: 48891cf209c6d32bf4</code></p><p><br /></p><p><code>--------------------- 本文来自 花``2``不谢 的CSDN 博客 ，全文地址请点击：https:``//blog.csdn.net/qq_25821067/article/details/79848589?utm_source=copy</code></p><p><br /></p><a name=\"使用方法\"></a><h1 id=\"ec09647d\">使用方法</h1><p><br /></p><p>界面化工具的使用相对来说是非常好搞定的，直接搬运其他博客的了的</p><p><br /></p><p><a href=\"https://blog.csdn.net/qq_38179167/article/details/80654093\" target=\"_blank\">https://blog.csdn.net/qq_38179167/article/details/80654093</a></p>",
    "body_lake": "<!doctype lake><a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>换了mac电脑，😜，需要抓包，之前windows上使用的fiddler使用不了，需要找到替代工具，随意百度下知道了 -- Charles</p><p><br /></p><p>charles（读法，查尔斯）</p><p><br /></p><a name=\"介绍\"></a><h1 id=\"61a3ec66\">介绍</h1><p><br /></p><p>官网：<a href=\"https://www.charlesproxy.com/\" target=\"_blank\">https://www.charlesproxy.com/</a><br />\n<code>破解方法，嘿嘿：</code></p><p><br /></p><p><code>// Charles Proxy License</code></p><p><br /></p><p><code>// 适用于Charles任意版本的注册码，谁还会想要使用破解版呢。</code></p><p><br /></p><p><code>// Charles 4.2目前是最新版，可用。</code></p><p><br /></p><p><code>Registered Name: https:``//zhile.io</code></p><p><br /></p><p><code>License Key: 48891cf209c6d32bf4</code></p><p><br /></p><p><code>--------------------- 本文来自 花``2``不谢 的CSDN 博客 ，全文地址请点击：https:``//blog.csdn.net/qq_25821067/article/details/79848589?utm_source=copy</code></p><p><br /></p><a name=\"使用方法\"></a><h1 id=\"ec09647d\">使用方法</h1><p><br /></p><p>界面化工具的使用相对来说是非常好搞定的，直接搬运其他博客的了的</p><p><br /></p><p><a href=\"https://blog.csdn.net/qq_38179167/article/details/80654093\" target=\"_blank\">https://blog.csdn.net/qq_38179167/article/details/80654093</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T12:15:45.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T12:15:45.000Z",
    "updated_at": "2019-04-16T12:15:45.000Z",
    "published_at": "2019-04-16T12:15:45.000Z",
    "first_published_at": null,
    "word_count": 181,
    "cover": null,
    "description": "背景 换了mac电脑，😜，需要抓包，之前windows上使用的fiddler使用不了，需要找到替代工具，随意百度下知道了 -- Charles charles（读法，查尔斯）  介绍 官网：https://www.charlesproxy.com/ 破解方法，嘿嘿： // Charles P...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547392,
    "slug": "ec1cc7fe-ea2a-4dc7-a959-d7b1536fdb95",
    "title": "数据库索引问题",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "# 背景\n群上有一位同学咨询一个问题，两个查询语句，就一个limit 11， 一个limit 12，处理的效率相差巨大，如下图：\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555416431620-15470c54-d6ce-4dbc-a431-29e68ce5b1bc.png)\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555416431940-9312f91a-6006-4dd5-989d-1d7a9dee1bf9.png)\n\n# 解决\n原因就是因为limit不同，导致走了不同的索引\n\n走的索引不一样，决定了要检索的数据量多少  \n1、当你要取的数据很少的时候，mysql认为走start\\_time的索引很快就能找够满足条件的数据，结果实际上满足条件的数据按照start\\_time倒序排列需要检索很多数据，所以会比较慢。  \n2、而当你limit20的时候mysql认为按照其他索引可能需要扫描很多的记录才能找到你要的结果，所以走了city\\_id的索引。  \nso这种情况你可以尝试一下按照start\\_time倒序排列后找两条最近的数据出来，按这些字段的值再去用limit 0,2检索看看是不是很快，如果是的话那就可以确定是这个原因。\n\n一个类似的问题：https://segmentfault.com/q/1010000010707314\n\n解决方法：\n\n1. 强制使用一个索引，try，可以解决，但不够灵活\n\n2. order by 后面的时间做个空运算，干扰下优化器，\n\ndate\\_sub(create\\_time, interval 0 day)\n\n或者 \n\ncreate\\_time+0",
    "body_draft": "",
    "body_html": "<a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>群上有一位同学咨询一个问题，两个查询语句，就一个limit 11， 一个limit 12，处理的效率相差巨大，如下图：</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555416431620-15470c54-d6ce-4dbc-a431-29e68ce5b1bc.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555416431940-9312f91a-6006-4dd5-989d-1d7a9dee1bf9.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><a name=\"解决\"></a><h1 id=\"4b86211f\">解决</h1><p><br /></p><p>原因就是因为limit不同，导致走了不同的索引</p><p><br /></p><p>走的索引不一样，决定了要检索的数据量多少<br />\n1、当你要取的数据很少的时候，mysql认为走start_time的索引很快就能找够满足条件的数据，结果实际上满足条件的数据按照start_time倒序排列需要检索很多数据，所以会比较慢。<br />\n2、而当你limit20的时候mysql认为按照其他索引可能需要扫描很多的记录才能找到你要的结果，所以走了city_id的索引。<br />\nso这种情况你可以尝试一下按照start_time倒序排列后找两条最近的数据出来，按这些字段的值再去用limit 0,2检索看看是不是很快，如果是的话那就可以确定是这个原因。</p><p><br /></p><p>一个类似的问题：<a href=\"https://segmentfault.com/q/1010000010707314\" target=\"_blank\">https://segmentfault.com/q/1010000010707314</a></p><p><br /></p><p>解决方法：</p><p><br /></p><p>1. 强制使用一个索引，try，可以解决，但不够灵活</p><p><br /></p><p>2. order by 后面的时间做个空运算，干扰下优化器，</p><p><br /></p><p>date_sub(create_time, interval 0 day)</p><p><br /></p><p>或者</p><p><br /></p><p>create_time+0</p>",
    "body_lake": "<!doctype lake><a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>群上有一位同学咨询一个问题，两个查询语句，就一个limit 11， 一个limit 12，处理的效率相差巨大，如下图：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555416431620-15470c54-d6ce-4dbc-a431-29e68ce5b1bc.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555416431940-9312f91a-6006-4dd5-989d-1d7a9dee1bf9.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><a name=\"解决\"></a><h1 id=\"4b86211f\">解决</h1><p><br /></p><p>原因就是因为limit不同，导致走了不同的索引</p><p><br /></p><p>走的索引不一样，决定了要检索的数据量多少<br />\n1、当你要取的数据很少的时候，mysql认为走start_time的索引很快就能找够满足条件的数据，结果实际上满足条件的数据按照start_time倒序排列需要检索很多数据，所以会比较慢。<br />\n2、而当你limit20的时候mysql认为按照其他索引可能需要扫描很多的记录才能找到你要的结果，所以走了city_id的索引。<br />\nso这种情况你可以尝试一下按照start_time倒序排列后找两条最近的数据出来，按这些字段的值再去用limit 0,2检索看看是不是很快，如果是的话那就可以确定是这个原因。</p><p><br /></p><p>一个类似的问题：<a href=\"https://segmentfault.com/q/1010000010707314\" target=\"_blank\">https://segmentfault.com/q/1010000010707314</a></p><p><br /></p><p>解决方法：</p><p><br /></p><p>1. 强制使用一个索引，try，可以解决，但不够灵活</p><p><br /></p><p>2. order by 后面的时间做个空运算，干扰下优化器，</p><p><br /></p><p>date_sub(create_time, interval 0 day)</p><p><br /></p><p>或者</p><p><br /></p><p>create_time+0</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T12:07:13.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T12:07:13.000Z",
    "updated_at": "2019-04-16T12:07:13.000Z",
    "published_at": "2019-04-16T12:07:13.000Z",
    "first_published_at": null,
    "word_count": 330,
    "cover": null,
    "description": "背景 群上有一位同学咨询一个问题，两个查询语句，就一个limit 11， 一个limit 12，处理的效率相差巨大，如下图：    解决 原因就是因为limit不同，导致走了不同的索引 走的索引不一样，决定了要检索的数据量多少 1、当你要取的数据很少的时候，mysql认为走start_time...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547373,
    "slug": "a4b94e92-589d-4d1e-b761-359d99268bdd",
    "title": "jacoco初探",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8e1b944f\"></a>\n# 背景\n集团的代码覆盖率平台因为网络问题无法使用，只能自己研究下。\n\n覆盖率是衡量自动化用例效果产品的一个指标，但只是一个辅助指标，覆盖率高并不意味着质量好，但覆盖率低却能说明一些问题，\n\n<a name=\"f5deaa17\"></a>\n# 对比\n\n覆盖率工具的对比，直接引用资料：\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/92887/1555416228795-02bd1341-65f0-4914-a10b-b6949ad30136.png#align=left&display=inline&height=517&name=image.png&originHeight=517&originWidth=738&size=133429&status=done&width=738)\n\n> 有赞团队的博客： [https://tech.youzan.com/code-coverage/](https://tech.youzan.com/code-coverage/)\n\n\n<a name=\"ac8a4f56\"></a>\n# 理解\n\n1. 结合业务形态，被测服务不能停止服务；\n\n2. 通过javaagent方式去启动jacoco；\n\n3. javaagent的方式可以用file，tcpserver、tcpclient三种模式，常用的是tcpserver格式\n\n4. 挂载javagent后，可以利用ip：port来跟javaagent进行网络交互，生成exec文件，生成报告；\n\n<a name=\"74718689\"></a>\n# 细节\n\n1. jacoco官网：[https://www.eclemma.org/jacoco/](https://www.eclemma.org/jacoco/) 上去下载agent.jar包；\n\n2. javaagent格式：\n\n-javaagent:_[yourpath/]_jacocoagent.jar=_[option1]_=_[value1]_,_[option2]_=_[value2]<br />\n更多参数：[https://www.jacoco.org/jacoco/trunk/doc/agent.html](https://www.jacoco.org/jacoco/trunk/doc/agent.html)<br />\n_\n\n_ 实际例子：-javaagent:/home/tools/jacocoagent.jar=includes=*,output=tcpserver,address=xxx.xxx.xx.xx,port=6300,append=true_\n\n3. 生成exec文件不局限于ant工具，其实底层还是通过tcp连接去访问；\n\n4. 生成exce后需要解析成报告，比较麻烦，要有编译后的class文件也有要源码。最理解的状态应该是从服务器拿回本地来操作；\n\n5. 实际落地： 被测服务挂载javaagent --》执行自动化用例 --》 生成exec文件 --》 解析生成报告（被测服务器上生成exec文件）\n\n<a name=\"9822c60d\"></a>\n# 疑问\n\n1. jacoco只支持时间段的代码覆盖率的统计，并不能细化到哪个方法/接口；\n\n2. javaagent的tcpserver和tcpclient的区别是什么？翻阅文档基本上都是tcpserver的，没有用tcpclient的\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8e1b944f\">背景</h1><p>集团的代码覆盖率平台因为网络问题无法使用，只能自己研究下。</p><p><br /></p><p>覆盖率是衡量自动化用例效果产品的一个指标，但只是一个辅助指标，覆盖率高并不意味着质量好，但覆盖率低却能说明一些问题，</p><p><br /></p><h1 id=\"f5deaa17\">对比</h1><p><br /></p><p>覆盖率工具的对比，直接引用资料：</p><p><br /></p><p><br /><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555416228795-02bd1341-65f0-4914-a10b-b6949ad30136.png#align=left&amp;display=inline&amp;height=517&amp;name=image.png&amp;originHeight=517&amp;originWidth=738&amp;size=133429&amp;status=done&amp;width=738\" style=\"max-width: 600px; width: 738px;\" /></p><p><br /></p><blockquote><p>有赞团队的博客： <a href=\"https://tech.youzan.com/code-coverage/\" target=\"_blank\">https://tech.youzan.com/code-coverage/</a></p></blockquote><p><br /></p><h1 id=\"ac8a4f56\">理解</h1><p><br /></p><p>1. 结合业务形态，被测服务不能停止服务；</p><p><br /></p><p>2. 通过javaagent方式去启动jacoco；</p><p><br /></p><p>3. javaagent的方式可以用file，tcpserver、tcpclient三种模式，常用的是tcpserver格式</p><p><br /></p><p>4. 挂载javagent后，可以利用ip：port来跟javaagent进行网络交互，生成exec文件，生成报告；</p><p><br /></p><h1 id=\"74718689\">细节</h1><p><br /></p><p>1. jacoco官网：<a href=\"https://www.eclemma.org/jacoco/\" target=\"_blank\">https://www.eclemma.org/jacoco/</a> 上去下载agent.jar包；</p><p><br /></p><p>2. javaagent格式：</p><p><br /></p><p>-javaagent:<em>[yourpath/]</em>jacocoagent.jar=<em>[option1]</em>=<em>[value1]</em>,<em>[option2]</em>=_[value2]<br />\n更多参数：<a href=\"https://www.jacoco.org/jacoco/trunk/doc/agent.html\" target=\"_blank\">https://www.jacoco.org/jacoco/trunk/doc/agent.html</a><br />\n_</p><p><br /></p><p><em> 实际例子：-javaagent:/home/tools/jacocoagent.jar=includes=*,output=tcpserver,address=xxx.xxx.xx.xx,port=6300,append=true</em></p><p><br /></p><p>3. 生成exec文件不局限于ant工具，其实底层还是通过tcp连接去访问；</p><p><br /></p><p>4. 生成exce后需要解析成报告，比较麻烦，要有编译后的class文件也有要源码。最理解的状态应该是从服务器拿回本地来操作；</p><p><br /></p><p>5. 实际落地： 被测服务挂载javaagent --》执行自动化用例 --》 生成exec文件 --》 解析生成报告（被测服务器上生成exec文件）</p><p><br /></p><h1 id=\"9822c60d\">疑问</h1><p><br /></p><p>1. jacoco只支持时间段的代码覆盖率的统计，并不能细化到哪个方法/接口；</p><p><br /></p><p>2. javaagent的tcpserver和tcpclient的区别是什么？翻阅文档基本上都是tcpserver的，没有用tcpclient的</p>",
    "body_lake": "<!doctype lake><h1 id=\"8e1b944f\">背景</h1><p>集团的代码覆盖率平台因为网络问题无法使用，只能自己研究下。</p><p><br /></p><p>覆盖率是衡量自动化用例效果产品的一个指标，但只是一个辅助指标，覆盖率高并不意味着质量好，但覆盖率低却能说明一些问题，</p><p><br /></p><h1 id=\"f5deaa17\">对比</h1><p><br /></p><p>覆盖率工具的对比，直接引用资料：</p><p><br /></p><p><br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555416228795-02bd1341-65f0-4914-a10b-b6949ad30136.png%22%2C%22originWidth%22%3A738%2C%22originHeight%22%3A517%2C%22name%22%3A%22image.png%22%2C%22size%22%3A133429%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A738%2C%22height%22%3A517%7D\"></card><cursor /></p><p><br /></p><blockquote><p>有赞团队的博客： <a href=\"https://tech.youzan.com/code-coverage/\" target=\"_blank\">https://tech.youzan.com/code-coverage/</a></p></blockquote><p><br /></p><h1 id=\"ac8a4f56\">理解</h1><p><br /></p><p>1. 结合业务形态，被测服务不能停止服务；</p><p><br /></p><p>2. 通过javaagent方式去启动jacoco；</p><p><br /></p><p>3. javaagent的方式可以用file，tcpserver、tcpclient三种模式，常用的是tcpserver格式</p><p><br /></p><p>4. 挂载javagent后，可以利用ip：port来跟javaagent进行网络交互，生成exec文件，生成报告；</p><p><br /></p><h1 id=\"74718689\">细节</h1><p><br /></p><p>1. jacoco官网：<a href=\"https://www.eclemma.org/jacoco/\" target=\"_blank\">https://www.eclemma.org/jacoco/</a> 上去下载agent.jar包；</p><p><br /></p><p>2. javaagent格式：</p><p><br /></p><p>-javaagent:<em>[yourpath/]</em>jacocoagent.jar=<em>[option1]</em>=<em>[value1]</em>,<em>[option2]</em>=_[value2]<br />\n更多参数：<a href=\"https://www.jacoco.org/jacoco/trunk/doc/agent.html\" target=\"_blank\">https://www.jacoco.org/jacoco/trunk/doc/agent.html</a><br />\n_</p><p><br /></p><p><em> 实际例子：-javaagent:/home/tools/jacocoagent.jar=includes=*,output=tcpserver,address=xxx.xxx.xx.xx,port=6300,append=true</em></p><p><br /></p><p>3. 生成exec文件不局限于ant工具，其实底层还是通过tcp连接去访问；</p><p><br /></p><p>4. 生成exce后需要解析成报告，比较麻烦，要有编译后的class文件也有要源码。最理解的状态应该是从服务器拿回本地来操作；</p><p><br /></p><p>5. 实际落地： 被测服务挂载javaagent --》执行自动化用例 --》 生成exec文件 --》 解析生成报告（被测服务器上生成exec文件）</p><p><br /></p><h1 id=\"9822c60d\">疑问</h1><p><br /></p><p>1. jacoco只支持时间段的代码覆盖率的统计，并不能细化到哪个方法/接口；</p><p><br /></p><p>2. javaagent的tcpserver和tcpclient的区别是什么？翻阅文档基本上都是tcpserver的，没有用tcpclient的</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T12:03:51.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T12:02:02.000Z",
    "updated_at": "2019-04-16T12:03:51.000Z",
    "published_at": "2019-04-16T12:03:51.000Z",
    "first_published_at": null,
    "word_count": 430,
    "cover": null,
    "description": "背景集团的代码覆盖率平台因为网络问题无法使用，只能自己研究下。覆盖率是衡量自动化用例效果产品的一个指标，但只是一个辅助指标，覆盖率高并不意味着质量好，但覆盖率低却能说明一些问题，对比覆盖率工具的对比，直接引用资料：有赞团队的博客： https://tech.youzan.com/code-co...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547355,
    "slug": "e792f70a-dbfc-4f77-b19c-b8cd3f6a2b4c",
    "title": "java中int和Integer对比的一些坑",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "\n\\---------------------   \n作者：狂飙的yellowcong   \n来源：CSDN   \n原文：https://blog.csdn.net/yelllowcong/article/details/78434606   \n版权声明：本文为博主原创文章，转载请附上博文链接！\n\n\\--------------------- \n\nInteger与int类型的关系\n================\n\nInteger是int的包装类，int的默认值是0，而Integer的默认值是null（jdk1.5的新特性 自动装箱和拆箱，Integer.valueOf（） 和xx.intValue（） ）,\n\n需要注意的是Integer里面默认的缓存数字是-128-127，\n\n1、Integer与Integer相互比较，数据在-128-127范围内，就会从缓存中拿去数据，比较就相等；如果不在这个范围，就会直接新创建一个Integer对象，使用 == 判断的是两个内存的应用地址，所以自然不相等。\n\n2、Integer和int类型相比，在jdk1.5,会自动拆箱，然后比较栈内存中的数据，所以没有不想等的情况  \n  \n\nint跟int比较\n---------\n\nint数据类型，都是在栈内存中存储，如果这个数字在栈内存中存在就会直接指向这个内存地址，如果不存在，就会重新开辟内存空间，所以int和int类型的比较，相同的值不会存在内存不等的情况\n\n八个基本数据类型不能看作对象（这点很特殊），存放在栈中。栈内操作速度快，创建销毁很容易\n\nint跟Integer比较\n-------------\n\n会自动拆箱，变成int与int对比\n\nInteger跟Integer比较\n\n　　在-128~127的范围内，==会相等，获取的cache的地址\n\n　　不在上述范围内，会去new一个对象对比\n\n　　直接new对象的话，肯定不等于\n\n ",
    "body_draft": "",
    "body_html": "<p>--------------------- <br />\n作者：狂飙的yellowcong <br />\n来源：CSDN <br />\n原文：<a href=\"https://blog.csdn.net/yelllowcong/article/details/78434606\" target=\"_blank\">https://blog.csdn.net/yelllowcong/article/details/78434606</a> <br />\n版权声明：本文为博主原创文章，转载请附上博文链接！</p><p><br /></p><p>---------------------</p><p><br /></p><a name=\"Integer与int类型的关系\"></a><h1 id=\"cf74074c\">Integer与int类型的关系</h1><p><br /></p><p>Integer是int的包装类，int的默认值是0，而Integer的默认值是null（jdk1.5的新特性 自动装箱和拆箱，Integer.valueOf（） 和xx.intValue（） ）,</p><p><br /></p><p>需要注意的是Integer里面默认的缓存数字是-128-127，</p><p><br /></p><p>1、Integer与Integer相互比较，数据在-128-127范围内，就会从缓存中拿去数据，比较就相等；如果不在这个范围，就会直接新创建一个Integer对象，使用 == 判断的是两个内存的应用地址，所以自然不相等。</p><p><br /></p><p>2、Integer和int类型相比，在jdk1.5,会自动拆箱，然后比较栈内存中的数据，所以没有不想等的情况</p><p><br /></p><a name=\"int跟int比较\"></a><h2 id=\"06705955\">int跟int比较</h2><p><br /></p><p>int数据类型，都是在栈内存中存储，如果这个数字在栈内存中存在就会直接指向这个内存地址，如果不存在，就会重新开辟内存空间，所以int和int类型的比较，相同的值不会存在内存不等的情况</p><p><br /></p><p>八个基本数据类型不能看作对象（这点很特殊），存放在栈中。栈内操作速度快，创建销毁很容易</p><p><br /></p><a name=\"int跟Integer比较\"></a><h2 id=\"1c88546e\">int跟Integer比较</h2><p><br /></p><p>会自动拆箱，变成int与int对比</p><p><br /></p><p>Integer跟Integer比较</p><p><br /></p><p>在-128~127的范围内，==会相等，获取的cache的地址</p><p><br /></p><p>不在上述范围内，会去new一个对象对比</p><p><br /></p><p>直接new对象的话，肯定不等于</p>",
    "body_lake": "<!doctype lake><p>--------------------- <br />\n作者：狂飙的yellowcong <br />\n来源：CSDN <br />\n原文：<a href=\"https://blog.csdn.net/yelllowcong/article/details/78434606\" target=\"_blank\">https://blog.csdn.net/yelllowcong/article/details/78434606</a> <br />\n版权声明：本文为博主原创文章，转载请附上博文链接！</p><p><br /></p><p>---------------------</p><p><br /></p><a name=\"Integer与int类型的关系\"></a><h1 id=\"cf74074c\">Integer与int类型的关系</h1><p><br /></p><p>Integer是int的包装类，int的默认值是0，而Integer的默认值是null（jdk1.5的新特性 自动装箱和拆箱，Integer.valueOf（） 和xx.intValue（） ）,</p><p><br /></p><p>需要注意的是Integer里面默认的缓存数字是-128-127，</p><p><br /></p><p>1、Integer与Integer相互比较，数据在-128-127范围内，就会从缓存中拿去数据，比较就相等；如果不在这个范围，就会直接新创建一个Integer对象，使用 == 判断的是两个内存的应用地址，所以自然不相等。</p><p><br /></p><p>2、Integer和int类型相比，在jdk1.5,会自动拆箱，然后比较栈内存中的数据，所以没有不想等的情况</p><p><br /></p><a name=\"int跟int比较\"></a><h2 id=\"06705955\">int跟int比较</h2><p><br /></p><p>int数据类型，都是在栈内存中存储，如果这个数字在栈内存中存在就会直接指向这个内存地址，如果不存在，就会重新开辟内存空间，所以int和int类型的比较，相同的值不会存在内存不等的情况</p><p><br /></p><p>八个基本数据类型不能看作对象（这点很特殊），存放在栈中。栈内操作速度快，创建销毁很容易</p><p><br /></p><a name=\"int跟Integer比较\"></a><h2 id=\"1c88546e\">int跟Integer比较</h2><p><br /></p><p>会自动拆箱，变成int与int对比</p><p><br /></p><p>Integer跟Integer比较</p><p><br /></p><p>在-128~127的范围内，==会相等，获取的cache的地址</p><p><br /></p><p>不在上述范围内，会去new一个对象对比</p><p><br /></p><p>直接new对象的话，肯定不等于</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T11:58:50.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T11:58:50.000Z",
    "updated_at": "2019-04-16T11:58:50.000Z",
    "published_at": "2019-04-16T11:58:50.000Z",
    "first_published_at": null,
    "word_count": 409,
    "cover": null,
    "description": "---------------------  作者：狂飙的yellowcong  来源：CSDN  原文：https://blog.csdn.net/yelllowcong/article/details/78434606  版权声明：本文为博主原创文章，转载请附上博文链接！ --------...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547350,
    "slug": "716cb3fb-f4aa-4f6a-bcc3-9d23e5ea75d6",
    "title": "精确测试",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"7ac32497\"></a>\n# 定义\n直接引用百度的 ：\n\n> 精准测试是一套计算机测试辅助分析系统。精准测试的核心组件包含的软件测试示波器、用例和代码的双向[追溯](https://baike.baidu.com/item/%E8%BF%BD%E6%BA%AF/10363173)、智能回归[测试用例](https://baike.baidu.com/item/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/1928697)选取、覆盖率分析、[缺陷](https://baike.baidu.com/item/%E7%BC%BA%E9%99%B7/33312)[定位](https://baike.baidu.com/item/%E5%AE%9A%E4%BD%8D)、测试用例[聚类](https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB)分析、测试用例自动生成系统，这些功能完整的构成了精准测试技术体系\n\n\n集团的同学分享了关于精准测试的文章，看了下简单记录一下\n\n（以下都是个人理解，如果有不对欢迎留言讨论）\n\n1. 做测试的朋友都可能碰到过：漏测/少测，根本原因是不知道研发改动了什么/影响到什么 or 是知道了改动了什么但因为一些需求历史不清楚，导致不知道影响到了什么；\n\n1. 精准的对立就是模糊，精准测试说白了就是当研发提交一个新版本过来的时候，你知道它改动了什么，影响到哪些接口/方法，然后针对改动点去测试。是从测试的角度去看待问题，提高测试的效率，毕竟之前是要求全量回归的，现在只需要测试部分；\n\n2. 精准测试 跟 回归测试有没有悖论呢 ？回归测试，验证新功能会不会对其他原有功能造成影响；而精准测试貌似说是可以发现这些影响面？ 了解了精准测试的大致原理，我只能说很难发现，why？\n\n3. 精准测试的大致思路：研发改动了什么 --> 影响面评估 -->  筛选用例 --> 用例执行 ；\n\n<a name=\"709dbd3c\"></a>\n# 没有精确测试\n\n---\n\n\n1. 提测 -- 研发提交代码，告知改动点，可能的影响面，自测点，测试重点（这里需要靠谱的研发！！）\n\n2. 用例编写 -- 针对这次需求/改动点编写用例，用业务经验/技术经验来评估影响面来新增用例；\n\n3. 用例review -- 用例发给组内同学一起讨论下，从别人的角度看待问题；\n\n4. 用例执行 ；\n\n总结： 其实用业务经验、技术经验、用例组内review就是一种精确测试，只是人工的形式罢了\n\n<a name=\"3fc06c3b\"></a>\n# 有了精确测试\n\n---\n\n\n1. 提测 -- 通过git工具获取本次提交的变更记录，获取改动的情况，可具体到哪个文件；\n\n2. diff --  通过diff工具，git也有diff功能，class文件的diff，目的就是找出方法级别的改动；\n\n3. 分析调用链路 -- 通过分析源码，找到入口，也就是top方法，java的service层，controller层\n\n4. 筛选用例 --  根据链路上的影响分析需要回归哪些用例；\n\n总结：整体大致流程就是：代码push --> 触发精准测试任务 --> 通过git工具获取改动详情（文件，方法，入口）--> 在用例库中筛选用例自动化执行 --> 报告输出（用例+覆盖率）\n\n<a name=\"80f82005\"></a>\n# 精确测试好处\n\n---\n\n\n1. 评估影响面，对长链路测试有帮助，A-B-C-D，修改了C，能评估中ABD中方法级别的影响；\n\n2. 提高测试效率，避免了不必要的用例执行；\n\n<a name=\"36e5e338\"></a>\n# 精确测试的疑问\n\n---\n\n\n1. 如果同一个工程中的链路，用精确测试确实可以精确的发现影响面，提供测试效率，但是多系统之间呢 ？如购物车系统 + 订单系统，两个不同的团队之间的链路，只能评估到比较粗的粒度；\n\n2. 数据依赖的，无法解决；A系统的代码变更导致写入DB中的数据变化了，B系统知识根据数据来走业务流程，那么A跟B的联系 就断开了，目前看到的文章只能在代码级别做关联；\n\n<a name=\"6f07b148\"></a>\n# 可借鉴的\n\n---\n\n\n1. 思路：从代码追溯到接口级别的改动来筛选用例，可以帮忙评估影响面，结合CI流程，是不是每次代码push可以有个大致的影响面评估图呢？\n",
    "body_draft": "",
    "body_html": "<h1 id=\"7ac32497\">定义</h1><p>直接引用百度的 ：</p><p><br /></p><blockquote><p>精准测试是一套计算机测试辅助分析系统。精准测试的核心组件包含的软件测试示波器、用例和代码的双向<a href=\"https://baike.baidu.com/item/%E8%BF%BD%E6%BA%AF/10363173\" target=\"_blank\">追溯</a>、智能回归<a href=\"https://baike.baidu.com/item/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/1928697\" target=\"_blank\">测试用例</a>选取、覆盖率分析、<a href=\"https://baike.baidu.com/item/%E7%BC%BA%E9%99%B7/33312\" target=\"_blank\">缺陷</a><a href=\"https://baike.baidu.com/item/%E5%AE%9A%E4%BD%8D\" target=\"_blank\">定位</a>、测试用例<a href=\"https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB\" target=\"_blank\">聚类</a>分析、测试用例自动生成系统，这些功能完整的构成了精准测试技术体系</p></blockquote><p><br /></p><p>集团的同学分享了关于精准测试的文章，看了下简单记录一下</p><p><br /></p><p>（以下都是个人理解，如果有不对欢迎留言讨论）</p><p><br /></p><p>1. 做测试的朋友都可能碰到过：漏测/少测，根本原因是不知道研发改动了什么/影响到什么 or 是知道了改动了什么但因为一些需求历史不清楚，导致不知道影响到了什么；</p><p><br /></p><p>1. 精准的对立就是模糊，精准测试说白了就是当研发提交一个新版本过来的时候，你知道它改动了什么，影响到哪些接口/方法，然后针对改动点去测试。是从测试的角度去看待问题，提高测试的效率，毕竟之前是要求全量回归的，现在只需要测试部分；</p><p><br /></p><p>2. 精准测试 跟 回归测试有没有悖论呢 ？回归测试，验证新功能会不会对其他原有功能造成影响；而精准测试貌似说是可以发现这些影响面？ 了解了精准测试的大致原理，我只能说很难发现，why？</p><p><br /></p><p>3. 精准测试的大致思路：研发改动了什么 --&gt; 影响面评估 --&gt;  筛选用例 --&gt; 用例执行 ；</p><p><br /></p><h1 id=\"709dbd3c\">没有精确测试</h1><hr /><p><br /></p><p>1. 提测 -- 研发提交代码，告知改动点，可能的影响面，自测点，测试重点（这里需要靠谱的研发！！）</p><p><br /></p><p>2. 用例编写 -- 针对这次需求/改动点编写用例，用业务经验/技术经验来评估影响面来新增用例；</p><p><br /></p><p>3. 用例review -- 用例发给组内同学一起讨论下，从别人的角度看待问题；</p><p><br /></p><p>4. 用例执行 ；</p><p><br /></p><p>总结： 其实用业务经验、技术经验、用例组内review就是一种精确测试，只是人工的形式罢了</p><p><br /></p><h1 id=\"3fc06c3b\">有了精确测试</h1><hr /><p><br /></p><p>1. 提测 -- 通过git工具获取本次提交的变更记录，获取改动的情况，可具体到哪个文件；</p><p><br /></p><p>2. diff --  通过diff工具，git也有diff功能，class文件的diff，目的就是找出方法级别的改动；</p><p><br /></p><p>3. 分析调用链路 -- 通过分析源码，找到入口，也就是top方法，java的service层，controller层</p><p><br /></p><p>4. 筛选用例 --  根据链路上的影响分析需要回归哪些用例；</p><p><br /></p><p>总结：整体大致流程就是：代码push --&gt; 触发精准测试任务 --&gt; 通过git工具获取改动详情（文件，方法，入口）--&gt; 在用例库中筛选用例自动化执行 --&gt; 报告输出（用例+覆盖率）</p><p><br /></p><h1 id=\"80f82005\">精确测试好处</h1><hr /><p><br /></p><p>1. 评估影响面，对长链路测试有帮助，A-B-C-D，修改了C，能评估中ABD中方法级别的影响；</p><p><br /></p><p>2. 提高测试效率，避免了不必要的用例执行；</p><p><br /></p><h1 id=\"36e5e338\">精确测试的疑问</h1><hr /><p><br /></p><p>1. 如果同一个工程中的链路，用精确测试确实可以精确的发现影响面，提供测试效率，但是多系统之间呢 ？如购物车系统 + 订单系统，两个不同的团队之间的链路，只能评估到比较粗的粒度；</p><p><br /></p><p>2. 数据依赖的，无法解决；A系统的代码变更导致写入DB中的数据变化了，B系统知识根据数据来走业务流程，那么A跟B的联系 就断开了，目前看到的文章只能在代码级别做关联；</p><p><br /></p><h1 id=\"6f07b148\">可借鉴的</h1><hr /><p><br /></p><p>1. 思路：从代码追溯到接口级别的改动来筛选用例，可以帮忙评估影响面，结合CI流程，是不是每次代码push可以有个大致的影响面评估图呢？</p>",
    "body_lake": "<!doctype lake><h1 id=\"7ac32497\">定义</h1><p>直接引用百度的 ：</p><p><br /></p><blockquote><p>精准测试是一套计算机测试辅助分析系统。精准测试的核心组件包含的软件测试示波器、用例和代码的双向<a href=\"https://baike.baidu.com/item/%E8%BF%BD%E6%BA%AF/10363173\" target=\"_blank\">追溯</a>、智能回归<a href=\"https://baike.baidu.com/item/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/1928697\" target=\"_blank\">测试用例</a>选取、覆盖率分析、<a href=\"https://baike.baidu.com/item/%E7%BC%BA%E9%99%B7/33312\" target=\"_blank\">缺陷</a><a href=\"https://baike.baidu.com/item/%E5%AE%9A%E4%BD%8D\" target=\"_blank\">定位</a>、测试用例<a href=\"https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB\" target=\"_blank\">聚类</a>分析、测试用例自动生成系统，这些功能完整的构成了精准测试技术体系</p></blockquote><p><br /></p><p>集团的同学分享了关于精准测试的文章，看了下简单记录一下</p><p><br /></p><p>（以下都是个人理解，如果有不对欢迎留言讨论）</p><p><br /></p><p>1. 做测试的朋友都可能碰到过：漏测/少测，根本原因是不知道研发改动了什么/影响到什么 or 是知道了改动了什么但因为一些需求历史不清楚，导致不知道影响到了什么；</p><p><br /></p><p>1. 精准的对立就是模糊，精准测试说白了就是当研发提交一个新版本过来的时候，你知道它改动了什么，影响到哪些接口/方法，然后针对改动点去测试。是从测试的角度去看待问题，提高测试的效率，毕竟之前是要求全量回归的，现在只需要测试部分；</p><p><br /></p><p>2. 精准测试 跟 回归测试有没有悖论呢 ？回归测试，验证新功能会不会对其他原有功能造成影响；而精准测试貌似说是可以发现这些影响面？ 了解了精准测试的大致原理，我只能说很难发现，why？</p><p><br /></p><p>3. 精准测试的大致思路：研发改动了什么 --&gt; 影响面评估 --&gt;  筛选用例 --&gt; 用例执行 ；</p><p><br /></p><h1 id=\"709dbd3c\">没有精确测试</h1><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22THbvz%22%7D\"></card><p><br /></p><p>1. 提测 -- 研发提交代码，告知改动点，可能的影响面，自测点，测试重点（这里需要靠谱的研发！！）</p><p><br /></p><p>2. 用例编写 -- 针对这次需求/改动点编写用例，用业务经验/技术经验来评估影响面来新增用例；</p><p><br /></p><p>3. 用例review -- 用例发给组内同学一起讨论下，从别人的角度看待问题；</p><p><br /></p><p>4. 用例执行 ；</p><p><br /></p><p>总结： 其实用业务经验、技术经验、用例组内review就是一种精确测试，只是人工的形式罢了</p><p><br /></p><h1 id=\"3fc06c3b\">有了精确测试</h1><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22ydGE3%22%7D\"></card><p><br /></p><p>1. 提测 -- 通过git工具获取本次提交的变更记录，获取改动的情况，可具体到哪个文件；</p><p><br /></p><p>2. diff --  通过diff工具，git也有diff功能，class文件的diff，目的就是找出方法级别的改动；</p><p><br /></p><p>3. 分析调用链路 -- 通过分析源码，找到入口，也就是top方法，java的service层，controller层</p><p><br /></p><p>4. 筛选用例 --  根据链路上的影响分析需要回归哪些用例；</p><p><br /></p><p>总结：整体大致流程就是：代码push --&gt; 触发精准测试任务 --&gt; 通过git工具获取改动详情（文件，方法，入口）--&gt; 在用例库中筛选用例自动化执行 --&gt; 报告输出（用例+覆盖率）</p><p><br /></p><h1 id=\"80f82005\">精确测试好处</h1><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22H9XUp%22%7D\"></card><p><br /></p><p>1. 评估影响面，对长链路测试有帮助，A-B-C-D，修改了C，能评估中ABD中方法级别的影响；</p><p><br /></p><p>2. 提高测试效率，避免了不必要的用例执行；</p><p><br /></p><h1 id=\"36e5e338\">精确测试的疑问</h1><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%223TQEl%22%7D\"></card><p><br /></p><p>1. 如果同一个工程中的链路，用精确测试确实可以精确的发现影响面，提供测试效率，但是多系统之间呢 ？如购物车系统 + 订单系统，两个不同的团队之间的链路，只能评估到比较粗的粒度；</p><p><br /></p><p>2. 数据依赖的，无法解决；A系统的代码变更导致写入DB中的数据变化了，B系统知识根据数据来走业务流程，那么A跟B的联系 就断开了，目前看到的文章只能在代码级别做关联；</p><p><br /></p><h1 id=\"6f07b148\">可借鉴的<cursor /></h1><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22roHhH%22%7D\"></card><p><br /></p><p>1. 思路：从代码追溯到接口级别的改动来筛选用例，可以帮忙评估影响面，结合CI流程，是不是每次代码push可以有个大致的影响面评估图呢？</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T11:57:23.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T11:56:54.000Z",
    "updated_at": "2019-04-16T11:57:23.000Z",
    "published_at": "2019-04-16T11:57:23.000Z",
    "first_published_at": null,
    "word_count": 1054,
    "cover": null,
    "description": "定义直接引用百度的 ：精准测试是一套计算机测试辅助分析系统。精准测试的核心组件包含的软件测试示波器、用例和代码的双向追溯、智能回归测试用例选取、覆盖率分析、缺陷定位、测试用例聚类分析、测试用例自动生成系统，这些功能完整的构成了精准测试技术体系集团的同学分享了关于精准测试的文章，看了下简单记录一...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547330,
    "slug": "f457b50c-3180-4edd-bf26-fe1f3165e6af",
    "title": "UC浏览器 - 不负责任思考",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "前言\n==\n\nUC浏览器的辉煌应该是我读大学（2008年）的时候，转眼间，十年过去了，庆幸的是UC还在，我从使用者变成了一名UC的员工。\n\n以下都是个人的不负责任的猜想或者思考\n\n变更\n==\n\n塞班时代\n\nUC浏览器的地位可以说是巨无霸的存在，手机上必备软件之一，想必大多数那个时代的人和我一样在课堂上用UC看着NBA文字直播，当时的流量还可以按K来统计，当时的手机都是按键的，当时还是NOKIA的天下，当时我还很年轻^\\_^\n\nUC的杀手锏是流量压缩技术，无图模式，让用户在这小小屏幕上阅读有更好的体验\n\n由于创始团队是从移动电信行业中过来的，预见了互联网跟移动设备的结合的时代到来\n\n> 永福的产品分享中有这么几句话：\n> \n> 无线永远是有限的，有线永远是无限的。（现在听起来还是有点懵逼）\n> \n> 用户跟内容这条通道上，有几次变革：门户 -- 搜索 -- 浏览器\n> \n> 互联网上有三种流：信息流，人流，资金流，对应着BAT\n\n安卓+IOS时代\n\n随着NOKIA辉煌的慢慢褪去，现在00后估计不知道诺基亚是啥东西，估计也很难想象当时的手机造型可真是百花齐放，这个时代UC浏览器也快速更近，出安卓版本+IOS版本，全面转向移动互联网时代，内部好像称为第二次创业，这个时候浏览器的地位还是比较牢固的，UC的口碑无疑还是非常棒的，这里有个搞笑的点，因为UC可以搜索出来你懂的东西\n\n现在的状况呢？\n\n4G时代还正步入5G时代，一个广告都可能是十几M的时代了，到处都是WIFI，手机流量都是好几个G的，手机流量看高清视频毫无压力，流量压缩技术现在看来有点像个笑话；\n\nAPP横行，都是独立的app了，浏览器的形态很尴尬了，对于大多数用户来说现在的浏览器其实就是用来百度下的而已，看新闻我有专业的新闻app，看视频我有视频app，看漫画我有漫画app，听歌。。。\n\n手机厂商的突起，Jobs的苹果重行定义了手机，iphone确实很棒，安卓的开源+苹果的商业形式，软硬件结合使得国内的手机厂商异常多，对用户来说很棒，选择更多了，看你们竞争，小米，魅族，oppo，vivo等等等。。都有自己的os，那么很大一部分用户都使用的是自带的浏览器，（其实永俞在分享中有提到了这点，在用户--内容这一层上，下一个变更应该就是在操作系统上，更底下了的）\n\n网站的改变，响应式设计，之前还记得有wap站点的，现在都应该是响应式设计了，网站自动适配手机屏幕了的，这点感觉也让UC很尴尬\n\nUC对应的改变就是，从浏览器这种工具性的 转向了 内容聚合平台 的形态，这种转变是浏览器的形态的转变，目前市面上的浏览器大多数都是如此。\n\n困扰\n==\n\nUC的做法是不是伤害了用户体验了？\n\n转变为内容聚合平台，在UC上可以看新闻，看视频，看小说，看漫画，可以搜索，可以玩游戏。。。他就是一个容器，或者更夸张的说就是一个操作系统，这是当年永福说的，这个概念就很像如今的小程序；但是用户来看，觉得一个浏览器而已，为啥干了这么多杂七杂八的事情呢？觉得UC浏览器越来越臃肿了；换句话说，如果UC能把这些功能做到极致了，能PK过那些原生APP了，用户可以只需要一个UC吗 ？尤其是现在容量也越来越不便宜了的 。。\n\n其实UC也意识到了这个问题，因为有这么一个浏览器 --  夸克浏览器，给搭建安利一下，纯工具形态的浏览器\n\n在这差异性越来越小的世界，UC该怎么走呢？ \n\n浏览器的功能，说个不好听的的，大大小小的公司换个壳就是一个了的，核心优势没了，只能靠口碑活下去吗 ？ 问了身边的朋友，使用UC的原因就是因为从塞班时代就开始用了的，习惯了，但现在都快卸载了，这应该整个浏览器形态的思考转变吧\n\n技术\n==\n\n能翻到的资料不多，大致的流程和PC浏览器一致，UC浏览器在服务层做了一层解析排版\n\n1\\. DNS域名解析\n\n2\\. 获取IP和端口，建立连接\n\n3\\. 发送请求，这一层是不是先发给了UC还需要确定下\n\n4\\. 获取返回，UC服务层做了一层解析，让内容更好的适应手机屏幕\n\n5\\. 手机展示\n\n简单来说就是UC做了一层代理，让内容更符合手机的小屏幕；\n\n当然UC也有自己的核心技术的，不然怎么在市场上屹立这么久的呢 \n\n结尾\n==\n\n现在提及UC，可能大家第一想到是UC震惊体，看到是UC越来越臃肿的样子\n\n不知道大家还记得当时那可爱的小松鼠吗 ？",
    "body_draft": "",
    "body_html": "<a name=\"前言\"></a><h1 id=\"df368884\">前言</h1><p><br /></p><p>UC浏览器的辉煌应该是我读大学（2008年）的时候，转眼间，十年过去了，庆幸的是UC还在，我从使用者变成了一名UC的员工。</p><p><br /></p><p>以下都是个人的不负责任的猜想或者思考</p><p><br /></p><a name=\"变更\"></a><h1 id=\"1dd554cd\">变更</h1><p><br /></p><p>塞班时代</p><p><br /></p><p>UC浏览器的地位可以说是巨无霸的存在，手机上必备软件之一，想必大多数那个时代的人和我一样在课堂上用UC看着NBA文字直播，当时的流量还可以按K来统计，当时的手机都是按键的，当时还是NOKIA的天下，当时我还很年轻<sup>_</sup></p><p><br /></p><p>UC的杀手锏是流量压缩技术，无图模式，让用户在这小小屏幕上阅读有更好的体验</p><p><br /></p><p>由于创始团队是从移动电信行业中过来的，预见了互联网跟移动设备的结合的时代到来</p><p><br /></p><blockquote><p>永福的产品分享中有这么几句话：</p>\n<p>无线永远是有限的，有线永远是无限的。（现在听起来还是有点懵逼）</p>\n<p>用户跟内容这条通道上，有几次变革：门户 -- 搜索 -- 浏览器</p>\n<p>互联网上有三种流：信息流，人流，资金流，对应着BAT</p></blockquote><p><br /></p><p>安卓+IOS时代</p><p><br /></p><p>随着NOKIA辉煌的慢慢褪去，现在00后估计不知道诺基亚是啥东西，估计也很难想象当时的手机造型可真是百花齐放，这个时代UC浏览器也快速更近，出安卓版本+IOS版本，全面转向移动互联网时代，内部好像称为第二次创业，这个时候浏览器的地位还是比较牢固的，UC的口碑无疑还是非常棒的，这里有个搞笑的点，因为UC可以搜索出来你懂的东西</p><p><br /></p><p>现在的状况呢？</p><p><br /></p><p>4G时代还正步入5G时代，一个广告都可能是十几M的时代了，到处都是WIFI，手机流量都是好几个G的，手机流量看高清视频毫无压力，流量压缩技术现在看来有点像个笑话；</p><p><br /></p><p>APP横行，都是独立的app了，浏览器的形态很尴尬了，对于大多数用户来说现在的浏览器其实就是用来百度下的而已，看新闻我有专业的新闻app，看视频我有视频app，看漫画我有漫画app，听歌。。。</p><p><br /></p><p>手机厂商的突起，Jobs的苹果重行定义了手机，iphone确实很棒，安卓的开源+苹果的商业形式，软硬件结合使得国内的手机厂商异常多，对用户来说很棒，选择更多了，看你们竞争，小米，魅族，oppo，vivo等等等。。都有自己的os，那么很大一部分用户都使用的是自带的浏览器，（其实永俞在分享中有提到了这点，在用户--内容这一层上，下一个变更应该就是在操作系统上，更底下了的）</p><p><br /></p><p>网站的改变，响应式设计，之前还记得有wap站点的，现在都应该是响应式设计了，网站自动适配手机屏幕了的，这点感觉也让UC很尴尬</p><p><br /></p><p>UC对应的改变就是，从浏览器这种工具性的 转向了 内容聚合平台 的形态，这种转变是浏览器的形态的转变，目前市面上的浏览器大多数都是如此。</p><p><br /></p><a name=\"困扰\"></a><h1 id=\"1071ea26\">困扰</h1><p><br /></p><p>UC的做法是不是伤害了用户体验了？</p><p><br /></p><p>转变为内容聚合平台，在UC上可以看新闻，看视频，看小说，看漫画，可以搜索，可以玩游戏。。。他就是一个容器，或者更夸张的说就是一个操作系统，这是当年永福说的，这个概念就很像如今的小程序；但是用户来看，觉得一个浏览器而已，为啥干了这么多杂七杂八的事情呢？觉得UC浏览器越来越臃肿了；换句话说，如果UC能把这些功能做到极致了，能PK过那些原生APP了，用户可以只需要一个UC吗 ？尤其是现在容量也越来越不便宜了的 。。</p><p><br /></p><p>其实UC也意识到了这个问题，因为有这么一个浏览器 --  夸克浏览器，给搭建安利一下，纯工具形态的浏览器</p><p><br /></p><p>在这差异性越来越小的世界，UC该怎么走呢？</p><p><br /></p><p>浏览器的功能，说个不好听的的，大大小小的公司换个壳就是一个了的，核心优势没了，只能靠口碑活下去吗 ？ 问了身边的朋友，使用UC的原因就是因为从塞班时代就开始用了的，习惯了，但现在都快卸载了，这应该整个浏览器形态的思考转变吧</p><p><br /></p><a name=\"技术\"></a><h1 id=\"a95dd3e1\">技术</h1><p><br /></p><p>能翻到的资料不多，大致的流程和PC浏览器一致，UC浏览器在服务层做了一层解析排版</p><p><br /></p><p>1. DNS域名解析</p><p><br /></p><p>2. 获取IP和端口，建立连接</p><p><br /></p><p>3. 发送请求，这一层是不是先发给了UC还需要确定下</p><p><br /></p><p>4. 获取返回，UC服务层做了一层解析，让内容更好的适应手机屏幕</p><p><br /></p><p>5. 手机展示</p><p><br /></p><p>简单来说就是UC做了一层代理，让内容更符合手机的小屏幕；</p><p><br /></p><p>当然UC也有自己的核心技术的，不然怎么在市场上屹立这么久的呢</p><p><br /></p><a name=\"结尾\"></a><h1 id=\"d1fb6ef9\">结尾</h1><p><br /></p><p>现在提及UC，可能大家第一想到是UC震惊体，看到是UC越来越臃肿的样子</p><p><br /></p><p>不知道大家还记得当时那可爱的小松鼠吗 ？</p>",
    "body_lake": "<!doctype lake><a name=\"前言\"></a><h1 id=\"df368884\">前言</h1><p><br /></p><p>UC浏览器的辉煌应该是我读大学（2008年）的时候，转眼间，十年过去了，庆幸的是UC还在，我从使用者变成了一名UC的员工。</p><p><br /></p><p>以下都是个人的不负责任的猜想或者思考</p><p><br /></p><a name=\"变更\"></a><h1 id=\"1dd554cd\">变更</h1><p><br /></p><p>塞班时代</p><p><br /></p><p>UC浏览器的地位可以说是巨无霸的存在，手机上必备软件之一，想必大多数那个时代的人和我一样在课堂上用UC看着NBA文字直播，当时的流量还可以按K来统计，当时的手机都是按键的，当时还是NOKIA的天下，当时我还很年轻<sup>_</sup></p><p><br /></p><p>UC的杀手锏是流量压缩技术，无图模式，让用户在这小小屏幕上阅读有更好的体验</p><p><br /></p><p>由于创始团队是从移动电信行业中过来的，预见了互联网跟移动设备的结合的时代到来</p><p><br /></p><blockquote><p>永福的产品分享中有这么几句话：</p>\n<p>无线永远是有限的，有线永远是无限的。（现在听起来还是有点懵逼）</p>\n<p>用户跟内容这条通道上，有几次变革：门户 -- 搜索 -- 浏览器</p>\n<p>互联网上有三种流：信息流，人流，资金流，对应着BAT</p></blockquote><p><br /></p><p>安卓+IOS时代</p><p><br /></p><p>随着NOKIA辉煌的慢慢褪去，现在00后估计不知道诺基亚是啥东西，估计也很难想象当时的手机造型可真是百花齐放，这个时代UC浏览器也快速更近，出安卓版本+IOS版本，全面转向移动互联网时代，内部好像称为第二次创业，这个时候浏览器的地位还是比较牢固的，UC的口碑无疑还是非常棒的，这里有个搞笑的点，因为UC可以搜索出来你懂的东西</p><p><br /></p><p>现在的状况呢？</p><p><br /></p><p>4G时代还正步入5G时代，一个广告都可能是十几M的时代了，到处都是WIFI，手机流量都是好几个G的，手机流量看高清视频毫无压力，流量压缩技术现在看来有点像个笑话；</p><p><br /></p><p>APP横行，都是独立的app了，浏览器的形态很尴尬了，对于大多数用户来说现在的浏览器其实就是用来百度下的而已，看新闻我有专业的新闻app，看视频我有视频app，看漫画我有漫画app，听歌。。。</p><p><br /></p><p>手机厂商的突起，Jobs的苹果重行定义了手机，iphone确实很棒，安卓的开源+苹果的商业形式，软硬件结合使得国内的手机厂商异常多，对用户来说很棒，选择更多了，看你们竞争，小米，魅族，oppo，vivo等等等。。都有自己的os，那么很大一部分用户都使用的是自带的浏览器，（其实永俞在分享中有提到了这点，在用户--内容这一层上，下一个变更应该就是在操作系统上，更底下了的）</p><p><br /></p><p>网站的改变，响应式设计，之前还记得有wap站点的，现在都应该是响应式设计了，网站自动适配手机屏幕了的，这点感觉也让UC很尴尬</p><p><br /></p><p>UC对应的改变就是，从浏览器这种工具性的 转向了 内容聚合平台 的形态，这种转变是浏览器的形态的转变，目前市面上的浏览器大多数都是如此。</p><p><br /></p><a name=\"困扰\"></a><h1 id=\"1071ea26\">困扰</h1><p><br /></p><p>UC的做法是不是伤害了用户体验了？</p><p><br /></p><p>转变为内容聚合平台，在UC上可以看新闻，看视频，看小说，看漫画，可以搜索，可以玩游戏。。。他就是一个容器，或者更夸张的说就是一个操作系统，这是当年永福说的，这个概念就很像如今的小程序；但是用户来看，觉得一个浏览器而已，为啥干了这么多杂七杂八的事情呢？觉得UC浏览器越来越臃肿了；换句话说，如果UC能把这些功能做到极致了，能PK过那些原生APP了，用户可以只需要一个UC吗 ？尤其是现在容量也越来越不便宜了的 。。</p><p><br /></p><p>其实UC也意识到了这个问题，因为有这么一个浏览器 --  夸克浏览器，给搭建安利一下，纯工具形态的浏览器</p><p><br /></p><p>在这差异性越来越小的世界，UC该怎么走呢？</p><p><br /></p><p>浏览器的功能，说个不好听的的，大大小小的公司换个壳就是一个了的，核心优势没了，只能靠口碑活下去吗 ？ 问了身边的朋友，使用UC的原因就是因为从塞班时代就开始用了的，习惯了，但现在都快卸载了，这应该整个浏览器形态的思考转变吧</p><p><br /></p><a name=\"技术\"></a><h1 id=\"a95dd3e1\">技术</h1><p><br /></p><p>能翻到的资料不多，大致的流程和PC浏览器一致，UC浏览器在服务层做了一层解析排版</p><p><br /></p><p>1. DNS域名解析</p><p><br /></p><p>2. 获取IP和端口，建立连接</p><p><br /></p><p>3. 发送请求，这一层是不是先发给了UC还需要确定下</p><p><br /></p><p>4. 获取返回，UC服务层做了一层解析，让内容更好的适应手机屏幕</p><p><br /></p><p>5. 手机展示</p><p><br /></p><p>简单来说就是UC做了一层代理，让内容更符合手机的小屏幕；</p><p><br /></p><p>当然UC也有自己的核心技术的，不然怎么在市场上屹立这么久的呢</p><p><br /></p><a name=\"结尾\"></a><h1 id=\"d1fb6ef9\">结尾</h1><p><br /></p><p>现在提及UC，可能大家第一想到是UC震惊体，看到是UC越来越臃肿的样子</p><p><br /></p><p>不知道大家还记得当时那可爱的小松鼠吗 ？</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T11:52:07.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T11:52:07.000Z",
    "updated_at": "2019-04-16T11:52:07.000Z",
    "published_at": "2019-04-16T11:52:07.000Z",
    "first_published_at": null,
    "word_count": 1443,
    "cover": null,
    "description": "前言 UC浏览器的辉煌应该是我读大学（2008年）的时候，转眼间，十年过去了，庆幸的是UC还在，我从使用者变成了一名UC的员工。 以下都是个人的不负责任的猜想或者思考  变更 塞班时代 UC浏览器的地位可以说是巨无霸的存在，手机上必备软件之一，想必大多数那个时代的人和我一样在课堂上用UC看着N...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547326,
    "slug": "b356f787-caf4-4ef2-8b27-9eacdd24b4a8",
    "title": "浏览器工作原理",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "浏览器工作原理 - whendream - 博客园\n\n<a name=\"2b53097b\"></a>\n# 简要\n\n1. 输入域名，浏览器做简单的筛选判断\n  1. 默认为http协议，https的话需要手动输入\n2. DNS查询，获取IP地址\n  1. 先查自己内存里的DNS Cache\n  2. 再查本地硬盘里的host文件\n  3. 查询DNS服务\n3. 建立TCP/IP连接\n4. 发送HTTP请求\n5. 服务器处理\n6. 浏览器收到返回，解析展示\n\n<a name=\"5fbe0eac\"></a>\n# **一、DNS域名解析**\n\n我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器IP地址这项工作，是由DNS服务器来完成的。\n\n客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。一般用户很少去编辑修改hosts文件。\n\n![](https://pic2.zhimg.com/80/v2-416bfd2b649384a009976bcb2c4f1219_hd.jpg#align=left&display=inline&height=300&originHeight=300&originWidth=720&status=done&width=720)\n\n![](https://pic1.zhimg.com/80/v2-1d38e588d0bc9f00930d74ad6cc05840_hd.jpg#align=left&display=inline&height=428&originHeight=428&originWidth=720&status=done&width=720)\n\n浏览器客户端向本地DNS服务器发送一个含有域名http://www.cnblogs.com的DNS查询报文。本地DNS服务器把查询报文转发到根DNS服务器，根DNS服务器注意到其com后缀，于是向本地DNS服务器返回comDNS服务器的IP地址。本地DNS服务器再次向comDNS服务器发送查询请求，comDNS服务器注意到其http://www.cnblogs.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。最后，本地DNS服务器将含有http://www.cnblogs.com的IP地址的响应报文发送给客户端。\n\n> 从客户端到本地服务器属于递归查询，而DNS服务器之间的交互属于迭代查询。 正常情况下，本地DNS服务器的缓存中已有comDNS服务器的地址，因此请求根域名服务器这一步不是必需的。\n\n\n<a name=\"8dc2fd3e\"></a>\n# **二、建立TCP链接**\n\n费了一顿周折终于拿到服务器IP了，下一步自然就是链接到该服务器。对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。\n\n![](https://pic4.zhimg.com/80/v2-9d0b617437b5a922f69ebb4b14fd4817_hd.jpg#align=left&display=inline&height=331&originHeight=331&originWidth=592&status=done&width=592)\n\n客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。\n\n上图也可以这么理解：\n\n客户端：“你好，在家不，有你快递。”\n\n服务端：“在的，送来就行。”\n\n客户端：“好嘞。”\n\n<a name=\"e2dcf545\"></a>\n# **三、发送HTTP请求**\n\n与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：\n\n![](https://pic3.zhimg.com/80/v2-15578edbbea7f001a48e9a2f08590862_hd.jpg#align=left&display=inline&height=169&originHeight=169&originWidth=629&status=done&width=629)\n\n在浏览器中查看报文首部（以google浏览器为例）：\n\n![](https://pic2.zhimg.com/80/v2-e9816e5aa3c2c9ac73245840989e7e7d_hd.jpg#align=left&display=inline&height=273&originHeight=273&originWidth=366&status=done&width=366)\n\n请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。\n\n<a name=\"294f3bb7\"></a>\n# **四、服务器处理请求**\n\n服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。\n\n![](https://pic1.zhimg.com/80/v2-1aef730ace63059a5fcb3fec3910c868_hd.jpg#align=left&display=inline&height=211&originHeight=211&originWidth=720&status=done&width=720)\n\n<a name=\"49f8a551\"></a>\n# 五、返回响应结果\n\n在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：\n\n![](https://pic1.zhimg.com/80/v2-7f7b7097bbb7be0dac70196d87dd5820_hd.jpg#align=left&display=inline&height=168&originHeight=168&originWidth=625&status=done&width=625)\n\n在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。\n\n状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：\n\n![](https://pic4.zhimg.com/80/v2-39cd5feb2a3ce47e19348a5c8623c0ab_hd.jpg#align=left&display=inline&height=192&originHeight=192&originWidth=417&status=done&width=417)\n\n<a name=\"40967eee\"></a>\n# **六、关闭TCP连接**\n\n为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。\n\n![](https://pic3.zhimg.com/80/v2-1e480290f059ab57cf57aac6c1249a7e_hd.jpg#align=left&display=inline&height=374&originHeight=374&originWidth=489&status=done&width=489)\n\n_上图可以这么理解：_\n\n客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。”\n\n服务端：“收到，我看看我这边有木有数据了。”\n\n服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。”\n\n客户端：“好嘞。”\n\n<a name=\"50ce737e\"></a>\n# **七、浏览器解析HTML**\n\n准确地说，浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。\n\n浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。\n\n要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题，关于JS阻塞相关问题，这里不过多阐述,后面会单独开篇讲解。\n\n<a name=\"7361a8bf\"></a>\n# **八、浏览器布局渲染**\n\n根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。\n\nreplaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。\n\nreflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。 所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。\n\n最后浏览器绘制各个节点，将页面展示给用户。\n",
    "body_draft": "",
    "body_html": "<p>浏览器工作原理 - whendream - 博客园</p><p><br /></p><h1 id=\"2b53097b\">简要</h1><p><br /></p><ol start=\"1\"><li>输入域名，浏览器做简单的筛选判断</li></ol><ol start=\"1\" data-lake-indent=\"1\"><li>默认为http协议，https的话需要手动输入</li></ol><ol start=\"2\"><li>DNS查询，获取IP地址</li></ol><ol start=\"1\" data-lake-indent=\"1\"><li>先查自己内存里的DNS Cache</li></ol><ol start=\"2\" data-lake-indent=\"1\"><li>再查本地硬盘里的host文件</li></ol><ol start=\"3\" data-lake-indent=\"1\"><li>查询DNS服务</li></ol><ol start=\"3\"><li>建立TCP/IP连接</li></ol><ol start=\"4\"><li>发送HTTP请求</li></ol><ol start=\"5\"><li>服务器处理</li></ol><ol start=\"6\"><li>浏览器收到返回，解析展示</li></ol><p><br /></p><h1 id=\"5fbe0eac\"><strong>一、DNS域名解析</strong></h1><p><br /></p><p>我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器IP地址这项工作，是由DNS服务器来完成的。</p><p><br /></p><p>客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。一般用户很少去编辑修改hosts文件。</p><p><br /></p><p><img src=\"https://pic2.zhimg.com/80/v2-416bfd2b649384a009976bcb2c4f1219_hd.jpg#align=left&amp;display=inline&amp;height=300&amp;originHeight=300&amp;originWidth=720&amp;status=done&amp;width=720\" style=\"max-width: 600px; width: 720px;\" /></p><p><br /></p><p><img src=\"https://pic1.zhimg.com/80/v2-1d38e588d0bc9f00930d74ad6cc05840_hd.jpg#align=left&amp;display=inline&amp;height=428&amp;originHeight=428&amp;originWidth=720&amp;status=done&amp;width=720\" style=\"max-width: 600px; width: 720px;\" /></p><p><br /></p><p>浏览器客户端向本地DNS服务器发送一个含有域名http://www.cnblogs.com的DNS查询报文。本地DNS服务器把查询报文转发到根DNS服务器，根DNS服务器注意到其com后缀，于是向本地DNS服务器返回comDNS服务器的IP地址。本地DNS服务器再次向comDNS服务器发送查询请求，comDNS服务器注意到其http://www.cnblogs.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。最后，本地DNS服务器将含有http://www.cnblogs.com的IP地址的响应报文发送给客户端。</p><p><br /></p><blockquote><p>从客户端到本地服务器属于递归查询，而DNS服务器之间的交互属于迭代查询。 正常情况下，本地DNS服务器的缓存中已有comDNS服务器的地址，因此请求根域名服务器这一步不是必需的。</p></blockquote><p><br /></p><h1 id=\"8dc2fd3e\"><strong>二、建立TCP链接</strong></h1><p><br /></p><p>费了一顿周折终于拿到服务器IP了，下一步自然就是链接到该服务器。对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。</p><p><br /></p><p><img src=\"https://pic4.zhimg.com/80/v2-9d0b617437b5a922f69ebb4b14fd4817_hd.jpg#align=left&amp;display=inline&amp;height=331&amp;originHeight=331&amp;originWidth=592&amp;status=done&amp;width=592\" style=\"max-width: 600px; width: 592px;\" /></p><p><br /></p><p>客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。</p><p><br /></p><p>上图也可以这么理解：</p><p><br /></p><p>客户端：“你好，在家不，有你快递。”</p><p><br /></p><p>服务端：“在的，送来就行。”</p><p><br /></p><p>客户端：“好嘞。”</p><p><br /></p><h1 id=\"e2dcf545\"><strong>三、发送HTTP请求</strong></h1><p><br /></p><p>与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：</p><p><br /></p><p><img src=\"https://pic3.zhimg.com/80/v2-15578edbbea7f001a48e9a2f08590862_hd.jpg#align=left&amp;display=inline&amp;height=169&amp;originHeight=169&amp;originWidth=629&amp;status=done&amp;width=629\" style=\"max-width: 600px; width: 629px;\" /></p><p><br /></p><p>在浏览器中查看报文首部（以google浏览器为例）：</p><p><br /></p><p><img src=\"https://pic2.zhimg.com/80/v2-e9816e5aa3c2c9ac73245840989e7e7d_hd.jpg#align=left&amp;display=inline&amp;height=273&amp;originHeight=273&amp;originWidth=366&amp;status=done&amp;width=366\" style=\"max-width: 600px; width: 366px;\" /></p><p><br /></p><p>请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。</p><p><br /></p><h1 id=\"294f3bb7\"><strong>四、服务器处理请求</strong></h1><p><br /></p><p>服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p><p><br /></p><p><img src=\"https://pic1.zhimg.com/80/v2-1aef730ace63059a5fcb3fec3910c868_hd.jpg#align=left&amp;display=inline&amp;height=211&amp;originHeight=211&amp;originWidth=720&amp;status=done&amp;width=720\" style=\"max-width: 600px; width: 720px;\" /></p><p><br /></p><h1 id=\"49f8a551\">五、返回响应结果</h1><p><br /></p><p>在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：</p><p><br /></p><p><img src=\"https://pic1.zhimg.com/80/v2-7f7b7097bbb7be0dac70196d87dd5820_hd.jpg#align=left&amp;display=inline&amp;height=168&amp;originHeight=168&amp;originWidth=625&amp;status=done&amp;width=625\" style=\"max-width: 600px; width: 625px;\" /></p><p><br /></p><p>在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。</p><p><br /></p><p>状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：</p><p><br /></p><p><img src=\"https://pic4.zhimg.com/80/v2-39cd5feb2a3ce47e19348a5c8623c0ab_hd.jpg#align=left&amp;display=inline&amp;height=192&amp;originHeight=192&amp;originWidth=417&amp;status=done&amp;width=417\" style=\"max-width: 600px; width: 417px;\" /></p><p><br /></p><h1 id=\"40967eee\"><strong>六、关闭TCP连接</strong></h1><p><br /></p><p>为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。</p><p><br /></p><p><img src=\"https://pic3.zhimg.com/80/v2-1e480290f059ab57cf57aac6c1249a7e_hd.jpg#align=left&amp;display=inline&amp;height=374&amp;originHeight=374&amp;originWidth=489&amp;status=done&amp;width=489\" style=\"max-width: 600px; width: 489px;\" /></p><p><br /></p><p><em>上图可以这么理解：</em></p><p><br /></p><p>客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。”</p><p><br /></p><p>服务端：“收到，我看看我这边有木有数据了。”</p><p><br /></p><p>服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。”</p><p><br /></p><p>客户端：“好嘞。”</p><p><br /></p><h1 id=\"50ce737e\"><strong>七、浏览器解析HTML</strong></h1><p><br /></p><p>准确地说，浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。</p><p><br /></p><p>浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。</p><p><br /></p><p>要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题，关于JS阻塞相关问题，这里不过多阐述,后面会单独开篇讲解。</p><p><br /></p><h1 id=\"7361a8bf\"><strong>八、浏览器布局渲染</strong></h1><p><br /></p><p>根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。</p><p><br /></p><p>replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p><p><br /></p><p>reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。 所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。</p><p><br /></p><p>最后浏览器绘制各个节点，将页面展示给用户。</p>",
    "body_lake": "<!doctype lake><p>浏览器工作原理 - whendream - 博客园</p><p><br /></p><h1 id=\"2b53097b\">简要</h1><p><br /></p><ol start=\"1\"><li>输入域名，浏览器做简单的筛选判断</li></ol><ol start=\"1\" data-lake-indent=\"1\"><li>默认为http协议，https的话需要手动输入</li></ol><ol start=\"2\"><li>DNS查询，获取IP地址</li></ol><ol start=\"1\" data-lake-indent=\"1\"><li>先查自己内存里的DNS Cache</li></ol><ol start=\"2\" data-lake-indent=\"1\"><li>再查本地硬盘里的host文件</li></ol><ol start=\"3\" data-lake-indent=\"1\"><li>查询DNS服务</li></ol><ol start=\"3\"><li>建立TCP/IP连接</li></ol><ol start=\"4\"><li>发送HTTP请求</li></ol><ol start=\"5\"><li>服务器处理</li></ol><ol start=\"6\"><li>浏览器收到返回，解析展示</li></ol><p><br /></p><h1 id=\"5fbe0eac\"><strong>一、DNS域名解析</strong></h1><p><br /></p><p>我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器IP地址这项工作，是由DNS服务器来完成的。</p><p><br /></p><p>客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。一般用户很少去编辑修改hosts文件。</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fpic2.zhimg.com%2F80%2Fv2-416bfd2b649384a009976bcb2c4f1219_hd.jpg%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A300%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A720%2C%22height%22%3A300%7D\"></card></p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fpic1.zhimg.com%2F80%2Fv2-1d38e588d0bc9f00930d74ad6cc05840_hd.jpg%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A428%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A720%2C%22height%22%3A428%7D\"></card></p><p><br /></p><p>浏览器客户端向本地DNS服务器发送一个含有域名http://www.cnblogs.com的DNS查询报文。本地DNS服务器把查询报文转发到根DNS服务器，根DNS服务器注意到其com后缀，于是向本地DNS服务器返回comDNS服务器的IP地址。本地DNS服务器再次向comDNS服务器发送查询请求，comDNS服务器注意到其http://www.cnblogs.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。最后，本地DNS服务器将含有http://www.cnblogs.com的IP地址的响应报文发送给客户端。</p><p><br /></p><blockquote><p>从客户端到本地服务器属于递归查询，而DNS服务器之间的交互属于迭代查询。 正常情况下，本地DNS服务器的缓存中已有comDNS服务器的地址，因此请求根域名服务器这一步不是必需的。</p></blockquote><p><br /></p><h1 id=\"8dc2fd3e\"><strong>二、建立TCP链接</strong></h1><p><br /></p><p>费了一顿周折终于拿到服务器IP了，下一步自然就是链接到该服务器。对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fpic4.zhimg.com%2F80%2Fv2-9d0b617437b5a922f69ebb4b14fd4817_hd.jpg%22%2C%22originWidth%22%3A592%2C%22originHeight%22%3A331%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A592%2C%22height%22%3A331%7D\"></card></p><p><br /></p><p>客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。</p><p><br /></p><p>上图也可以这么理解：</p><p><br /></p><p>客户端：“你好，在家不，有你快递。”</p><p><br /></p><p>服务端：“在的，送来就行。”</p><p><br /></p><p>客户端：“好嘞。”</p><p><br /></p><h1 id=\"e2dcf545\"><strong>三、发送HTTP请求</strong></h1><p><br /></p><p>与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fpic3.zhimg.com%2F80%2Fv2-15578edbbea7f001a48e9a2f08590862_hd.jpg%22%2C%22originWidth%22%3A629%2C%22originHeight%22%3A169%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A629%2C%22height%22%3A169%7D\"></card></p><p><br /></p><p>在浏览器中查看报文首部（以google浏览器为例）：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fpic2.zhimg.com%2F80%2Fv2-e9816e5aa3c2c9ac73245840989e7e7d_hd.jpg%22%2C%22originWidth%22%3A366%2C%22originHeight%22%3A273%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A366%2C%22height%22%3A273%7D\"></card></p><p><br /></p><p>请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。</p><p><br /></p><h1 id=\"294f3bb7\"><strong>四、服务器处理请求</strong></h1><p><br /></p><p>服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fpic1.zhimg.com%2F80%2Fv2-1aef730ace63059a5fcb3fec3910c868_hd.jpg%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A211%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A720%2C%22height%22%3A211%7D\"></card></p><p><br /></p><h1 id=\"49f8a551\">五、返回响应结果</h1><p><br /></p><p>在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fpic1.zhimg.com%2F80%2Fv2-7f7b7097bbb7be0dac70196d87dd5820_hd.jpg%22%2C%22originWidth%22%3A625%2C%22originHeight%22%3A168%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A625%2C%22height%22%3A168%7D\"></card></p><p><br /></p><p>在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。</p><p><br /></p><p>状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fpic4.zhimg.com%2F80%2Fv2-39cd5feb2a3ce47e19348a5c8623c0ab_hd.jpg%22%2C%22originWidth%22%3A417%2C%22originHeight%22%3A192%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A417%2C%22height%22%3A192%7D\"></card></p><p><br /></p><h1 id=\"40967eee\"><strong>六、关闭TCP连接</strong></h1><p><br /></p><p>为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fpic3.zhimg.com%2F80%2Fv2-1e480290f059ab57cf57aac6c1249a7e_hd.jpg%22%2C%22originWidth%22%3A489%2C%22originHeight%22%3A374%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A489%2C%22height%22%3A374%7D\"></card></p><p><br /></p><p><em>上图可以这么理解：</em></p><p><br /></p><p>客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。”</p><p><br /></p><p>服务端：“收到，我看看我这边有木有数据了。”</p><p><br /></p><p>服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。”</p><p><br /></p><p>客户端：“好嘞。”</p><p><br /></p><h1 id=\"50ce737e\"><strong>七、浏览器解析HTML</strong></h1><p><br /></p><p>准确地说，浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。</p><p><br /></p><p>浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。</p><p><br /></p><p>要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题，关于JS阻塞相关问题，这里不过多阐述,后面会单独开篇讲解。</p><p><br /></p><h1 id=\"7361a8bf\"><strong>八、浏览器布局渲染</strong></h1><p><br /></p><p>根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。</p><p><br /></p><p>replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p><p><br /></p><p>reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。 所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。</p><p><br /></p><p>最后浏览器绘制各个节点，将页面展示给用户。<cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T11:50:32.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T11:50:05.000Z",
    "updated_at": "2019-07-06T14:10:35.000Z",
    "published_at": "2019-04-16T11:50:32.000Z",
    "first_published_at": null,
    "word_count": 1667,
    "cover": null,
    "description": "浏览器工作原理 - whendream - 博客园简要输入域名，浏览器做简单的筛选判断默认为http协议，https的话需要手动输入DNS查询，获取IP地址先查自己内存里的DNS Cache再查本地硬盘里的host文件查询DNS服务建立TCP/IP连接发送HTTP请求服务器处理浏览器收到返回，...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547313,
    "slug": "93bcca58-d062-43ab-9dd1-f279c89ffe40",
    "title": "iTerm2连接远程-中文乱码问题",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "# 现象\nmac 上用是iterm2终端, Shell 环境是zsh。\n\nssh 到Linux 服务器上查看一些文件时，中文乱码。  这种情况一般是终端和服务器的字符集不匹配，MacOSX下默认的是utf8字符集。\n\niterm2本地显示中文正常，但ssh到服务端发现中文乱码\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555415235863-d2ac29ee-4825-402d-9147-ec93c5f3edfa.png)\n\n# 解决方法\n输入locale可以查看字符编码设置情况，而我的对应值是空的。  而默认的.zshrc没有设置为utf-8编码，所以本地和服务器端都要在.zshrc设置，步骤如下，(bash对应.bash\\_profile或.bashrc文件)。\n\n1.在终端下输入  \nvim ~/.zshrc\n\n2.在文件内容末端添加：\n\n```\nexport LC\\_ALL=en\\_US.UTF-8 \nexport LANG\\=en\\_US.UTF-8\n```\n接着重启一下终端，或者输入source ~/.zshrc使设置生效。  \n连接服务器，中文显示都正常了。\n\n  \n\\---------------------  \n作者：大道泛兮  \n来源：CSDN  \n原文：https://blog.csdn.net/u013931660/article/details/79443037  \n版权声明：本文为博主原创文章，转载请附上博文链接！",
    "body_draft": "",
    "body_html": "<a name=\"现象\"></a><h1 id=\"a047b772\">现象</h1><p><br /></p><p>mac 上用是iterm2终端, Shell 环境是zsh。</p><p><br /></p><p>ssh 到Linux 服务器上查看一些文件时，中文乱码。 <br />\n这种情况一般是终端和服务器的字符集不匹配，MacOSX下默认的是utf8字符集。</p><p><br /></p><p>iterm2本地显示中文正常，但ssh到服务端发现中文乱码</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555415235863-d2ac29ee-4825-402d-9147-ec93c5f3edfa.png#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><a name=\"解决方法\"></a><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p>输入locale可以查看字符编码设置情况，而我的对应值是空的。 <br />\n而默认的.zshrc没有设置为utf-8编码，所以本地和服务器端都要在.zshrc设置，步骤如下，(bash对应.bash_profile或.bashrc文件)。</p><p><br /></p><p>1.在终端下输入<br />\nvim ~/.zshrc</p><p><br /></p><p>2.在文件内容末端添加：</p><p><br /></p><pre><code>export LC\\_ALL=en\\_US.UTF-8 \nexport LANG\\=en\\_US.UTF-8</code></pre><p><br /></p><p>接着重启一下终端，或者输入source ~/.zshrc使设置生效。<br />\n连接服务器，中文显示都正常了。</p><p><br /></p><p>---------------------<br />\n作者：大道泛兮<br />\n来源：CSDN<br />\n原文：<a href=\"https://blog.csdn.net/u013931660/article/details/79443037\" target=\"_blank\">https://blog.csdn.net/u013931660/article/details/79443037</a><br />\n版权声明：本文为博主原创文章，转载请附上博文链接！</p>",
    "body_lake": "<!doctype lake><a name=\"现象\"></a><h1 id=\"a047b772\">现象</h1><p><br /></p><p>mac 上用是iterm2终端, Shell 环境是zsh。</p><p><br /></p><p>ssh 到Linux 服务器上查看一些文件时，中文乱码。 <br />\n这种情况一般是终端和服务器的字符集不匹配，MacOSX下默认的是utf8字符集。</p><p><br /></p><p>iterm2本地显示中文正常，但ssh到服务端发现中文乱码</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555415235863-d2ac29ee-4825-402d-9147-ec93c5f3edfa.png%22%2C%22alt%22%3A%22%22%7D\"></card></p><p><br /></p><a name=\"解决方法\"></a><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p>输入locale可以查看字符编码设置情况，而我的对应值是空的。 <br />\n而默认的.zshrc没有设置为utf-8编码，所以本地和服务器端都要在.zshrc设置，步骤如下，(bash对应.bash_profile或.bashrc文件)。</p><p><br /></p><p>1.在终端下输入<br />\nvim ~/.zshrc</p><p><br /></p><p>2.在文件内容末端添加：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22dbda92a7%22%2C%22code%22%3A%22export%20LC%5C%5C_ALL%3Den%5C%5C_US.UTF-8%20%5Cnexport%20LANG%5C%5C%3Den%5C%5C_US.UTF-8%22%7D\"></card><p><br /></p><p>接着重启一下终端，或者输入source ~/.zshrc使设置生效。<br />\n连接服务器，中文显示都正常了。</p><p><br /></p><p>---------------------<br />\n作者：大道泛兮<br />\n来源：CSDN<br />\n原文：<a href=\"https://blog.csdn.net/u013931660/article/details/79443037\" target=\"_blank\">https://blog.csdn.net/u013931660/article/details/79443037</a><br />\n版权声明：本文为博主原创文章，转载请附上博文链接！</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T11:48:00.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T11:48:00.000Z",
    "updated_at": "2019-04-16T11:48:00.000Z",
    "published_at": "2019-04-16T11:48:00.000Z",
    "first_published_at": null,
    "word_count": 257,
    "cover": null,
    "description": "现象 mac 上用是iterm2终端, Shell 环境是zsh。 ssh 到Linux 服务器上查看一些文件时，中文乱码。  这种情况一般是终端和服务器的字符集不匹配，MacOSX下默认的是utf8字符集。 iterm2本地显示中文正常，但ssh到服务端发现中文乱码   解决方法 输入loc...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547306,
    "slug": "044f0f6b-81b3-4615-b28a-0d0d97fa462c",
    "title": "jar包获取资源文件",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8e1b944f\"></a>\n# 背景\n写的一个spring boot项目打成jar包部署运行下，打成jar包，提示找不到资源文件，如下图：\n\n![](https://cdn.nlark.com/yuque/0/2019/png/92887/1555415069829-61e77f52-aaea-4403-93fd-060b5b1ccf1c.png#align=left&display=inline&height=103&originHeight=208&originWidth=1506&status=done&width=746)\n\n直接通过idea是可以运行的，但打成jar包后提示找不到资源文件，简单查阅后了解到是因为jar包在读取文件的方式不一致导致的\n\n<a name=\"094c47ac\"></a>\n# 问题分析\n先定位到哪行代码出错，如下：\n\nURI configurationFileURI = this.getClass().getClassLoader().getResource(CONFIGURATION_FILE).toURI();\n\n这里报错，提示getResource为null。\n\n原因如下：\n\n**在jar文件中查找资源和在文件系统中查找资源的方式是不一样的**\n\n错误的加载方式：\n\nXXX.calss.getResource(path)<br />\nXXX.calss.getClassLoader().getResource(path)\n\n正确的加载方式：\n\nXXX.class.getResourceAsStream(path)<br />\nXXX.calss.getClassLoader().getResourceAsStream(path)\n\n以流的方式来加载\n\n<a name=\"957a228f\"></a>\n# 解决方法\n\n知道了根本原因了，就简单了，将之前getResource这种方式改成getResourceAsStream方法\n\n具体代码如下：\n\n```java\nInputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(CONFIGURATION_FILE);\nBufferedReader br = new BufferedReader(new InputStreamReader(resourceAsStream));\n\nString s = \"\";\nList lines = new ArrayList();\nwhile ((s = br.readLine()) != null) {\nlines.add(s);\n}\n// 关闭流\nresourceAsStream.close();\nbr.close();\n```\n\n<a name=\"7187e4d5\"></a>\n# 简单总结\n\n1. 在jar文件中查找资源和在文件系统中查找资源的方式是不一样的\n2. jar包是一个单独的文件而非文件夹，绝对不可能通过\"file:/e:/.../ResourceJar.jar/resource/res.txt\"这种形式的文件URL来定位资源文件\n3. public InputStream getResourceAsStream(String name); 返回读取指定资源的输入流。这个方法很重要，可以直接获得jar包中文件的内容。\n\n<a name=\"35808e79\"></a>\n# 参考资料\n[http://hxraid.iteye.com/blog/483115](http://hxraid.iteye.com/blog/483115)\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8e1b944f\">背景</h1><p>写的一个spring boot项目打成jar包部署运行下，打成jar包，提示找不到资源文件，如下图：</p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/92887/1555415069829-61e77f52-aaea-4403-93fd-060b5b1ccf1c.png#align=left&amp;display=inline&amp;height=103&amp;originHeight=208&amp;originWidth=1506&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><p>直接通过idea是可以运行的，但打成jar包后提示找不到资源文件，简单查阅后了解到是因为jar包在读取文件的方式不一致导致的</p><p><br /></p><h1 id=\"094c47ac\">问题分析</h1><p>先定位到哪行代码出错，如下：</p><p><br /></p><p>URI configurationFileURI = this.getClass().getClassLoader().getResource(CONFIGURATION_FILE).toURI();</p><p><br /></p><p>这里报错，提示getResource为null。</p><p><br /></p><p>原因如下：</p><p><br /></p><p><strong>在jar文件中查找资源和在文件系统中查找资源的方式是不一样的</strong></p><p><br /></p><p>错误的加载方式：</p><p><br /></p><p>XXX.calss.getResource(path)<br />\nXXX.calss.getClassLoader().getResource(path)</p><p><br /></p><p>正确的加载方式：</p><p><br /></p><p>XXX.class.getResourceAsStream(path)<br />\nXXX.calss.getClassLoader().getResourceAsStream(path)</p><p><br /></p><p>以流的方式来加载</p><p><br /></p><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p>知道了根本原因了，就简单了，将之前getResource这种方式改成getResourceAsStream方法</p><p><br /></p><p>具体代码如下：</p><p><br /></p><pre data-lang=\"java\"><code>InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(CONFIGURATION_FILE);\nBufferedReader br = new BufferedReader(new InputStreamReader(resourceAsStream));\n\nString s = &quot;&quot;;\nList lines = new ArrayList();\nwhile ((s = br.readLine()) != null) {\nlines.add(s);\n}\n// 关闭流\nresourceAsStream.close();\nbr.close();</code></pre><p><br /></p><h1 id=\"7187e4d5\">简单总结</h1><ol start=\"1\"><li>在jar文件中查找资源和在文件系统中查找资源的方式是不一样的</li></ol><ol start=\"2\"><li>jar包是一个单独的文件而非文件夹，绝对不可能通过&quot;file:/e:/.../ResourceJar.jar/resource/res.txt&quot;这种形式的文件URL来定位资源文件</li></ol><ol start=\"3\"><li>public InputStream getResourceAsStream(String name); 返回读取指定资源的输入流。这个方法很重要，可以直接获得jar包中文件的内容。</li></ol><p><br /></p><h1 id=\"35808e79\">参考资料</h1><p><a href=\"http://hxraid.iteye.com/blog/483115\" target=\"_blank\">http://hxraid.iteye.com/blog/483115</a></p>",
    "body_lake": "<!doctype lake><h1 id=\"8e1b944f\">背景</h1><p>写的一个spring boot项目打成jar包部署运行下，打成jar包，提示找不到资源文件，如下图：</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F92887%2F1555415069829-61e77f52-aaea-4403-93fd-060b5b1ccf1c.png%22%2C%22originWidth%22%3A1506%2C%22originHeight%22%3A208%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A103%7D\"></card></p><p><br /></p><p>直接通过idea是可以运行的，但打成jar包后提示找不到资源文件，简单查阅后了解到是因为jar包在读取文件的方式不一致导致的</p><p><br /></p><h1 id=\"094c47ac\">问题分析</h1><p>先定位到哪行代码出错，如下：</p><p><br /></p><p>URI configurationFileURI = this.getClass().getClassLoader().getResource(CONFIGURATION_FILE).toURI();</p><p><br /></p><p>这里报错，提示getResource为null。</p><p><br /></p><p>原因如下：</p><p><br /></p><p><strong>在jar文件中查找资源和在文件系统中查找资源的方式是不一样的</strong></p><p><br /></p><p>错误的加载方式：</p><p><br /></p><p>XXX.calss.getResource(path)<br />\nXXX.calss.getClassLoader().getResource(path)</p><p><br /></p><p>正确的加载方式：</p><p><br /></p><p>XXX.class.getResourceAsStream(path)<br />\nXXX.calss.getClassLoader().getResourceAsStream(path)</p><p><br /></p><p>以流的方式来加载</p><p><br /></p><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p>知道了根本原因了，就简单了，将之前getResource这种方式改成getResourceAsStream方法</p><p><br /></p><p>具体代码如下：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22InputStream%20resourceAsStream%20%3D%20this.getClass().getClassLoader().getResourceAsStream(CONFIGURATION_FILE)%3B%5CnBufferedReader%20br%20%3D%20new%20BufferedReader(new%20InputStreamReader(resourceAsStream))%3B%5Cn%5CnString%20s%20%3D%20%5C%22%5C%22%3B%5CnList%20lines%20%3D%20new%20ArrayList()%3B%5Cnwhile%20((s%20%3D%20br.readLine())%20!%3D%20null)%20%7B%5Cnlines.add(s)%3B%5Cn%7D%5Cn%2F%2F%20%E5%85%B3%E9%97%AD%E6%B5%81%5CnresourceAsStream.close()%3B%5Cnbr.close()%3B%22%2C%22id%22%3A%22UAEcg%22%7D\"></card><p><cursor /><br /></p><h1 id=\"7187e4d5\">简单总结</h1><ol start=\"1\"><li>在jar文件中查找资源和在文件系统中查找资源的方式是不一样的</li></ol><ol start=\"2\"><li>jar包是一个单独的文件而非文件夹，绝对不可能通过&quot;file:/e:/.../ResourceJar.jar/resource/res.txt&quot;这种形式的文件URL来定位资源文件</li></ol><ol start=\"3\"><li>public InputStream getResourceAsStream(String name); 返回读取指定资源的输入流。这个方法很重要，可以直接获得jar包中文件的内容。</li></ol><p><br /></p><h1 id=\"35808e79\">参考资料</h1><p><a href=\"http://hxraid.iteye.com/blog/483115\" target=\"_blank\">http://hxraid.iteye.com/blog/483115</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T11:46:46.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T11:46:03.000Z",
    "updated_at": "2019-04-16T11:46:46.000Z",
    "published_at": "2019-04-16T11:46:46.000Z",
    "first_published_at": null,
    "word_count": 400,
    "cover": null,
    "description": "背景写的一个spring boot项目打成jar包部署运行下，打成jar包，提示找不到资源文件，如下图：直接通过idea是可以运行的，但打成jar包后提示找不到资源文件，简单查阅后了解到是因为jar包在读取文件的方式不一致导致的问题分析先定位到哪行代码出错，如下：URI configurati...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547295,
    "slug": "91d88f71-baac-44a7-bf9a-0ec2bf976642",
    "title": "ip网段变更",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8e1b944f\"></a>\n# 背景\n\n公司网络跟集团靠拢，先走第一步：IP网段变更。从XX网段切换到OO网段\n\n<a name=\"ea340b9d\"></a>\n# 方法\n\n1. 准备工作\n  1. 保证IPMI连接正常\n  1. 获得新IP并核对对应主机名、旧IP是否相符\n\n2. 确认网卡名称\n\n#找到目前配置旧业务IP的活动网卡,如eth0，以各机器实际使用网卡为准,本文以eth0为例\n\nifconfig\n\n3. 修改配置文件\n\n#修改网卡配置文件\n\nvim /etc/sysconfig/network-scripts/ifcfg-eth0\n\nGATEWAY=\"111.11.1.1\" #修改为分配的新网关\n\nIPADDR=\"111.11.1.8\" #修改为分配的新IP\n\nNETMASK=\"255.255.255.55\" #修改为分配的新掩码\n\n#修改网络配置文件\n\nvim /etc/sysconfig/network\n\nGATEWAY=111.11.1.1 #修改为分配的新网关\n\n4. 重启网络服务\n\nservice network restart\n\n5. 修改DNS服务IP（如有需要）\n\n#cat /etc/resolv.conf<br />\nnameserver 新ip<br />\nnameserver 新ip\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>公司网络跟集团靠拢，先走第一步：IP网段变更。从XX网段切换到OO网段</p><p><br /></p><h1 id=\"ea340b9d\">方法</h1><p><br /></p><ol start=\"1\"><li>准备工作</li></ol><ol data-lake-indent=\"1\"><li>保证IPMI连接正常</li><li>获得新IP并核对对应主机名、旧IP是否相符</li></ol><p><br /></p><ol start=\"2\"><li>确认网卡名称</li></ol><p><br /></p><p style=\"text-indent: 2em;\">#找到目前配置旧业务IP的活动网卡,如eth0，以各机器实际使用网卡为准,本文以eth0为例</p><p><br /></p><p style=\"text-indent: 2em;\">ifconfig</p><p><br /></p><ol start=\"3\"><li>修改配置文件</li></ol><p><br /></p><p>#修改网卡配置文件</p><p><br /></p><p>vim /etc/sysconfig/network-scripts/ifcfg-eth0</p><p><br /></p><p>GATEWAY=&quot;111.11.1.1&quot; #修改为分配的新网关</p><p><br /></p><p>IPADDR=&quot;111.11.1.8&quot; #修改为分配的新IP</p><p><br /></p><p>NETMASK=&quot;255.255.255.55&quot; #修改为分配的新掩码</p><p><br /></p><p>#修改网络配置文件</p><p><br /></p><p>vim /etc/sysconfig/network</p><p><br /></p><p>GATEWAY=111.11.1.1 #修改为分配的新网关</p><p><br /></p><ol start=\"4\"><li>重启网络服务</li></ol><p><br /></p><p>service network restart</p><p><br /></p><ol start=\"5\"><li>修改DNS服务IP（如有需要）</li></ol><p><br /></p><p>#cat /etc/resolv.conf<br />\nnameserver 新ip<br />\nnameserver 新ip</p>",
    "body_lake": "<!doctype lake><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>公司网络跟集团靠拢，先走第一步：IP网段变更。从XX网段切换到OO网段</p><p><br /></p><h1 id=\"ea340b9d\">方法</h1><p><br /></p><ol start=\"1\"><li>准备工作</li></ol><ol data-lake-indent=\"1\"><li>保证IPMI连接正常</li><li>获得新IP并核对对应主机名、旧IP是否相符</li></ol><p><br /></p><ol start=\"2\"><li>确认网卡名称</li></ol><p><br /></p><p style=\"text-indent: 2em;\">#找到目前配置旧业务IP的活动网卡,如eth0，以各机器实际使用网卡为准,本文以eth0为例</p><p><br /></p><p style=\"text-indent: 2em;\">ifconfig</p><p><br /></p><ol start=\"3\"><li>修改配置文件</li></ol><p><br /></p><p>#修改网卡配置文件</p><p><br /></p><p>vim /etc/sysconfig/network-scripts/ifcfg-eth0</p><p><br /></p><p>GATEWAY=&quot;111.11.1.1&quot; #修改为分配的新网关</p><p><br /></p><p>IPADDR=&quot;111.11.1.8&quot; #修改为分配的新IP</p><p><br /></p><p>NETMASK=&quot;255.255.255.55&quot; #修改为分配的新掩码</p><p><br /></p><p>#修改网络配置文件</p><p><br /></p><p>vim /etc/sysconfig/network</p><p><br /></p><p>GATEWAY=111.11.1.1 #修改为分配的新网关</p><p><br /></p><ol start=\"4\"><li>重启网络服务</li></ol><p><br /></p><p>service network restart</p><p><br /></p><ol start=\"5\"><li>修改DNS服务IP（如有需要）<cursor /></li></ol><p><br /></p><p>#cat /etc/resolv.conf<br />\nnameserver 新ip<br />\nnameserver 新ip</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T11:44:05.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T11:42:38.000Z",
    "updated_at": "2019-04-16T11:44:05.000Z",
    "published_at": "2019-04-16T11:44:05.000Z",
    "first_published_at": null,
    "word_count": 226,
    "cover": null,
    "description": "背景公司网络跟集团靠拢，先走第一步：IP网段变更。从XX网段切换到OO网段方法准备工作保证IPMI连接正常获得新IP并核对对应主机名、旧IP是否相符确认网卡名称#找到目前配置旧业务IP的活动网卡,如eth0，以各机器实际使用网卡为准,本文以eth0为例ifconfig修改配置文件#修改网卡配置...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1547294,
    "slug": "54742f45-3b7d-4289-a0e4-3030b4e3f0de",
    "title": "adb错误 - INSTALL_FAILED_NO_MATCHING_ABIS",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "# 背景\n换组啦，去了UC国际浏览器，被拥抱变化了。还在熟悉阶段，尝试了下adb，然后就碰到了这个INSTALL\\_FAILED\\_NO\\_MATCHING\\_ABIS的坑。。。\n\n# 解决方法\n`INSTALL_FAILED_NO_MATCHING_ABIS` is when you are trying to install an app that has native libraries and it doesn't have a native library for your cpu architecture. For example if you compiled an app for _armv7_ and are trying to install it on an emulator that uses the _Intel_ architecture instead it will not work.\n\n了解大概原理：应用使用了原生库（NDK，Native Lib），这些库的编译目标通常是arm架构的cpu，在x86的模拟器上运行就会报这样的错误。\n\n知道原因了就简单了，新建一个arm架构的模拟器，蛋疼的是这种模拟器卡的要死，无法工作\n\n# 后续\n这个问题的排查其实很快就找到原因了的，但实际解决还是隔了一天。\n\n第一个是：因为太卡了，没有耐心等待手机模拟器的打开，adb install命令也没有耐心等待；\n\n第二个是：在新建arm架构的模拟器的时候，as提示我不建议创建arm架构的，强烈建议使用x86的，最初定位还以为因为系统是64位的而新建的是32位的cpu的问题，导致还是去创建了一个X64的模拟器\n\n# 参考资料\nhttps://stackoverflow.com/questions/24572052/install-failed-no-matching-abis-when-install-apk  \nhttps://juejin.im/post/5a30dca7f265da4324807033",
    "body_draft": "",
    "body_html": "<a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>换组啦，去了UC国际浏览器，被拥抱变化了。还在熟悉阶段，尝试了下adb，然后就碰到了这个INSTALL_FAILED_NO_MATCHING_ABIS的坑。。。</p><p><br /></p><a name=\"解决方法\"></a><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p><code>INSTALL_FAILED_NO_MATCHING_ABIS</code> is when you are trying to install an app that has native libraries and it doesn't have a native library for your cpu architecture. For example if you compiled an app for <em>armv7</em> and are trying to install it on an emulator that uses the <em>Intel</em> architecture instead it will not work.</p><p><br /></p><p>了解大概原理：应用使用了原生库（NDK，Native Lib），这些库的编译目标通常是arm架构的cpu，在x86的模拟器上运行就会报这样的错误。</p><p><br /></p><p>知道原因了就简单了，新建一个arm架构的模拟器，蛋疼的是这种模拟器卡的要死，无法工作</p><p><br /></p><a name=\"后续\"></a><h1 id=\"9c58068f\">后续</h1><p><br /></p><p>这个问题的排查其实很快就找到原因了的，但实际解决还是隔了一天。</p><p><br /></p><p>第一个是：因为太卡了，没有耐心等待手机模拟器的打开，adb install命令也没有耐心等待；</p><p><br /></p><p>第二个是：在新建arm架构的模拟器的时候，as提示我不建议创建arm架构的，强烈建议使用x86的，最初定位还以为因为系统是64位的而新建的是32位的cpu的问题，导致还是去创建了一个X64的模拟器</p><p><br /></p><a name=\"参考资料\"></a><h1 id=\"35808e79\">参考资料</h1><p><br /></p><p><a href=\"https://stackoverflow.com/questions/24572052/install-failed-no-matching-abis-when-install-apk\" target=\"_blank\">https://stackoverflow.com/questions/24572052/install-failed-no-matching-abis-when-install-apk</a><br />\n<a href=\"https://juejin.im/post/5a30dca7f265da4324807033\" target=\"_blank\">https://juejin.im/post/5a30dca7f265da4324807033</a></p>",
    "body_lake": "<!doctype lake><a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>换组啦，去了UC国际浏览器，被拥抱变化了。还在熟悉阶段，尝试了下adb，然后就碰到了这个INSTALL_FAILED_NO_MATCHING_ABIS的坑。。。</p><p><br /></p><a name=\"解决方法\"></a><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p><code>INSTALL_FAILED_NO_MATCHING_ABIS</code> is when you are trying to install an app that has native libraries and it doesn't have a native library for your cpu architecture. For example if you compiled an app for <em>armv7</em> and are trying to install it on an emulator that uses the <em>Intel</em> architecture instead it will not work.</p><p><br /></p><p>了解大概原理：应用使用了原生库（NDK，Native Lib），这些库的编译目标通常是arm架构的cpu，在x86的模拟器上运行就会报这样的错误。</p><p><br /></p><p>知道原因了就简单了，新建一个arm架构的模拟器，蛋疼的是这种模拟器卡的要死，无法工作</p><p><br /></p><a name=\"后续\"></a><h1 id=\"9c58068f\">后续</h1><p><br /></p><p>这个问题的排查其实很快就找到原因了的，但实际解决还是隔了一天。</p><p><br /></p><p>第一个是：因为太卡了，没有耐心等待手机模拟器的打开，adb install命令也没有耐心等待；</p><p><br /></p><p>第二个是：在新建arm架构的模拟器的时候，as提示我不建议创建arm架构的，强烈建议使用x86的，最初定位还以为因为系统是64位的而新建的是32位的cpu的问题，导致还是去创建了一个X64的模拟器</p><p><br /></p><a name=\"参考资料\"></a><h1 id=\"35808e79\">参考资料</h1><p><br /></p><p><a href=\"https://stackoverflow.com/questions/24572052/install-failed-no-matching-abis-when-install-apk\" target=\"_blank\">https://stackoverflow.com/questions/24572052/install-failed-no-matching-abis-when-install-apk</a><br />\n<a href=\"https://juejin.im/post/5a30dca7f265da4324807033\" target=\"_blank\">https://juejin.im/post/5a30dca7f265da4324807033</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T11:41:52.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T11:41:52.000Z",
    "updated_at": "2019-04-16T11:41:52.000Z",
    "published_at": "2019-04-16T11:41:52.000Z",
    "first_published_at": null,
    "word_count": 361,
    "cover": null,
    "description": "背景 换组啦，去了UC国际浏览器，被拥抱变化了。还在熟悉阶段，尝试了下adb，然后就碰到了这个INSTALL_FAILED_NO_MATCHING_ABIS的坑。。。  解决方法 INSTALL_FAILED_NO_MATCHING_ABIS is when you are trying to...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1545693,
    "slug": "1c5e5472-7931-4203-adb9-0d1b2af913a3",
    "title": "play framework - 初识",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8e1b944f\"></a>\n# 背景\n\n研发代码框架是play-framework框架，想看代码的话，需要学习下play框架。IDE工具的话之前一直用的idea，所以本文涉及的idea play的配置 和 一些play的简单知识\n\n<a name=\"3fb2f32d\"></a>\n# 认识play\n\n百度百科如下：\n\n> play framework是一个full-stack（全栈的）Java Web的应用框架，包括一个简单的无状态MVC模型，具有Hibernate的对象持续，一个基于Groovy的[模板引擎](https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/907667)，以及建立一个现代Web应用所需的所有东西。\n\n\n前提是安装jdk，play也分两个大的版本，1.X和2.X，跟着我们这版研发版本走，使用的1.4.4版本\n\n<a name=\"dbabf722\"></a>\n## play安装\n\n使用的是mac，理论上可以支持brew安装的，但我期望的安装低版本的，直接下载bin包来配置。\n\n1. 下载\n<br />play的下载地址：[https://www.playframework.com/releases](https://www.playframework.com/releases)\n<br />选择下载自己期望的版本\n2. 配置环境变量\n<br />配置一个play的home目录即可，添加到path中，如下：<br />\n![](https://img2018.cnblogs.com/blog/411616/201812/411616-20181215172752409-994205794.png#align=left&display=inline&height=146&originHeight=218&originWidth=1076&status=done&width=720)\n3. 测试\n<br />配置完记得source下，直接执行play，就可以看到效果<br />\n![](https://img2018.cnblogs.com/blog/411616/201812/411616-20181215172807313-1837231567.png#align=left&display=inline&height=411&originHeight=562&originWidth=984&status=done&width=720)\n\n<a name=\"a4e6c251\"></a>\n## play-framework 依赖管理\n\n之前熟悉了maven来管理jar包的依赖，play是通过dependencies.yml文件来管理依赖的，直接执行play dependencies命令的话，就会更新下载依赖，目前只要掌握这个命令即可\n\n可以直接参考https://blog.csdn.net/twx843571091/article/details/50037393\n\n<a name=\"4929ab60\"></a>\n## idea配置\n\nidea支持1.X版本的play了的，不需要额外配置，但是要简单执行一个命令，进入到项目目录，执行`play idea`会生成一个ipr文件，然后idea打开这个ipr文件即可\n\n![](https://img2018.cnblogs.com/blog/411616/201812/411616-20181215172820837-378201831.png#align=left&display=inline&height=434&originHeight=520&originWidth=894&status=done&width=746)\n\n有play的jar包和playFramework Dependencies表示是play项目\n\n<a name=\"12f1d7ef\"></a>\n# 结束\n历史原因选择了play框架，知道后续新的应用都是走的spring boot。。。\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>研发代码框架是play-framework框架，想看代码的话，需要学习下play框架。IDE工具的话之前一直用的idea，所以本文涉及的idea play的配置 和 一些play的简单知识</p><p><br /></p><h1 id=\"3fb2f32d\">认识play</h1><p><br /></p><p>百度百科如下：</p><p><br /></p><blockquote><p>play framework是一个full-stack（全栈的）Java Web的应用框架，包括一个简单的无状态MVC模型，具有Hibernate的对象持续，一个基于Groovy的<a href=\"https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/907667\" target=\"_blank\">模板引擎</a>，以及建立一个现代Web应用所需的所有东西。</p></blockquote><p><br /></p><p>前提是安装jdk，play也分两个大的版本，1.X和2.X，跟着我们这版研发版本走，使用的1.4.4版本</p><p><br /></p><h2 id=\"dbabf722\">play安装</h2><p><br /></p><p>使用的是mac，理论上可以支持brew安装的，但我期望的安装低版本的，直接下载bin包来配置。</p><p><br /></p><ol start=\"1\"><li>下载\n<br />play的下载地址：<a href=\"https://www.playframework.com/releases\" target=\"_blank\">https://www.playframework.com/releases</a>\n<br />选择下载自己期望的版本</li></ol><ol start=\"2\"><li>配置环境变量\n<br />配置一个play的home目录即可，添加到path中，如下：<br />\n<img src=\"https://img2018.cnblogs.com/blog/411616/201812/411616-20181215172752409-994205794.png#align=left&amp;display=inline&amp;height=146&amp;originHeight=218&amp;originWidth=1076&amp;status=done&amp;width=720\" style=\"max-width: 600px; width: 720px;\" /></li></ol><ol start=\"3\"><li>测试\n<br />配置完记得source下，直接执行play，就可以看到效果<br />\n<img src=\"https://img2018.cnblogs.com/blog/411616/201812/411616-20181215172807313-1837231567.png#align=left&amp;display=inline&amp;height=411&amp;originHeight=562&amp;originWidth=984&amp;status=done&amp;width=720\" style=\"max-width: 600px; width: 720px;\" /></li></ol><p><br /></p><h2 id=\"a4e6c251\">play-framework 依赖管理</h2><p><br /></p><p>之前熟悉了maven来管理jar包的依赖，play是通过dependencies.yml文件来管理依赖的，直接执行play dependencies命令的话，就会更新下载依赖，目前只要掌握这个命令即可</p><p><br /></p><p>可以直接参考https://blog.csdn.net/twx843571091/article/details/50037393</p><p><br /></p><h2 id=\"4929ab60\">idea配置</h2><p><br /></p><p>idea支持1.X版本的play了的，不需要额外配置，但是要简单执行一个命令，进入到项目目录，执行<code>play idea</code>会生成一个ipr文件，然后idea打开这个ipr文件即可</p><p><br /></p><p><img src=\"https://img2018.cnblogs.com/blog/411616/201812/411616-20181215172820837-378201831.png#align=left&amp;display=inline&amp;height=434&amp;originHeight=520&amp;originWidth=894&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><p>有play的jar包和playFramework Dependencies表示是play项目</p><p><br /></p><h1 id=\"12f1d7ef\">结束</h1><p>历史原因选择了play框架，知道后续新的应用都是走的spring boot。。。</p>",
    "body_lake": "<!doctype lake><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>研发代码框架是play-framework框架，想看代码的话，需要学习下play框架。IDE工具的话之前一直用的idea，所以本文涉及的idea play的配置 和 一些play的简单知识</p><p><br /></p><h1 id=\"3fb2f32d\">认识play</h1><p><br /></p><p>百度百科如下：</p><p><br /></p><blockquote><p>play framework是一个full-stack（全栈的）Java Web的应用框架，包括一个简单的无状态MVC模型，具有Hibernate的对象持续，一个基于Groovy的<a href=\"https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/907667\" target=\"_blank\">模板引擎</a>，以及建立一个现代Web应用所需的所有东西。</p></blockquote><p><br /></p><p>前提是安装jdk，play也分两个大的版本，1.X和2.X，跟着我们这版研发版本走，使用的1.4.4版本</p><p><br /></p><h2 id=\"dbabf722\">play安装</h2><p><br /></p><p>使用的是mac，理论上可以支持brew安装的，但我期望的安装低版本的，直接下载bin包来配置。</p><p><br /></p><ol start=\"1\"><li>下载\n<br />play的下载地址：<a href=\"https://www.playframework.com/releases\" target=\"_blank\">https://www.playframework.com/releases</a>\n<br />选择下载自己期望的版本</li></ol><ol start=\"2\"><li>配置环境变量\n<br />配置一个play的home目录即可，添加到path中，如下：<br />\n<card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F411616%2F201812%2F411616-20181215172752409-994205794.png%22%2C%22originWidth%22%3A1076%2C%22originHeight%22%3A218%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A720%2C%22height%22%3A146%7D\"></card></li></ol><ol start=\"3\"><li>测试\n<br />配置完记得source下，直接执行play，就可以看到效果<br />\n<card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F411616%2F201812%2F411616-20181215172807313-1837231567.png%22%2C%22originWidth%22%3A984%2C%22originHeight%22%3A562%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A720%2C%22height%22%3A411%7D\"></card></li></ol><p><br /></p><h2 id=\"a4e6c251\">play-framework 依赖管理</h2><p><br /></p><p>之前熟悉了maven来管理jar包的依赖，play是通过dependencies.yml文件来管理依赖的，直接执行play dependencies命令的话，就会更新下载依赖，目前只要掌握这个命令即可</p><p><br /></p><p>可以直接参考https://blog.csdn.net/twx843571091/article/details/50037393</p><p><br /></p><h2 id=\"4929ab60\">idea配置</h2><p><br /></p><p>idea支持1.X版本的play了的，不需要额外配置，但是要简单执行一个命令，进入到项目目录，执行<code>play idea</code>会生成一个ipr文件，然后idea打开这个ipr文件即可</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F411616%2F201812%2F411616-20181215172820837-378201831.png%22%2C%22originWidth%22%3A894%2C%22originHeight%22%3A520%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A434%7D\"></card></p><p><br /></p><p>有play的jar包和playFramework Dependencies表示是play项目</p><p><br /></p><h1 id=\"12f1d7ef\">结束<cursor /></h1><p>历史原因选择了play框架，知道后续新的应用都是走的spring boot。。。</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T08:37:00.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T08:36:42.000Z",
    "updated_at": "2019-04-16T08:37:00.000Z",
    "published_at": "2019-04-16T08:37:00.000Z",
    "first_published_at": null,
    "word_count": 463,
    "cover": null,
    "description": "背景研发代码框架是play-framework框架，想看代码的话，需要学习下play框架。IDE工具的话之前一直用的idea，所以本文涉及的idea play的配置 和 一些play的简单知识认识play百度百科如下：play framework是一个full-stack（全栈的）Java W...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1545504,
    "slug": "lqmdoz",
    "title": "php基础语法（持续更新）",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"array_chunk\"></a>\n# array_chunk\n将一个数组分割成多个\n\n<a name=\"f411d0f1\"></a>\n## 说明\n```php\narray_chunk ( array $array , int $size [, bool $preserve_keys = false ] ) : array\n```\n\n将一个数组分割成多个数组，其中每个数组的单元数目由 size 决定。最后一个数组的单元数目可能会少于 size 个。\n\n<a name=\"226b5276\"></a>\n## 参数  \narray<br />需要操作的数组<br />size<br />每个数组的单元数目<br />preserve_keys<br />设为 TRUE，可以使 PHP 保留输入数组中原来的键名。如果你指定了 FALSE，那每个结果数组将用从零开始的新数字索引。默认值是 FALSE。\n\n<a name=\"Xvblj\"></a>\n# md5_file\n计算指定文件的 MD5 散列值，支持stream即远程文件<br />md5_file在计算前用fopen打开，读取数据，然后做计算，远程open超时了<br />这个也是走的系统的配置php.ini<br />default_socket_timeout = 60\n\n<a name=\"e7sCQ\"></a>\n# get_headers\nget_headers — 取得服务器响应一个 HTTP 请求所发送的所有标头\n<a name=\"zjwFG\"></a>\n### 说明[ ](https://www.php.net/manual/zh/function.get-headers.php#refsect1-function.get-headers-description)\n**get_headers** ( string `$url` [, int `$format` = 0 ] ) : array<br />**get_headers()** 返回一个数组，包含有服务器响应一个 HTTP 请求所发送的标头。\n<a name=\"x72XJ\"></a>\n### 参数[ ](https://www.php.net/manual/zh/function.get-headers.php#refsect1-function.get-headers-parameters)\n`url`<br />目标 URL。<br />`format`<br />如果将可选的 `format` 参数设为 1，则 **get_headers()** 会解析相应的信息并设定数组的键名。\n<a name=\"lwJJ0\"></a>\n### 返回值[ ](https://www.php.net/manual/zh/function.get-headers.php#refsect1-function.get-headers-returnvalues)\n返回包含有服务器响应一个 HTTP 请求所发送标头的索引或关联数组，如果失败则返回 **`FALSE`**。\n\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"array_chunk\">array_chunk</h1><p>将一个数组分割成多个</p><p><br /></p><h2 id=\"f411d0f1\">说明</h2><pre data-lang=\"php\"><code>array_chunk ( array $array , int $size [, bool $preserve_keys = false ] ) : array</code></pre><p><br /></p><p>将一个数组分割成多个数组，其中每个数组的单元数目由 size 决定。最后一个数组的单元数目可能会少于 size 个。</p><p><br /></p><h2 id=\"226b5276\">参数  </h2><p>array</p><p>需要操作的数组</p><p>size</p><p>每个数组的单元数目</p><p>preserve_keys</p><p>设为 TRUE，可以使 PHP 保留输入数组中原来的键名。如果你指定了 FALSE，那每个结果数组将用从零开始的新数字索引。默认值是 FALSE。</p><p><br /></p><h1 id=\"Xvblj\">md5_file</h1><p>计算指定文件的 MD5 散列值，支持stream即远程文件</p><p><span style=\"color: #191F25;\">md5_file在计算前用fopen打开，读取数据，然后做计算，远程open超时了</span></p><p><span style=\"color: #191F25;\">这个也是走的</span><span>系统的配置php.ini</span></p><p><span>default_socket_timeout = 60</span></p><p><span><br /></span></p><h1 id=\"e7sCQ\">get_headers</h1><p><span>get_headers</span> — <span>取得服务器响应一个 HTTP 请求所发送的所有标头</span></p><h3 id=\"zjwFG\">说明<a href=\"https://www.php.net/manual/zh/function.get-headers.php#refsect1-function.get-headers-description\" target=\"_blank\"> </a></h3><p><strong>get_headers</strong> ( <span style=\"color: #669933;\">string</span> <code>$url</code> [, <span style=\"color: #669933;\">int</span> <code>$format</code><span style=\"color: #993366;\"> = 0</span> ] ) : <span style=\"color: #669933;\">array</span></p><p><strong>get_headers()</strong> 返回一个数组，包含有服务器响应一个 HTTP 请求所发送的标头。</p><h3 id=\"x72XJ\">参数<a href=\"https://www.php.net/manual/zh/function.get-headers.php#refsect1-function.get-headers-parameters\" target=\"_blank\"> </a></h3><p><code>url</code></p><p>目标 URL。</p><p><code>format</code></p><p>如果将可选的 <code>format</code> 参数设为 1，则 <strong>get_headers()</strong> 会解析相应的信息并设定数组的键名。</p><h3 id=\"lwJJ0\">返回值<a href=\"https://www.php.net/manual/zh/function.get-headers.php#refsect1-function.get-headers-returnvalues\" target=\"_blank\"> </a></h3><p>返回包含有服务器响应一个 HTTP 请求所发送标头的索引或关联数组，如果失败则返回 <strong><code>FALSE</code></strong>。</p><p><span><br /></span></p><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"array_chunk\">array_chunk</h1><p>将一个数组分割成多个</p><p><br /></p><h2 id=\"f411d0f1\">说明</h2><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22php%22%2C%22code%22%3A%22array_chunk%20(%20array%20%24array%20%2C%20int%20%24size%20%5B%2C%20bool%20%24preserve_keys%20%3D%20false%20%5D%20)%20%3A%20array%22%2C%22id%22%3A%22pS4Sv%22%7D\"></card><p><br /></p><p>将一个数组分割成多个数组，其中每个数组的单元数目由 size 决定。最后一个数组的单元数目可能会少于 size 个。</p><p><br /></p><h2 id=\"226b5276\">参数  </h2><p>array</p><p>需要操作的数组</p><p>size</p><p>每个数组的单元数目</p><p>preserve_keys</p><p>设为 TRUE，可以使 PHP 保留输入数组中原来的键名。如果你指定了 FALSE，那每个结果数组将用从零开始的新数字索引。默认值是 FALSE。</p><p><br /></p><h1 id=\"Xvblj\">md5_file</h1><p>计算指定文件的 MD5 散列值，支持stream即远程文件</p><p><span style=\"color: #191F25;\">md5_file在计算前用fopen打开，读取数据，然后做计算，远程open超时了</span></p><p><span style=\"color: #191F25;\">这个也是走的</span><span>系统的配置php.ini</span></p><p><span>default_socket_timeout = 60</span></p><p><span><br /></span></p><h1 id=\"e7sCQ\">get_headers</h1><p><span>get_headers</span> — <span>取得服务器响应一个 HTTP 请求所发送的所有标头</span></p><h3 id=\"zjwFG\">说明<a href=\"https://www.php.net/manual/zh/function.get-headers.php#refsect1-function.get-headers-description\" target=\"_blank\"> <cursor /></a></h3><p><strong>get_headers</strong> ( <span style=\"color: #669933;\">string</span> <code>$url</code> [, <span style=\"color: #669933;\">int</span> <code>$format</code><span style=\"color: #993366;\"> = 0</span> ] ) : <span style=\"color: #669933;\">array</span></p><p><strong>get_headers()</strong> 返回一个数组，包含有服务器响应一个 HTTP 请求所发送的标头。</p><h3 id=\"x72XJ\">参数<a href=\"https://www.php.net/manual/zh/function.get-headers.php#refsect1-function.get-headers-parameters\" target=\"_blank\"> </a></h3><p><code>url</code></p><p>目标 URL。</p><p><code>format</code></p><p>如果将可选的 <code>format</code> 参数设为 1，则 <strong>get_headers()</strong> 会解析相应的信息并设定数组的键名。</p><h3 id=\"lwJJ0\">返回值<a href=\"https://www.php.net/manual/zh/function.get-headers.php#refsect1-function.get-headers-returnvalues\" target=\"_blank\"> </a></h3><p>返回包含有服务器响应一个 HTTP 请求所发送标头的索引或关联数组，如果失败则返回 <strong><code>FALSE</code></strong>。</p><p><span><br /></span></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-05-27T07:14:21.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T08:19:09.000Z",
    "updated_at": "2019-05-27T07:14:21.000Z",
    "published_at": "2019-05-27T07:14:21.000Z",
    "first_published_at": "2019-04-16T08:22:38.000Z",
    "word_count": 346,
    "cover": null,
    "description": "array_chunk将一个数组分割成多个说明array_chunk ( array $array , int $size [, bool $preserve_keys = false ] ) : array将一个数组分割成多个数组，其中每个数组的单元数目由 size 决定。最后一个数组的单元...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1545269,
    "slug": "85a90280-18c8-4429-ba8a-5c49e54094d4",
    "title": "源自KPI交谈的思考",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "> 说明白一件事情不容易\n\n# 前言\n跟领导谈及下半年KPI的时候，问我什么打算/计划，在交谈过程中，有几个有意思的点\n\n# 问题\nQ: 目标是hold住服务端，那么怎么样才算hold住服务端?\n\nQ: 如何推动别人去做一件事\n\nQ: 如何表达/阐述一件事情\n\n# 想说\n很多问题都当做理所当然，没有深入挖掘，局限于自己的视角。自以为hold住了服务端，但别人怎么看待呢？在别人眼里，你可能只是做了应该做的事情，并没有达到掌控全场的能力。如，现在有个大坑，你来了往里面填了东西，坑填了不少，但这能说明你hold住了吗？只能说明了做了一些事情，有一些效果。能hold住的话，表示有风险掌控能力，能减低风险的出现/大小，能减低风险带来的影响！当你有了整个项目/产品的风险掌控能力就是表示你能hold整个项目/产品；\n\n推动别人做一件事情，这件事情对于别人来说都是有成本的，即使这个事情对大家都能带来好处。单从我的角度出来：这件事情是符合上层要求的，是你们应该要做的，应该要做的事情的话，那么就要推动下去；现在问题变成了你认为要做的事情，别人不一定是这么任务的，对别人来说是有成本/风险的，别人会拒绝，不好推动。那么问题变成了如何将应该变成一定，这件事是你们必须做的。根据现状提出要求，目前是这样子，你们必须这么做才能扭转现状\n\n表达阐述一件事情，我们做的任何一件事情，都是有目的/目标的。不要把手段当做是目标。如做监控的目的是降低风险，而不是为了做监控而做监控，因此你的目标并不是完成多少监控，而是把风险降低；\n\n# 后文\n文笔不佳，表达凌乱。所以为什么作家叫作家...",
    "body_draft": "",
    "body_html": "<blockquote><p>说明白一件事情不容易</p></blockquote><p><br /></p><a name=\"前言\"></a><h1 id=\"df368884\">前言</h1><p><br /></p><p>跟领导谈及下半年KPI的时候，问我什么打算/计划，在交谈过程中，有几个有意思的点</p><p><br /></p><a name=\"问题\"></a><h1 id=\"5dc99f6e\">问题</h1><p><br /></p><p>Q: 目标是hold住服务端，那么怎么样才算hold住服务端?</p><p><br /></p><p>Q: 如何推动别人去做一件事</p><p><br /></p><p>Q: 如何表达/阐述一件事情</p><p><br /></p><a name=\"想说\"></a><h1 id=\"9790618a\">想说</h1><p><br /></p><p>很多问题都当做理所当然，没有深入挖掘，局限于自己的视角。自以为hold住了服务端，但别人怎么看待呢？在别人眼里，你可能只是做了应该做的事情，并没有达到掌控全场的能力。如，现在有个大坑，你来了往里面填了东西，坑填了不少，但这能说明你hold住了吗？只能说明了做了一些事情，有一些效果。能hold住的话，表示有风险掌控能力，能减低风险的出现/大小，能减低风险带来的影响！当你有了整个项目/产品的风险掌控能力就是表示你能hold整个项目/产品；</p><p><br /></p><p>推动别人做一件事情，这件事情对于别人来说都是有成本的，即使这个事情对大家都能带来好处。单从我的角度出来：这件事情是符合上层要求的，是你们应该要做的，应该要做的事情的话，那么就要推动下去；现在问题变成了你认为要做的事情，别人不一定是这么任务的，对别人来说是有成本/风险的，别人会拒绝，不好推动。那么问题变成了如何将应该变成一定，这件事是你们必须做的。根据现状提出要求，目前是这样子，你们必须这么做才能扭转现状</p><p><br /></p><p>表达阐述一件事情，我们做的任何一件事情，都是有目的/目标的。不要把手段当做是目标。如做监控的目的是降低风险，而不是为了做监控而做监控，因此你的目标并不是完成多少监控，而是把风险降低；</p><p><br /></p><a name=\"后文\"></a><h1 id=\"946a4254\">后文</h1><p><br /></p><p>文笔不佳，表达凌乱。所以为什么作家叫作家...</p>",
    "body_lake": "<!doctype lake><blockquote><p>说明白一件事情不容易</p></blockquote><p><br /></p><a name=\"前言\"></a><h1 id=\"df368884\">前言</h1><p><br /></p><p>跟领导谈及下半年KPI的时候，问我什么打算/计划，在交谈过程中，有几个有意思的点</p><p><br /></p><a name=\"问题\"></a><h1 id=\"5dc99f6e\">问题</h1><p><br /></p><p>Q: 目标是hold住服务端，那么怎么样才算hold住服务端?</p><p><br /></p><p>Q: 如何推动别人去做一件事</p><p><br /></p><p>Q: 如何表达/阐述一件事情</p><p><br /></p><a name=\"想说\"></a><h1 id=\"9790618a\">想说</h1><p><br /></p><p>很多问题都当做理所当然，没有深入挖掘，局限于自己的视角。自以为hold住了服务端，但别人怎么看待呢？在别人眼里，你可能只是做了应该做的事情，并没有达到掌控全场的能力。如，现在有个大坑，你来了往里面填了东西，坑填了不少，但这能说明你hold住了吗？只能说明了做了一些事情，有一些效果。能hold住的话，表示有风险掌控能力，能减低风险的出现/大小，能减低风险带来的影响！当你有了整个项目/产品的风险掌控能力就是表示你能hold整个项目/产品；</p><p><br /></p><p>推动别人做一件事情，这件事情对于别人来说都是有成本的，即使这个事情对大家都能带来好处。单从我的角度出来：这件事情是符合上层要求的，是你们应该要做的，应该要做的事情的话，那么就要推动下去；现在问题变成了你认为要做的事情，别人不一定是这么任务的，对别人来说是有成本/风险的，别人会拒绝，不好推动。那么问题变成了如何将应该变成一定，这件事是你们必须做的。根据现状提出要求，目前是这样子，你们必须这么做才能扭转现状</p><p><br /></p><p>表达阐述一件事情，我们做的任何一件事情，都是有目的/目标的。不要把手段当做是目标。如做监控的目的是降低风险，而不是为了做监控而做监控，因此你的目标并不是完成多少监控，而是把风险降低；</p><p><br /></p><a name=\"后文\"></a><h1 id=\"946a4254\">后文</h1><p><br /></p><p>文笔不佳，表达凌乱。所以为什么作家叫作家...</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T07:55:55.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T07:55:55.000Z",
    "updated_at": "2019-05-30T13:46:05.000Z",
    "published_at": "2019-04-16T07:55:55.000Z",
    "first_published_at": null,
    "word_count": 565,
    "cover": null,
    "description": "说明白一件事情不容易   前言 跟领导谈及下半年KPI的时候，问我什么打算/计划，在交谈过程中，有几个有意思的点  问题 Q: 目标是hold住服务端，那么怎么样才算hold住服务端? Q: 如何推动别人去做一件事 Q: 如何表达/阐述一件事情  想说 很多问题都当做理所当然，没有深入挖掘，局...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1545261,
    "slug": "7f3d5881-64f4-468a-8164-408ffe71f539",
    "title": "spring项目读取配置的demo",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "markdown",
    "body": "# 背景\n读取配置是基础能力，研发这个模式不错，可以从不同配置中读取数据，如下图：  \n![](https://img2018.cnblogs.com/blog/411616/201901/411616-20190105115713584-54200896.png)  \n可以根据不同分类的文件来管理配置，然后统一在conf中配置哪些文件\n\n    package com.jwen.platform.config;\n    \n    import com.jwen.platform.exception.AppConfigurationException;\n    \n    import java.io.BufferedReader;\n    import java.io.IOException;\n    import java.io.InputStream;\n    import java.io.InputStreamReader;\n    import java.net.URISyntaxException;\n    import java.util.ArrayList;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    import java.util.regex.Pattern;\n    \n    public enum Configurations {\n        INSTANCE;\n    \n        private final static String KEY_VALUE_SEPARATOR = \"=\";\n        private final static String CONFIGURATION_FILE = \"application.conf\";\n        private final static String OTHER_CONFIGURATION_FILE_KEY = \"app_include_file\";\n    \n        private List<String> otherConfigurationFiles = new ArrayList<>();\n        private Map<String, String> configurations = new HashMap<>();\n    \n        Configurations() {\n            try {\n                init();\n            } catch (IOException | URISyntaxException e) {\n                throw new AppConfigurationException(\"has error in your application.conf\", e);\n            }\n        }\n    \n        private void init() throws IOException, URISyntaxException {\n    \n            InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(CONFIGURATION_FILE);\n            BufferedReader br = new BufferedReader(new InputStreamReader(resourceAsStream));\n    \n            String s = \"\";\n            List<String> lines = new ArrayList<String>();\n    \n            while ((s = br.readLine()) != null) {\n                lines.add(s);\n            }\n    \n            \n            resourceAsStream.close();\n            br.close();\n    \n            initConfigurations(lines);\n            initOtherConfigurations();\n    \n        }\n    \n        private void initOtherConfigurations() throws URISyntaxException, IOException {\n            for (String fileName : otherConfigurationFiles) {\n                InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(fileName);\n                BufferedReader br = new BufferedReader(new InputStreamReader(resourceAsStream));\n    \n    \n                String s = \"\";\n                List<String> lines = new ArrayList<String>();\n    \n                while ((s = br.readLine()) != null) {\n                    lines.add(s);\n                }\n    \n                \n                resourceAsStream.close();\n                br.close();\n    \n    \n                initConfigurations(lines);\n            }\n    \n            otherConfigurationFiles = null;\n        }\n    \n        private boolean isOtherConfigurationKey(String key) {\n            return OTHER_CONFIGURATION_FILE_KEY.equalsIgnoreCase(key);\n        }\n    \n        private void initConfigurations(List<String> lines) throws URISyntaxException, IOException {\n            lines.stream().forEach(line -> {\n                int keyValueSeparatorIndex = line.indexOf(KEY_VALUE_SEPARATOR);\n                if (isLegalConfigurationLine(line)) {\n                    String key = line.substring(0, keyValueSeparatorIndex).trim();\n                    String value = line.substring(keyValueSeparatorIndex + 1, line.length()).trim();\n                    if (isOtherConfigurationKey(key)) {\n                        otherConfigurationFiles.add(value);\n                    } else {\n                        configurations.put(key, value);\n                    }\n                }\n            });\n        }\n    \n        private boolean isLegalConfigurationLine(String line) {\n            Pattern pattern = Pattern.compile(\"^[a-zA-Z](.*?)=(.*?)\");\n            return pattern.matcher(line).matches();\n        }\n    \n    \n        public String get(String key) {\n            return configurations.get(key);\n        }\n    \n        public static void main(String[] args) {\n    \n            System.out.println(Configurations.INSTANCE.get(\"test.on\"));\n        }\n    }",
    "body_draft": "",
    "body_html": "<a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>读取配置是基础能力，研发这个模式不错，可以从不同配置中读取数据，如下图：<br />\n<img src=\"https://img2018.cnblogs.com/blog/411616/201901/411616-20190105115713584-54200896.png#alt=\" style=\"max-width: 600px;\" /><br />\n可以根据不同分类的文件来管理配置，然后统一在conf中配置哪些文件</p><p><br /></p><pre><code>package com.jwen.platform.config;\n\nimport com.jwen.platform.exception.AppConfigurationException;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\npublic enum Configurations {\n    INSTANCE;\n\n    private final static String KEY_VALUE_SEPARATOR = &quot;=&quot;;\n    private final static String CONFIGURATION_FILE = &quot;application.conf&quot;;\n    private final static String OTHER_CONFIGURATION_FILE_KEY = &quot;app_include_file&quot;;\n\n    private List&lt;String&gt; otherConfigurationFiles = new ArrayList&lt;&gt;();\n    private Map&lt;String, String&gt; configurations = new HashMap&lt;&gt;();\n\n    Configurations() {\n        try {\n            init();\n        } catch (IOException | URISyntaxException e) {\n            throw new AppConfigurationException(&quot;has error in your application.conf&quot;, e);\n        }\n    }\n\n    private void init() throws IOException, URISyntaxException {\n\n        InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(CONFIGURATION_FILE);\n        BufferedReader br = new BufferedReader(new InputStreamReader(resourceAsStream));\n\n        String s = &quot;&quot;;\n        List&lt;String&gt; lines = new ArrayList&lt;String&gt;();\n\n        while ((s = br.readLine()) != null) {\n            lines.add(s);\n        }\n\n        \n        resourceAsStream.close();\n        br.close();\n\n        initConfigurations(lines);\n        initOtherConfigurations();\n\n    }\n\n    private void initOtherConfigurations() throws URISyntaxException, IOException {\n        for (String fileName : otherConfigurationFiles) {\n            InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(fileName);\n            BufferedReader br = new BufferedReader(new InputStreamReader(resourceAsStream));\n\n\n            String s = &quot;&quot;;\n            List&lt;String&gt; lines = new ArrayList&lt;String&gt;();\n\n            while ((s = br.readLine()) != null) {\n                lines.add(s);\n            }\n\n            \n            resourceAsStream.close();\n            br.close();\n\n\n            initConfigurations(lines);\n        }\n\n        otherConfigurationFiles = null;\n    }\n\n    private boolean isOtherConfigurationKey(String key) {\n        return OTHER_CONFIGURATION_FILE_KEY.equalsIgnoreCase(key);\n    }\n\n    private void initConfigurations(List&lt;String&gt; lines) throws URISyntaxException, IOException {\n        lines.stream().forEach(line -&gt; {\n            int keyValueSeparatorIndex = line.indexOf(KEY_VALUE_SEPARATOR);\n            if (isLegalConfigurationLine(line)) {\n                String key = line.substring(0, keyValueSeparatorIndex).trim();\n                String value = line.substring(keyValueSeparatorIndex + 1, line.length()).trim();\n                if (isOtherConfigurationKey(key)) {\n                    otherConfigurationFiles.add(value);\n                } else {\n                    configurations.put(key, value);\n                }\n            }\n        });\n    }\n\n    private boolean isLegalConfigurationLine(String line) {\n        Pattern pattern = Pattern.compile(&quot;^[a-zA-Z](.*?)=(.*?)&quot;);\n        return pattern.matcher(line).matches();\n    }\n\n\n    public String get(String key) {\n        return configurations.get(key);\n    }\n\n    public static void main(String[] args) {\n\n        System.out.println(Configurations.INSTANCE.get(&quot;test.on&quot;));\n    }\n}</code></pre>",
    "body_lake": "<!doctype lake><a name=\"背景\"></a><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>读取配置是基础能力，研发这个模式不错，可以从不同配置中读取数据，如下图：<br />\n<card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F411616%2F201901%2F411616-20190105115713584-54200896.png%22%2C%22alt%22%3A%22%22%7D\"></card><br />\n可以根据不同分类的文件来管理配置，然后统一在conf中配置哪些文件</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%224d33cf13%22%2C%22code%22%3A%22package%20com.jwen.platform.config%3B%5Cn%5Cnimport%20com.jwen.platform.exception.AppConfigurationException%3B%5Cn%5Cnimport%20java.io.BufferedReader%3B%5Cnimport%20java.io.IOException%3B%5Cnimport%20java.io.InputStream%3B%5Cnimport%20java.io.InputStreamReader%3B%5Cnimport%20java.net.URISyntaxException%3B%5Cnimport%20java.util.ArrayList%3B%5Cnimport%20java.util.HashMap%3B%5Cnimport%20java.util.List%3B%5Cnimport%20java.util.Map%3B%5Cnimport%20java.util.regex.Pattern%3B%5Cn%5Cnpublic%20enum%20Configurations%20%7B%5Cn%20%20%20%20INSTANCE%3B%5Cn%5Cn%20%20%20%20private%20final%20static%20String%20KEY_VALUE_SEPARATOR%20%3D%20%5C%22%3D%5C%22%3B%5Cn%20%20%20%20private%20final%20static%20String%20CONFIGURATION_FILE%20%3D%20%5C%22application.conf%5C%22%3B%5Cn%20%20%20%20private%20final%20static%20String%20OTHER_CONFIGURATION_FILE_KEY%20%3D%20%5C%22app_include_file%5C%22%3B%5Cn%5Cn%20%20%20%20private%20List%3CString%3E%20otherConfigurationFiles%20%3D%20new%20ArrayList%3C%3E()%3B%5Cn%20%20%20%20private%20Map%3CString%2C%20String%3E%20configurations%20%3D%20new%20HashMap%3C%3E()%3B%5Cn%5Cn%20%20%20%20Configurations()%20%7B%5Cn%20%20%20%20%20%20%20%20try%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20init()%3B%5Cn%20%20%20%20%20%20%20%20%7D%20catch%20(IOException%20%7C%20URISyntaxException%20e)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20throw%20new%20AppConfigurationException(%5C%22has%20error%20in%20your%20application.conf%5C%22%2C%20e)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20private%20void%20init()%20throws%20IOException%2C%20URISyntaxException%20%7B%5Cn%5Cn%20%20%20%20%20%20%20%20InputStream%20resourceAsStream%20%3D%20this.getClass().getClassLoader().getResourceAsStream(CONFIGURATION_FILE)%3B%5Cn%20%20%20%20%20%20%20%20BufferedReader%20br%20%3D%20new%20BufferedReader(new%20InputStreamReader(resourceAsStream))%3B%5Cn%5Cn%20%20%20%20%20%20%20%20String%20s%20%3D%20%5C%22%5C%22%3B%5Cn%20%20%20%20%20%20%20%20List%3CString%3E%20lines%20%3D%20new%20ArrayList%3CString%3E()%3B%5Cn%5Cn%20%20%20%20%20%20%20%20while%20((s%20%3D%20br.readLine())%20!%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20lines.add(s)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20resourceAsStream.close()%3B%5Cn%20%20%20%20%20%20%20%20br.close()%3B%5Cn%5Cn%20%20%20%20%20%20%20%20initConfigurations(lines)%3B%5Cn%20%20%20%20%20%20%20%20initOtherConfigurations()%3B%5Cn%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20private%20void%20initOtherConfigurations()%20throws%20URISyntaxException%2C%20IOException%20%7B%5Cn%20%20%20%20%20%20%20%20for%20(String%20fileName%20%3A%20otherConfigurationFiles)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20InputStream%20resourceAsStream%20%3D%20this.getClass().getClassLoader().getResourceAsStream(fileName)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20BufferedReader%20br%20%3D%20new%20BufferedReader(new%20InputStreamReader(resourceAsStream))%3B%5Cn%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20String%20s%20%3D%20%5C%22%5C%22%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20List%3CString%3E%20lines%20%3D%20new%20ArrayList%3CString%3E()%3B%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20while%20((s%20%3D%20br.readLine())%20!%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20lines.add(s)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20resourceAsStream.close()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20br.close()%3B%5Cn%5Cn%5Cn%20%20%20%20%20%20%20%20%20%20%20%20initConfigurations(lines)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%20%20%20%20otherConfigurationFiles%20%3D%20null%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20private%20boolean%20isOtherConfigurationKey(String%20key)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20OTHER_CONFIGURATION_FILE_KEY.equalsIgnoreCase(key)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20private%20void%20initConfigurations(List%3CString%3E%20lines)%20throws%20URISyntaxException%2C%20IOException%20%7B%5Cn%20%20%20%20%20%20%20%20lines.stream().forEach(line%20-%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20int%20keyValueSeparatorIndex%20%3D%20line.indexOf(KEY_VALUE_SEPARATOR)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(isLegalConfigurationLine(line))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20String%20key%20%3D%20line.substring(0%2C%20keyValueSeparatorIndex).trim()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20String%20value%20%3D%20line.substring(keyValueSeparatorIndex%20%2B%201%2C%20line.length()).trim()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20(isOtherConfigurationKey(key))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20otherConfigurationFiles.add(value)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20configurations.put(key%2C%20value)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20private%20boolean%20isLegalConfigurationLine(String%20line)%20%7B%5Cn%20%20%20%20%20%20%20%20Pattern%20pattern%20%3D%20Pattern.compile(%5C%22%5E%5Ba-zA-Z%5D(.*%3F)%3D(.*%3F)%5C%22)%3B%5Cn%20%20%20%20%20%20%20%20return%20pattern.matcher(line).matches()%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%5Cn%20%20%20%20public%20String%20get(String%20key)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20configurations.get(key)%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%5Cn%5Cn%20%20%20%20%20%20%20%20System.out.println(Configurations.INSTANCE.get(%5C%22test.on%5C%22))%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%7D\"></card>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T07:54:56.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T07:54:56.000Z",
    "updated_at": "2019-04-16T07:54:56.000Z",
    "published_at": "2019-04-16T07:54:56.000Z",
    "first_published_at": null,
    "word_count": 414,
    "cover": null,
    "description": "背景 读取配置是基础能力，研发这个模式不错，可以从不同配置中读取数据，如下图：  可以根据不同分类的文件来管理配置，然后统一在conf中配置哪些文件 package com.jwen.platform.config;  import com.jwen.platform.exception.Ap...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1545241,
    "slug": "9613cf15-4151-465b-8f2b-dc4d7b489cb6",
    "title": "python安装mysql-python依赖包",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8e1b944f\"></a>\n# 背景\n新公司，对换工作了！接口自动化使用的是python的behave框架，因此需要折腾python了，而公司配的笔记本是windows的，因此要在windows下折腾python了\n\n<a name=\"52b36576\"></a>\n# 步骤\n项目中使用的setup.py文件来管理依赖的，通过ide直接安装依赖的时候提供mysql-python安装失败，如下\n\nMySQLdb/_mysql.c(29) : fatal error C1083: Cannot open include file: 'mysql.h': No such file or directory\n\n还有其他的各种错误，一顿google最后还是解决了\n\n1. 安装wheel，通过pip install wheel安装即可\n\n2. 安装whl包，这个包从[https://link.jianshu.com/?t=http://www.lfd.uci.edu/~gohlke/pythonlibs/](https://link.jianshu.com/?t=http://www.lfd.uci.edu/~gohlke/pythonlibs/)去获取，\n\n![](https://img2018.cnblogs.com/blog/411616/201904/411616-20190408135406204-3297367.png#align=left&display=inline&height=128&originHeight=128&originWidth=705&status=done&width=705)\n\n下载相应的版本，然后通过pip install 安装下载好的whl文件\n\n3. 然后再执行pip install mysql-python\n\n<a name=\"7a0a21d5\"></a>\n# 后记\n是经过多次尝试后，成功了，其中也安装过vcforpython，说是因为windows缺少编译组件，如果上面步骤不成功，可以尝试安装下这个编译环境\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8e1b944f\">背景</h1><p>新公司，对换工作了！接口自动化使用的是python的behave框架，因此需要折腾python了，而公司配的笔记本是windows的，因此要在windows下折腾python了</p><p><br /></p><h1 id=\"52b36576\">步骤</h1><p>项目中使用的setup.py文件来管理依赖的，通过ide直接安装依赖的时候提供mysql-python安装失败，如下</p><p><br /></p><p>MySQLdb/_mysql.c(29) : fatal error C1083: Cannot open include file: 'mysql.h': No such file or directory</p><p><br /></p><p>还有其他的各种错误，一顿google最后还是解决了</p><p><br /></p><p>1. 安装wheel，通过pip install wheel安装即可</p><p><br /></p><p>2. 安装whl包，这个包从<a href=\"https://link.jianshu.com/?t=http://www.lfd.uci.edu/~gohlke/pythonlibs/\" target=\"_blank\">https://link.jianshu.com/?t=http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>去获取，</p><p><br /></p><p><img src=\"https://img2018.cnblogs.com/blog/411616/201904/411616-20190408135406204-3297367.png#align=left&amp;display=inline&amp;height=128&amp;originHeight=128&amp;originWidth=705&amp;status=done&amp;width=705\" style=\"max-width: 600px; width: 705px;\" /></p><p><br /></p><p>下载相应的版本，然后通过pip install 安装下载好的whl文件</p><p><br /></p><p>3. 然后再执行pip install mysql-python</p><p><br /></p><h1 id=\"7a0a21d5\">后记</h1><p>是经过多次尝试后，成功了，其中也安装过vcforpython，说是因为windows缺少编译组件，如果上面步骤不成功，可以尝试安装下这个编译环境</p>",
    "body_lake": "<!doctype lake><h1 id=\"8e1b944f\">背景</h1><p>新公司，对换工作了！接口自动化使用的是python的behave框架，因此需要折腾python了，而公司配的笔记本是windows的，因此要在windows下折腾python了</p><p><br /></p><h1 id=\"52b36576\">步骤</h1><p>项目中使用的setup.py文件来管理依赖的，通过ide直接安装依赖的时候提供mysql-python安装失败，如下</p><p><br /></p><p>MySQLdb/_mysql.c(29) : fatal error C1083: Cannot open include file: 'mysql.h': No such file or directory</p><p><br /></p><p>还有其他的各种错误，一顿google最后还是解决了</p><p><br /></p><p>1. 安装wheel，通过pip install wheel安装即可</p><p><br /></p><p>2. 安装whl包，这个包从<a href=\"https://link.jianshu.com/?t=http://www.lfd.uci.edu/~gohlke/pythonlibs/\" target=\"_blank\">https://link.jianshu.com/?t=http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>去获取，</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F411616%2F201904%2F411616-20190408135406204-3297367.png%22%2C%22originWidth%22%3A705%2C%22originHeight%22%3A128%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A705%2C%22height%22%3A128%7D\"></card></p><p><br /></p><p>下载相应的版本，然后通过pip install 安装下载好的whl文件</p><p><br /></p><p>3. 然后再执行pip install mysql-python</p><p><br /></p><h1 id=\"7a0a21d5\">后记<cursor /></h1><p>是经过多次尝试后，成功了，其中也安装过vcforpython，说是因为windows缺少编译组件，如果上面步骤不成功，可以尝试安装下这个编译环境</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T07:53:31.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T07:52:53.000Z",
    "updated_at": "2019-04-16T07:53:31.000Z",
    "published_at": "2019-04-16T07:53:31.000Z",
    "first_published_at": null,
    "word_count": 251,
    "cover": null,
    "description": "背景新公司，对换工作了！接口自动化使用的是python的behave框架，因此需要折腾python了，而公司配的笔记本是windows的，因此要在windows下折腾python了步骤项目中使用的setup.py文件来管理依赖的，通过ide直接安装依赖的时候提供mysql-python安装失败...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1545045,
    "slug": "obvprg",
    "title": "python- 动态加载目录下所有的类",
    "book_id": 271801,
    "book": {
      "id": 271801,
      "type": "Book",
      "slug": "testway",
      "name": "测试之路",
      "user_id": 92887,
      "description": "",
      "creator_id": 92887,
      "public": 1,
      "items_count": 45,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-07-16T12:16:18.220Z",
      "updated_at": "2019-07-16T12:16:18.000Z",
      "created_at": "2019-04-16T07:37:07.000Z",
      "namespace": "qianwang/testway",
      "user": {
        "id": 92887,
        "type": "User",
        "login": "qianwang",
        "name": "千往",
        "description": "不想当产品的开发不是好测试",
        "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
        "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 8,
        "following_count": 0,
        "created_at": "2018-03-12T13:01:17.000Z",
        "updated_at": "2019-05-23T14:35:40.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 92887,
    "creator": {
      "id": 92887,
      "type": "User",
      "login": "qianwang",
      "name": "千往",
      "description": "不想当产品的开发不是好测试",
      "avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg",
      "large_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://lark-assets-prod.oss-cn-hangzhou.aliyuncs.com/2018/jpeg/avatar/c459e622-38b0-497a-91e4-1137c6299b1f.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 8,
      "following_count": 0,
      "created_at": "2018-03-12T13:01:17.000Z",
      "updated_at": "2019-05-23T14:35:40.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"8e1b944f\"></a>\n# 背景\n\n自动化测试框架中model层下有很多类，用来操作mysql的，使用的时候需要把全部的类加载进来，需要使用到动态加载类\n\n<a name=\"957a228f\"></a>\n# 解决方法\n\n使用pkgutil，内置的方法，常用的话有两个方法<br />iter_modules(path=None, prefix='')<br />Yields (module_loader, name, ispkg) for all submodules on path, or, if path is None, all top-level modules on sys.path.<br />path是包的目录路径，prefix是输出时，所有包的名字的前缀。用来获取该path下的子模块或子包。\n\nwalk_packages(path=None, prefix='', onerror=None)<br />Yields (module_loader, name, ispkg) for all modules recursively on path, or, if path is None, all accessible modules.<br />同上，但是这个方法是递归获取路径下的所有模块。<br />具体使用如下：\n\n```python\n# 动态加载modelsql中所有类\nfor importer_sql, modname, ispkg_sql in pkgutil.walk_packages(path=modelsql.path,\n\nprefix=modelsql.name+'.',\n\nonerror=lambda x: None):\n\nexec('from ' + modname + ' import *')\n```\n\n相当于对目录下所有的类执行了import *的操作\n\n",
    "body_draft": "",
    "body_html": "<h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>自动化测试框架中model层下有很多类，用来操作mysql的，使用的时候需要把全部的类加载进来，需要使用到动态加载类</p><p><br /></p><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p>使用pkgutil，内置的方法，常用的话有两个方法</p><p>iter_modules(path=None, prefix='')</p><p>Yields (module_loader, name, ispkg) for all submodules on path, or, if path is None, all top-level modules on sys.path.</p><p>path是包的目录路径，prefix是输出时，所有包的名字的前缀。用来获取该path下的子模块或子包。</p><p><br /></p><p>walk_packages(path=None, prefix='', onerror=None)</p><p>Yields (module_loader, name, ispkg) for all modules recursively on path, or, if path is None, all accessible modules.</p><p>同上，但是这个方法是递归获取路径下的所有模块。</p><p>具体使用如下：</p><p><br /></p><pre data-lang=\"python\"><code># 动态加载modelsql中所有类\nfor importer_sql, modname, ispkg_sql in pkgutil.walk_packages(path=modelsql.path,\n\nprefix=modelsql.name+'.',\n\nonerror=lambda x: None):\n\nexec('from ' + modname + ' import *')</code></pre><p><br /></p><p>相当于对目录下所有的类执行了import *的操作</p><p><br /></p>",
    "body_lake": "<!doctype lake><h1 id=\"8e1b944f\">背景</h1><p><br /></p><p>自动化测试框架中model层下有很多类，用来操作mysql的，使用的时候需要把全部的类加载进来，需要使用到动态加载类</p><p><br /></p><h1 id=\"957a228f\">解决方法</h1><p><br /></p><p>使用pkgutil，内置的方法，常用的话有两个方法</p><p>iter_modules(path=None, prefix='')</p><p>Yields (module_loader, name, ispkg) for all submodules on path, or, if path is None, all top-level modules on sys.path.</p><p>path是包的目录路径，prefix是输出时，所有包的名字的前缀。用来获取该path下的子模块或子包。</p><p><br /></p><p>walk_packages(path=None, prefix='', onerror=None)</p><p>Yields (module_loader, name, ispkg) for all modules recursively on path, or, if path is None, all accessible modules.</p><p>同上，但是这个方法是递归获取路径下的所有模块。</p><p>具体使用如下：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22python%22%2C%22code%22%3A%22%23%20%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDmodelsql%E4%B8%AD%E6%89%80%E6%9C%89%E7%B1%BB%5Cnfor%20importer_sql%2C%20modname%2C%20ispkg_sql%20in%20pkgutil.walk_packages(path%3Dmodelsql.path%2C%5Cn%5Cnprefix%3Dmodelsql.name%2B'.'%2C%5Cn%5Cnonerror%3Dlambda%20x%3A%20None)%3A%5Cn%5Cnexec('from%20'%20%2B%20modname%20%2B%20'%20import%20*')%22%2C%22id%22%3A%22aw9fE%22%7D\"></card><p><br /></p><p>相当于对目录下所有的类执行了import *的操作</p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-16T07:39:04.000Z",
    "deleted_at": null,
    "created_at": "2019-04-16T07:38:01.000Z",
    "updated_at": "2019-04-16T07:39:04.000Z",
    "published_at": "2019-04-16T07:39:04.000Z",
    "first_published_at": "2019-04-16T07:39:04.000Z",
    "word_count": 233,
    "cover": null,
    "description": "背景自动化测试框架中model层下有很多类，用来操作mysql的，使用的时候需要把全部的类加载进来，需要使用到动态加载类解决方法使用pkgutil，内置的方法，常用的话有两个方法iter_modules(path=None, prefix='')Yields (module_loader, n...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  }
]